(window.webpackJsonp = window.webpackJsonp || []).push([[1], { "+gph": function (t, e) { t.exports = Object.keys || function (t) { var e = [], n = Object.prototype.hasOwnProperty; for (var i in t) n.call(t, i) && e.push(i); return e } }, 0: function (t, e, n) { t.exports = n("zUnb") }, "0ls1": function (t, e, n) { t.exports = n("weDv"), t.exports.parser = n("nbjS") }, 1: function (t, e) { }, "14A5": function (t, e) { var n = void 0 !== n ? n : "undefined" != typeof WebKitBlobBuilder ? WebKitBlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder && MozBlobBuilder, i = function () { try { return 2 === new Blob(["hi"]).size } catch (t) { return !1 } }(), r = i && function () { try { return 2 === new Blob([new Uint8Array([1, 2])]).size } catch (t) { return !1 } }(), s = n && n.prototype.append && n.prototype.getBlob; function o(t) { return t.map((function (t) { if (t.buffer instanceof ArrayBuffer) { var e = t.buffer; if (t.byteLength !== e.byteLength) { var n = new Uint8Array(t.byteLength); n.set(new Uint8Array(e, t.byteOffset, t.byteLength)), e = n.buffer } return e } return t })) } function a(t, e) { e = e || {}; var i = new n; return o(t).forEach((function (t) { i.append(t) })), e.type ? i.getBlob(e.type) : i.getBlob() } function l(t, e) { return new Blob(o(t), e || {}) } "undefined" != typeof Blob && (a.prototype = Blob.prototype, l.prototype = Blob.prototype), t.exports = i ? r ? Blob : l : s ? a : void 0 }, "17fY": function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"; e.definition = { prefix: "fas", iconName: "spinner", icon: [512, 512, i, "f110", r] }, e.faSpinner = e.definition, e.prefix = "fas", e.iconName = "spinner", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f110", e.svgPathData = r }, "1nsi": function (t, e) { var n, i, r, s = String.fromCharCode; function o(t) { for (var e, n, i = [], r = 0, s = t.length; r < s;)(e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < s ? 56320 == (64512 & (n = t.charCodeAt(r++))) ? i.push(((1023 & e) << 10) + (1023 & n) + 65536) : (i.push(e), r--) : i.push(e); return i } function a(t, e) { if (t >= 55296 && t <= 57343) { if (e) throw Error("Lone surrogate U+" + t.toString(16).toUpperCase() + " is not a scalar value"); return !1 } return !0 } function l(t, e) { return s(t >> e & 63 | 128) } function c(t, e) { if (0 == (4294967168 & t)) return s(t); var n = ""; return 0 == (4294965248 & t) ? n = s(t >> 6 & 31 | 192) : 0 == (4294901760 & t) ? (a(t, e) || (t = 65533), n = s(t >> 12 & 15 | 224), n += l(t, 6)) : 0 == (4292870144 & t) && (n = s(t >> 18 & 7 | 240), n += l(t, 12), n += l(t, 6)), n + s(63 & t | 128) } function h() { if (r >= i) throw Error("Invalid byte index"); var t = 255 & n[r]; if (r++, 128 == (192 & t)) return 63 & t; throw Error("Invalid continuation byte") } function u(t) { var e, s; if (r > i) throw Error("Invalid byte index"); if (r == i) return !1; if (e = 255 & n[r], r++, 0 == (128 & e)) return e; if (192 == (224 & e)) { if ((s = (31 & e) << 6 | h()) >= 128) return s; throw Error("Invalid continuation byte") } if (224 == (240 & e)) { if ((s = (15 & e) << 12 | h() << 6 | h()) >= 2048) return a(s, t) ? s : 65533; throw Error("Invalid continuation byte") } if (240 == (248 & e) && (s = (7 & e) << 18 | h() << 12 | h() << 6 | h()) >= 65536 && s <= 1114111) return s; throw Error("Invalid UTF-8 detected") } t.exports = { version: "2.1.2", encode: function (t, e) { for (var n = !1 !== (e = e || {}).strict, i = o(t), r = i.length, s = -1, a = ""; ++s < r;)a += c(i[s], n); return a }, decode: function (t, e) { var a = !1 !== (e = e || {}).strict; n = o(t), i = n.length, r = 0; for (var l, c = []; !1 !== (l = u(a));)c.push(l); return function (t) { for (var e, n = t.length, i = -1, r = ""; ++i < n;)(e = t[i]) > 65535 && (r += s((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), r += s(e); return r }(c) } } }, "3JDX": function (t, e, n) { t.exports = function (t) { function e(t) { let e = 0; for (let n = 0; n < t.length; n++)e = (e << 5) - e + t.charCodeAt(n), e |= 0; return i.colors[Math.abs(e) % i.colors.length] } function i(t) { let n; function o(...t) { if (!o.enabled) return; const e = o, r = Number(new Date); e.diff = r - (n || r), e.prev = n, e.curr = r, n = r, t[0] = i.coerce(t[0]), "string" != typeof t[0] && t.unshift("%O"); let s = 0; t[0] = t[0].replace(/%([a-zA-Z%])/g, (n, r) => { if ("%%" === n) return n; s++; const o = i.formatters[r]; return "function" == typeof o && (n = o.call(e, t[s]), t.splice(s, 1), s--), n }), i.formatArgs.call(e, t), (e.log || i.log).apply(e, t) } return o.namespace = t, o.enabled = i.enabled(t), o.useColors = i.useColors(), o.color = e(t), o.destroy = r, o.extend = s, "function" == typeof i.init && i.init(o), i.instances.push(o), o } function r() { const t = i.instances.indexOf(this); return -1 !== t && (i.instances.splice(t, 1), !0) } function s(t, e) { const n = i(this.namespace + (void 0 === e ? ":" : e) + t); return n.log = this.log, n } function o(t) { return t.toString().substring(2, t.toString().length - 2).replace(/\.\*\?$/, "*") } return i.debug = i, i.default = i, i.coerce = function (t) { return t instanceof Error ? t.stack || t.message : t }, i.disable = function () { const t = [...i.names.map(o), ...i.skips.map(o).map(t => "-" + t)].join(","); return i.enable(""), t }, i.enable = function (t) { let e; i.save(t), i.names = [], i.skips = []; const n = ("string" == typeof t ? t : "").split(/[\s,]+/), r = n.length; for (e = 0; e < r; e++)n[e] && ("-" === (t = n[e].replace(/\*/g, ".*?"))[0] ? i.skips.push(new RegExp("^" + t.substr(1) + "$")) : i.names.push(new RegExp("^" + t + "$"))); for (e = 0; e < i.instances.length; e++) { const t = i.instances[e]; t.enabled = i.enabled(t.namespace) } }, i.enabled = function (t) { if ("*" === t[t.length - 1]) return !0; let e, n; for (e = 0, n = i.skips.length; e < n; e++)if (i.skips[e].test(t)) return !1; for (e = 0, n = i.names.length; e < n; e++)if (i.names[e].test(t)) return !0; return !1 }, i.humanize = n("FGiv"), Object.keys(t).forEach(e => { i[e] = t[e] }), i.instances = [], i.names = [], i.skips = [], i.formatters = {}, i.selectColor = e, i.enable(i.load()), i } }, "3dqp": function (t, e, n) { function i(t) { if (t) return function (t) { for (var e in i.prototype) t[e] = i.prototype[e]; return t }(t) } t.exports = i, i.prototype.on = i.prototype.addEventListener = function (t, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this }, i.prototype.once = function (t, e) { function n() { this.off(t, n), e.apply(this, arguments) } return n.fn = e, this.on(t, n), this }, i.prototype.off = i.prototype.removeListener = i.prototype.removeAllListeners = i.prototype.removeEventListener = function (t, e) { if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this; var n, i = this._callbacks["$" + t]; if (!i) return this; if (1 == arguments.length) return delete this._callbacks["$" + t], this; for (var r = 0; r < i.length; r++)if ((n = i[r]) === e || n.fn === e) { i.splice(r, 1); break } return this }, i.prototype.emit = function (t) { this._callbacks = this._callbacks || {}; var e = [].slice.call(arguments, 1), n = this._callbacks["$" + t]; if (n) for (var i = 0, r = (n = n.slice(0)).length; i < r; ++i)n[i].apply(this, e); return this }, i.prototype.listeners = function (t) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [] }, i.prototype.hasListeners = function (t) { return !!this.listeners(t).length } }, "4MzN": function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M512 176.001C512 273.203 433.202 352 336 352c-11.22 0-22.19-1.062-32.827-3.069l-24.012 27.014A23.999 23.999 0 0 1 261.223 384H224v40c0 13.255-10.745 24-24 24h-40v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24v-78.059c0-6.365 2.529-12.47 7.029-16.971l161.802-161.802C163.108 213.814 160 195.271 160 176 160 78.798 238.797.001 335.999 0 433.488-.001 512 78.511 512 176.001zM336 128c0 26.51 21.49 48 48 48s48-21.49 48-48-21.49-48-48-48-48 21.49-48 48z"; e.definition = { prefix: "fas", iconName: "key", icon: [512, 512, i, "f084", r] }, e.faKey = e.definition, e.prefix = "fas", e.iconName = "key", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f084", e.svgPathData = r }, "4jMP": function (t, e, n) { var i = n("bOPS"), r = n("uXkJ"), s = n("Wfuu"), o = n("NOtv")("socket.io-client"); t.exports = e = l; var a = e.managers = {}; function l(t, e) { "object" == typeof t && (e = t, t = void 0), e = e || {}; var n, r = i(t), l = r.source, c = r.id; return e.forceNew || e["force new connection"] || !1 === e.multiplex || a[c] && r.path in a[c].nsps ? (o("ignoring socket cache for %s", l), n = s(l, e)) : (a[c] || (o("new io instance for %s", l), a[c] = s(l, e)), n = a[c]), r.query && !e.query && (e.query = r.query), n.socket(r.path, e) } e.protocol = r.protocol, e.connect = l, e.Manager = n("Wfuu"), e.Socket = n("vjuW") }, "5KXg": function (t, e, n) { function i() { var t; try { t = e.storage.debug } catch (n) { } return !t && "undefined" != typeof process && "env" in process && (t = process.env.DEBUG), t } (e = t.exports = n("brUr")).log = function () { return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments) }, e.formatArgs = function (t) { var n = this.useColors; if (t[0] = (n ? "%c" : "") + this.namespace + (n ? " %c" : " ") + t[0] + (n ? "%c " : " ") + "+" + e.humanize(this.diff), n) { var i = "color: " + this.color; t.splice(1, 0, i, "color: inherit"); var r = 0, s = 0; t[0].replace(/%[a-zA-Z%]/g, (function (t) { "%%" !== t && (r++, "%c" === t && (s = r)) })), t.splice(s, 0, i) } }, e.save = function (t) { try { null == t ? e.storage.removeItem("debug") : e.storage.debug = t } catch (n) { } }, e.load = i, e.useColors = function () { return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, e.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function () { try { return window.localStorage } catch (t) { } }(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e.formatters.j = function (t) { try { return JSON.stringify(t) } catch (e) { return "[UnexpectedJSONParseError]: " + e.message } }, e.enable(i()) }, "6C75": function (t, e) { var n = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t) } }, "7jRU": function (t, e) { var n = [].indexOf; t.exports = function (t, e) { if (n) return t.indexOf(e); for (var i = 0; i < t.length; ++i)if (t[i] === e) return i; return -1 } }, "7snx": function (t, e, n) { var i = n("9WME"), r = n("TypT"), s = n("nbjS"), o = n("Yvos"), a = n("Aplp"), l = n("NOtv")("engine.io-client:polling"); t.exports = h; var c = null != new (n("nY9P"))({ xdomain: !1 }).responseType; function h(t) { c && !(t && t.forceBase64) || (this.supportsBinary = !1), i.call(this, t) } o(h, i), h.prototype.name = "polling", h.prototype.doOpen = function () { this.poll() }, h.prototype.pause = function (t) { var e = this; function n() { l("paused"), e.readyState = "paused", t() } if (this.readyState = "pausing", this.polling || !this.writable) { var i = 0; this.polling && (l("we are currently polling - waiting to pause"), i++, this.once("pollComplete", (function () { l("pre-pause polling complete"), --i || n() }))), this.writable || (l("we are currently writing - waiting to pause"), i++, this.once("drain", (function () { l("pre-pause writing complete"), --i || n() }))) } else n() }, h.prototype.poll = function () { l("polling"), this.polling = !0, this.doPoll(), this.emit("poll") }, h.prototype.onData = function (t) { var e = this; l("polling got data %s", t), s.decodePayload(t, this.socket.binaryType, (function (t, n, i) { if ("opening" === e.readyState && e.onOpen(), "close" === t.type) return e.onClose(), !1; e.onPacket(t) })), "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : l('ignoring poll - transport state "%s"', this.readyState)) }, h.prototype.doClose = function () { var t = this; function e() { l("writing close packet"), t.write([{ type: "close" }]) } "open" === this.readyState ? (l("transport open - closing"), e()) : (l("transport not open - deferring close"), this.once("open", e)) }, h.prototype.write = function (t) { var e = this; this.writable = !1; var n = function () { e.writable = !0, e.emit("drain") }; s.encodePayload(t, this.supportsBinary, (function (t) { e.doWrite(t, n) })) }, h.prototype.uri = function () { var t = this.query || {}, e = this.secure ? "https" : "http", n = ""; return !1 !== this.timestampRequests && (t[this.timestampParam] = a()), this.supportsBinary || t.sid || (t.b64 = 1), t = r.encode(t), this.port && ("https" === e && 443 !== Number(this.port) || "http" === e && 80 !== Number(this.port)) && (n = ":" + this.port), t.length && (t = "?" + t), e + "://" + (-1 !== this.hostname.indexOf(":") ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t } }, "9WME": function (t, e, n) { var i = n("nbjS"), r = n("3dqp"); function s(t) { this.path = t.path, this.hostname = t.hostname, this.port = t.port, this.secure = t.secure, this.query = t.query, this.timestampParam = t.timestampParam, this.timestampRequests = t.timestampRequests, this.readyState = "", this.agent = t.agent || !1, this.socket = t.socket, this.enablesXDR = t.enablesXDR, this.withCredentials = t.withCredentials, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.forceNode = t.forceNode, this.isReactNative = t.isReactNative, this.extraHeaders = t.extraHeaders, this.localAddress = t.localAddress } t.exports = s, r(s.prototype), s.prototype.onError = function (t, e) { var n = new Error(t); return n.type = "TransportError", n.description = e, this.emit("error", n), this }, s.prototype.open = function () { return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this }, s.prototype.close = function () { return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this }, s.prototype.send = function (t) { if ("open" !== this.readyState) throw new Error("Transport not open"); this.write(t) }, s.prototype.onOpen = function () { this.readyState = "open", this.writable = !0, this.emit("open") }, s.prototype.onData = function (t) { var e = i.decodePacket(t, this.socket.binaryType); this.onPacket(e) }, s.prototype.onPacket = function (t) { this.emit("packet", t) }, s.prototype.onClose = function () { this.readyState = "closed", this.emit("close") } }, Aplp: function (t, e, n) { "use strict"; var i, r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), s = {}, o = 0, a = 0; function l(t) { var e = ""; do { e = r[t % 64] + e, t = Math.floor(t / 64) } while (t > 0); return e } function c() { var t = l(+new Date); return t !== i ? (o = 0, i = t) : t + "." + l(o++) } for (; a < 64; a++)s[r[a]] = a; c.encode = l, c.decode = function (t) { var e = 0; for (a = 0; a < t.length; a++)e = 64 * e + s[t.charAt(a)]; return e }, t.exports = c }, BA80: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M0 168v-16c0-13.255 10.745-24 24-24h360V80c0-21.367 25.899-32.042 40.971-16.971l80 80c9.372 9.373 9.372 24.569 0 33.941l-80 80C409.956 271.982 384 261.456 384 240v-48H24c-13.255 0-24-10.745-24-24zm488 152H128v-48c0-21.314-25.862-32.08-40.971-16.971l-80 80c-9.372 9.373-9.372 24.569 0 33.941l80 80C102.057 463.997 128 453.437 128 432v-48h360c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24z"; e.definition = { prefix: "fas", iconName: "exchange-alt", icon: [512, 512, i, "f362", r] }, e.faExchangeAlt = e.definition, e.prefix = "fas", e.iconName = "exchange-alt", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f362", e.svgPathData = r }, C2QD: function (t, e) { function n(t) { this.ms = (t = t || {}).min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0 } t.exports = n, n.prototype.duration = function () { var t = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(), n = Math.floor(e * this.jitter * t); t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n } return 0 | Math.min(t, this.max) }, n.prototype.reset = function () { this.attempts = 0 }, n.prototype.setMin = function (t) { this.ms = t }, n.prototype.setMax = function (t) { this.max = t }, n.prototype.setJitter = function (t) { this.jitter = t } }, "F/Mi": function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"; e.definition = { prefix: "fas", iconName: "user-circle", icon: [496, 512, i, "f2bd", r] }, e.faUserCircle = e.definition, e.prefix = "fas", e.iconName = "user-circle", e.width = 496, e.height = 512, e.ligatures = i, e.unicode = "f2bd", e.svgPathData = r }, FGiv: function (t, e) { var n = 1e3, i = 6e4, r = 60 * i, s = 24 * r; function o(t, e, n, i) { var r = e >= 1.5 * n; return Math.round(t / n) + " " + i + (r ? "s" : "") } t.exports = function (t, e) { e = e || {}; var a, l, c = typeof t; if ("string" === c && t.length > 0) return function (t) { if (!((t = String(t)).length > 100)) { var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t); if (e) { var o = parseFloat(e[1]); switch ((e[2] || "ms").toLowerCase()) { case "years": case "year": case "yrs": case "yr": case "y": return 315576e5 * o; case "weeks": case "week": case "w": return 6048e5 * o; case "days": case "day": case "d": return o * s; case "hours": case "hour": case "hrs": case "hr": case "h": return o * r; case "minutes": case "minute": case "mins": case "min": case "m": return o * i; case "seconds": case "second": case "secs": case "sec": case "s": return o * n; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return o; default: return } } } }(t); if ("number" === c && isFinite(t)) return e.long ? (a = t, (l = Math.abs(a)) >= s ? o(a, l, s, "day") : l >= r ? o(a, l, r, "hour") : l >= i ? o(a, l, i, "minute") : l >= n ? o(a, l, n, "second") : a + " ms") : function (t) { var e = Math.abs(t); return e >= s ? Math.round(t / s) + "d" : e >= r ? Math.round(t / r) + "h" : e >= i ? Math.round(t / i) + "m" : e >= n ? Math.round(t / n) + "s" : t + "ms" }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)) } }, Gt99: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"; e.definition = { prefix: "fas", iconName: "search", icon: [512, 512, i, "f002", r] }, e.faSearch = e.definition, e.prefix = "fas", e.iconName = "search", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f002", e.svgPathData = r }, LSMI: function (t, e, n) { var i = n("nY9P"), r = n("7snx"), s = n("3dqp"), o = n("Yvos"), a = n("NOtv")("engine.io-client:polling-xhr"), l = n("opsh"); function c() { } function h(t) { if (r.call(this, t), this.requestTimeout = t.requestTimeout, this.extraHeaders = t.extraHeaders, "undefined" != typeof location) { var e = "https:" === location.protocol, n = location.port; n || (n = e ? 443 : 80), this.xd = "undefined" != typeof location && t.hostname !== location.hostname || n !== t.port, this.xs = t.secure !== e } } function u(t) { this.method = t.method || "GET", this.uri = t.uri, this.xd = !!t.xd, this.xs = !!t.xs, this.async = !1 !== t.async, this.data = void 0 !== t.data ? t.data : null, this.agent = t.agent, this.isBinary = t.isBinary, this.supportsBinary = t.supportsBinary, this.enablesXDR = t.enablesXDR, this.withCredentials = t.withCredentials, this.requestTimeout = t.requestTimeout, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.extraHeaders = t.extraHeaders, this.create() } function d() { for (var t in u.requests) u.requests.hasOwnProperty(t) && u.requests[t].abort() } t.exports = h, t.exports.Request = u, o(h, r), h.prototype.supportsBinary = !0, h.prototype.request = function (t) { return (t = t || {}).uri = this.uri(), t.xd = this.xd, t.xs = this.xs, t.agent = this.agent || !1, t.supportsBinary = this.supportsBinary, t.enablesXDR = this.enablesXDR, t.withCredentials = this.withCredentials, t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized, t.requestTimeout = this.requestTimeout, t.extraHeaders = this.extraHeaders, new u(t) }, h.prototype.doWrite = function (t, e) { var n = this.request({ method: "POST", data: t, isBinary: "string" != typeof t && void 0 !== t }), i = this; n.on("success", e), n.on("error", (function (t) { i.onError("xhr post error", t) })), this.sendXhr = n }, h.prototype.doPoll = function () { a("xhr poll"); var t = this.request(), e = this; t.on("data", (function (t) { e.onData(t) })), t.on("error", (function (t) { e.onError("xhr poll error", t) })), this.pollXhr = t }, s(u.prototype), u.prototype.create = function () { var t = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR }; t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized; var e = this.xhr = new i(t), n = this; try { a("xhr open %s: %s", this.method, this.uri), e.open(this.method, this.uri, this.async); try { if (this.extraHeaders) for (var r in e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0), this.extraHeaders) this.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.extraHeaders[r]) } catch (s) { } if ("POST" === this.method) try { e.setRequestHeader("Content-type", this.isBinary ? "application/octet-stream" : "text/plain;charset=UTF-8") } catch (s) { } try { e.setRequestHeader("Accept", "*/*") } catch (s) { } "withCredentials" in e && (e.withCredentials = this.withCredentials), this.requestTimeout && (e.timeout = this.requestTimeout), this.hasXDR() ? (e.onload = function () { n.onLoad() }, e.onerror = function () { n.onError(e.responseText) }) : e.onreadystatechange = function () { if (2 === e.readyState) try { var t = e.getResponseHeader("Content-Type"); (n.supportsBinary && "application/octet-stream" === t || "application/octet-stream; charset=UTF-8" === t) && (e.responseType = "arraybuffer") } catch (s) { } 4 === e.readyState && (200 === e.status || 1223 === e.status ? n.onLoad() : setTimeout((function () { n.onError("number" == typeof e.status ? e.status : 0) }), 0)) }, a("xhr data %s", this.data), e.send(this.data) } catch (s) { return void setTimeout((function () { n.onError(s) }), 0) } "undefined" != typeof document && (this.index = u.requestsCount++, u.requests[this.index] = this) }, u.prototype.onSuccess = function () { this.emit("success"), this.cleanup() }, u.prototype.onData = function (t) { this.emit("data", t), this.onSuccess() }, u.prototype.onError = function (t) { this.emit("error", t), this.cleanup(!0) }, u.prototype.cleanup = function (t) { if (null != this.xhr) { if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = c : this.xhr.onreadystatechange = c, t) try { this.xhr.abort() } catch (e) { } "undefined" != typeof document && delete u.requests[this.index], this.xhr = null } }, u.prototype.onLoad = function () { var t; try { var e; try { e = this.xhr.getResponseHeader("Content-Type") } catch (n) { } t = ("application/octet-stream" === e || "application/octet-stream; charset=UTF-8" === e) && this.xhr.response || this.xhr.responseText } catch (n) { this.onError(n) } null != t && this.onData(t) }, u.prototype.hasXDR = function () { return "undefined" != typeof XDomainRequest && !this.xs && this.enablesXDR }, u.prototype.abort = function () { this.cleanup() }, u.requestsCount = 0, u.requests = {}, "undefined" != typeof document && ("function" == typeof attachEvent ? attachEvent("onunload", d) : "function" == typeof addEventListener && addEventListener("onpagehide" in l ? "pagehide" : "unload", d, !1)) }, N2Ba: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M360 0H24C10.745 0 0 10.745 0 24v16c0 13.255 10.745 24 24 24 0 90.965 51.016 167.734 120.842 192C75.016 280.266 24 357.035 24 448c-13.255 0-24 10.745-24 24v16c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24 0-90.965-51.016-167.734-120.842-192C308.984 231.734 360 154.965 360 64c13.255 0 24-10.745 24-24V24c0-13.255-10.745-24-24-24zm-64 448H88c0-77.458 46.204-144 104-144 57.786 0 104 66.517 104 144z"; e.definition = { prefix: "fas", iconName: "hourglass-start", icon: [384, 512, i, "f251", r] }, e.faHourglassStart = e.definition, e.prefix = "fas", e.iconName = "hourglass-start", e.width = 384, e.height = 512, e.ligatures = i, e.unicode = "f251", e.svgPathData = r }, NOtv: function (t, e, n) { e.log = function (...t) { return "object" == typeof console && console.log && console.log(...t) }, e.formatArgs = function (e) { if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors) return; const n = "color: " + this.color; e.splice(1, 0, n, "color: inherit"); let i = 0, r = 0; e[0].replace(/%[a-zA-Z%]/g, t => { "%%" !== t && (i++, "%c" === t && (r = i)) }), e.splice(r, 0, n) }, e.save = function (t) { try { t ? e.storage.setItem("debug", t) : e.storage.removeItem("debug") } catch (n) { } }, e.load = function () { let t; try { t = e.storage.getItem("debug") } catch (n) { } return !t && "undefined" != typeof process && "env" in process && (t = process.env.DEBUG), t }, e.useColors = function () { return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, e.storage = function () { try { return localStorage } catch (t) { } }(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.exports = n("3JDX")(e); const { formatters: i } = t.exports; i.j = function (t) { try { return JSON.stringify(t) } catch (e) { return "[UnexpectedJSONParseError]: " + e.message } } }, OTwl: function (t, e, n) { var i = n("WqQy"), r = n("j/BV"), s = Object.prototype.toString, o = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === s.call(Blob), a = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === s.call(File); e.deconstructPacket = function (t) { var e = [], n = t; return n.data = function t(e, n) { if (!e) return e; if (r(e)) { var s = { _placeholder: !0, num: n.length }; return n.push(e), s } if (i(e)) { for (var o = new Array(e.length), a = 0; a < e.length; a++)o[a] = t(e[a], n); return o } if ("object" == typeof e && !(e instanceof Date)) { for (var l in o = {}, e) o[l] = t(e[l], n); return o } return e }(t.data, e), n.attachments = e.length, { packet: n, buffers: e } }, e.reconstructPacket = function (t, e) { return t.data = function t(e, n) { if (!e) return e; if (e && e._placeholder) return n[e.num]; if (i(e)) for (var r = 0; r < e.length; r++)e[r] = t(e[r], n); else if ("object" == typeof e) for (var s in e) e[s] = t(e[s], n); return e }(t.data, e), t.attachments = void 0, t }, e.removeBlobs = function (t, e) { var n = 0, s = t; !function t(l, c, h) { if (!l) return l; if (o && l instanceof Blob || a && l instanceof File) { n++; var u = new FileReader; u.onload = function () { h ? h[c] = this.result : s = this.result, --n || e(s) }, u.readAsArrayBuffer(l) } else if (i(l)) for (var d = 0; d < l.length; d++)t(l[d], d, l); else if ("object" == typeof l && !r(l)) for (var p in l) t(l[p], p, l) }(s), n || e(s) } }, QN7Q: function (t, e) { var n = [].slice; t.exports = function (t, e) { if ("string" == typeof e && (e = t[e]), "function" != typeof e) throw new Error("bind() requires a function"); var i = n.call(arguments, 2); return function () { return e.apply(t, i.concat(n.call(arguments))) } } }, "TFQ+": function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z"; e.definition = { prefix: "fas", iconName: "circle", icon: [512, 512, i, "f111", r] }, e.faCircle = e.definition, e.prefix = "fas", e.iconName = "circle", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f111", e.svgPathData = r }, TypT: function (t, e) { e.encode = function (t) { var e = ""; for (var n in t) t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n])); return e }, e.decode = function (t) { for (var e = {}, n = t.split("&"), i = 0, r = n.length; i < r; i++) { var s = n[i].split("="); e[decodeURIComponent(s[0])] = decodeURIComponent(s[1]) } return e } }, Uxeu: function (t, e) { var n = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, i = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; t.exports = function (t) { var e = t, r = t.indexOf("["), s = t.indexOf("]"); -1 != r && -1 != s && (t = t.substring(0, r) + t.substring(r, s).replace(/:/g, ";") + t.substring(s, t.length)); for (var o = n.exec(t || ""), a = {}, l = 14; l--;)a[i[l]] = o[l] || ""; return -1 != r && -1 != s && (a.source = e, a.host = a.host.substring(1, a.host.length - 1).replace(/;/g, ":"), a.authority = a.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), a.ipv6uri = !0), a } }, "V/HI": function (t, e) { var n = 1e3, i = 6e4, r = 60 * i, s = 24 * r; function o(t, e, n) { if (!(t < e)) return t < 1.5 * e ? Math.floor(t / e) + " " + n : Math.ceil(t / e) + " " + n + "s" } t.exports = function (t, e) { e = e || {}; var a, l = typeof t; if ("string" === l && t.length > 0) return function (t) { if (!((t = String(t)).length > 100)) { var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t); if (e) { var o = parseFloat(e[1]); switch ((e[2] || "ms").toLowerCase()) { case "years": case "year": case "yrs": case "yr": case "y": return 315576e5 * o; case "days": case "day": case "d": return o * s; case "hours": case "hour": case "hrs": case "hr": case "h": return o * r; case "minutes": case "minute": case "mins": case "min": case "m": return o * i; case "seconds": case "second": case "secs": case "sec": case "s": return o * n; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return o; default: return } } } }(t); if ("number" === l && !1 === isNaN(t)) return e.long ? o(a = t, s, "day") || o(a, r, "hour") || o(a, i, "minute") || o(a, n, "second") || a + " ms" : function (t) { return t >= s ? Math.round(t / s) + "d" : t >= r ? Math.round(t / r) + "h" : t >= i ? Math.round(t / i) + "m" : t >= n ? Math.round(t / n) + "s" : t + "ms" }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)) } }, WLGk: function (t, e, n) { var i = n("6C75"), r = Object.prototype.toString, s = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === r.call(Blob), o = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === r.call(File); t.exports = function t(e) { if (!e || "object" != typeof e) return !1; if (i(e)) { for (var n = 0, r = e.length; n < r; n++)if (t(e[n])) return !0; return !1 } if ("function" == typeof Buffer && Buffer.isBuffer && Buffer.isBuffer(e) || "function" == typeof ArrayBuffer && e instanceof ArrayBuffer || s && e instanceof Blob || o && e instanceof File) return !0; if (e.toJSON && "function" == typeof e.toJSON && 1 === arguments.length) return t(e.toJSON(), !0); for (var a in e) if (Object.prototype.hasOwnProperty.call(e, a) && t(e[a])) return !0; return !1 } }, Wfuu: function (t, e, n) { var i = n("0ls1"), r = n("vjuW"), s = n("3dqp"), o = n("uXkJ"), a = n("n62F"), l = n("QN7Q"), c = n("NOtv")("socket.io-client:manager"), h = n("7jRU"), u = n("C2QD"), d = Object.prototype.hasOwnProperty; function p(t, e) { if (!(this instanceof p)) return new p(t, e); t && "object" == typeof t && (e = t, t = void 0), (e = e || {}).path = e.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = e, this.reconnection(!1 !== e.reconnection), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(e.randomizationFactor || .5), this.backoff = new u({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this.readyState = "closed", this.uri = t, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = []; var n = e.parser || o; this.encoder = new n.Encoder, this.decoder = new n.Decoder, this.autoConnect = !1 !== e.autoConnect, this.autoConnect && this.open() } t.exports = p, p.prototype.emitAll = function () { for (var t in this.emit.apply(this, arguments), this.nsps) d.call(this.nsps, t) && this.nsps[t].emit.apply(this.nsps[t], arguments) }, p.prototype.updateSocketIds = function () { for (var t in this.nsps) d.call(this.nsps, t) && (this.nsps[t].id = this.generateId(t)) }, p.prototype.generateId = function (t) { return ("/" === t ? "" : t + "#") + this.engine.id }, s(p.prototype), p.prototype.reconnection = function (t) { return arguments.length ? (this._reconnection = !!t, this) : this._reconnection }, p.prototype.reconnectionAttempts = function (t) { return arguments.length ? (this._reconnectionAttempts = t, this) : this._reconnectionAttempts }, p.prototype.reconnectionDelay = function (t) { return arguments.length ? (this._reconnectionDelay = t, this.backoff && this.backoff.setMin(t), this) : this._reconnectionDelay }, p.prototype.randomizationFactor = function (t) { return arguments.length ? (this._randomizationFactor = t, this.backoff && this.backoff.setJitter(t), this) : this._randomizationFactor }, p.prototype.reconnectionDelayMax = function (t) { return arguments.length ? (this._reconnectionDelayMax = t, this.backoff && this.backoff.setMax(t), this) : this._reconnectionDelayMax }, p.prototype.timeout = function (t) { return arguments.length ? (this._timeout = t, this) : this._timeout }, p.prototype.maybeReconnectOnOpen = function () { !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect() }, p.prototype.open = p.prototype.connect = function (t, e) { if (c("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this; c("opening %s", this.uri), this.engine = i(this.uri, this.opts); var n = this.engine, r = this; this.readyState = "opening", this.skipReconnect = !1; var s = a(n, "open", (function () { r.onopen(), t && t() })), o = a(n, "error", (function (e) { if (c("connect_error"), r.cleanup(), r.readyState = "closed", r.emitAll("connect_error", e), t) { var n = new Error("Connection error"); n.data = e, t(n) } else r.maybeReconnectOnOpen() })); if (!1 !== this._timeout) { var l = this._timeout; c("connect attempt will timeout after %d", l); var h = setTimeout((function () { c("connect attempt timed out after %d", l), s.destroy(), n.close(), n.emit("error", "timeout"), r.emitAll("connect_timeout", l) }), l); this.subs.push({ destroy: function () { clearTimeout(h) } }) } return this.subs.push(s), this.subs.push(o), this }, p.prototype.onopen = function () { c("open"), this.cleanup(), this.readyState = "open", this.emit("open"); var t = this.engine; this.subs.push(a(t, "data", l(this, "ondata"))), this.subs.push(a(t, "ping", l(this, "onping"))), this.subs.push(a(t, "pong", l(this, "onpong"))), this.subs.push(a(t, "error", l(this, "onerror"))), this.subs.push(a(t, "close", l(this, "onclose"))), this.subs.push(a(this.decoder, "decoded", l(this, "ondecoded"))) }, p.prototype.onping = function () { this.lastPing = new Date, this.emitAll("ping") }, p.prototype.onpong = function () { this.emitAll("pong", new Date - this.lastPing) }, p.prototype.ondata = function (t) { this.decoder.add(t) }, p.prototype.ondecoded = function (t) { this.emit("packet", t) }, p.prototype.onerror = function (t) { c("error", t), this.emitAll("error", t) }, p.prototype.socket = function (t, e) { var n = this.nsps[t]; if (!n) { n = new r(this, t, e), this.nsps[t] = n; var i = this; n.on("connecting", s), n.on("connect", (function () { n.id = i.generateId(t) })), this.autoConnect && s() } function s() { ~h(i.connecting, n) || i.connecting.push(n) } return n }, p.prototype.destroy = function (t) { var e = h(this.connecting, t); ~e && this.connecting.splice(e, 1), this.connecting.length || this.close() }, p.prototype.packet = function (t) { c("writing packet %j", t); var e = this; t.query && 0 === t.type && (t.nsp += "?" + t.query), e.encoding ? e.packetBuffer.push(t) : (e.encoding = !0, this.encoder.encode(t, (function (n) { for (var i = 0; i < n.length; i++)e.engine.write(n[i], t.options); e.encoding = !1, e.processPacketQueue() }))) }, p.prototype.processPacketQueue = function () { if (this.packetBuffer.length > 0 && !this.encoding) { var t = this.packetBuffer.shift(); this.packet(t) } }, p.prototype.cleanup = function () { c("cleanup"); for (var t = this.subs.length, e = 0; e < t; e++)this.subs.shift().destroy(); this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy() }, p.prototype.close = p.prototype.disconnect = function () { c("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close() }, p.prototype.onclose = function (t) { c("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", t), this._reconnection && !this.skipReconnect && this.reconnect() }, p.prototype.reconnect = function () { if (this.reconnecting || this.skipReconnect) return this; var t = this; if (this.backoff.attempts >= this._reconnectionAttempts) c("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1; else { var e = this.backoff.duration(); c("will wait %dms before reconnect attempt", e), this.reconnecting = !0; var n = setTimeout((function () { t.skipReconnect || (c("attempting reconnect"), t.emitAll("reconnect_attempt", t.backoff.attempts), t.emitAll("reconnecting", t.backoff.attempts), t.skipReconnect || t.open((function (e) { e ? (c("reconnect attempt error"), t.reconnecting = !1, t.reconnect(), t.emitAll("reconnect_error", e.data)) : (c("reconnect success"), t.onreconnect()) }))) }), e); this.subs.push({ destroy: function () { clearTimeout(n) } }) } }, p.prototype.onreconnect = function () { var t = this.backoff.attempts; this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", t) } }, WiE2: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 448c-110.532 0-200-89.431-200-200 0-110.495 89.472-200 200-200 110.491 0 200 89.471 200 200 0 110.53-89.431 200-200 200zm107.244-255.2c0 67.052-72.421 68.084-72.421 92.863V300c0 6.627-5.373 12-12 12h-45.647c-6.627 0-12-5.373-12-12v-8.659c0-35.745 27.1-50.034 47.579-61.516 17.561-9.845 28.324-16.541 28.324-29.579 0-17.246-21.999-28.693-39.784-28.693-23.189 0-33.894 10.977-48.942 29.969-4.057 5.12-11.46 6.071-16.666 2.124l-27.824-21.098c-5.107-3.872-6.251-11.066-2.644-16.363C184.846 131.491 214.94 112 261.794 112c49.071 0 101.45 38.304 101.45 88.8zM298 368c0 23.159-18.841 42-42 42s-42-18.841-42-42 18.841-42 42-42 42 18.841 42 42z"; e.definition = { prefix: "far", iconName: "question-circle", icon: [512, 512, i, "f059", r] }, e.faQuestionCircle = e.definition, e.prefix = "far", e.iconName = "question-circle", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f059", e.svgPathData = r }, WqQy: function (t, e) { var n = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t) } }, Xa4a: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"; e.definition = { prefix: "fas", iconName: "clock", icon: [512, 512, i, "f017", r] }, e.faClock = e.definition, e.prefix = "fas", e.iconName = "clock", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f017", e.svgPathData = r }, XrrA: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M239.1 6.3l-208 78c-18.7 7-31.1 25-31.1 45v225.1c0 18.2 10.3 34.8 26.5 42.9l208 104c13.5 6.8 29.4 6.8 42.9 0l208-104c16.3-8.1 26.5-24.8 26.5-42.9V129.3c0-20-12.4-37.9-31.1-44.9l-208-78C262 2.2 250 2.2 239.1 6.3zM256 68.4l192 72v1.1l-192 78-192-78v-1.1l192-72zm32 356V275.5l160-65v133.9l-160 80z"; e.definition = { prefix: "fas", iconName: "cube", icon: [512, 512, i, "f1b2", r] }, e.faCube = e.definition, e.prefix = "fas", e.iconName = "cube", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f1b2", e.svgPathData = r }, Y3lY: function (t, e, n) { "use strict"; function i(t, ...e) { return (...n) => t(...e, ...n) } function r(t) { return function (...e) { var n = e.pop(); return t.call(this, e, n) } } n.r(e), n.d(e, "apply", (function () { return i })), n.d(e, "applyEach", (function () { return T })), n.d(e, "applyEachSeries", (function () { return I })), n.d(e, "asyncify", (function () { return h })), n.d(e, "auto", (function () { return L })), n.d(e, "autoInject", (function () { return z })), n.d(e, "cargo", (function () { return q })), n.d(e, "cargoQueue", (function () { return W })), n.d(e, "compose", (function () { return X })), n.d(e, "concat", (function () { return Z })), n.d(e, "concatLimit", (function () { return Q })), n.d(e, "concatSeries", (function () { return J })), n.d(e, "constant", (function () { return tt })), n.d(e, "detect", (function () { return nt })), n.d(e, "detectLimit", (function () { return it })), n.d(e, "detectSeries", (function () { return rt })), n.d(e, "dir", (function () { return ot })), n.d(e, "doUntil", (function () { return lt })), n.d(e, "doWhilst", (function () { return at })), n.d(e, "each", (function () { return ht })), n.d(e, "eachLimit", (function () { return ut })), n.d(e, "eachOf", (function () { return O })), n.d(e, "eachOfLimit", (function () { return S })), n.d(e, "eachOfSeries", (function () { return P })), n.d(e, "eachSeries", (function () { return dt })), n.d(e, "ensureAsync", (function () { return pt })), n.d(e, "every", (function () { return ft })), n.d(e, "everyLimit", (function () { return mt })), n.d(e, "everySeries", (function () { return gt })), n.d(e, "filter", (function () { return bt })), n.d(e, "filterLimit", (function () { return wt })), n.d(e, "filterSeries", (function () { return xt })), n.d(e, "forever", (function () { return Ct })), n.d(e, "groupBy", (function () { return kt })), n.d(e, "groupByLimit", (function () { return St })), n.d(e, "groupBySeries", (function () { return Et })), n.d(e, "log", (function () { return Ot })), n.d(e, "map", (function () { return A })), n.d(e, "mapLimit", (function () { return K })), n.d(e, "mapSeries", (function () { return D })), n.d(e, "mapValues", (function () { return Tt })), n.d(e, "mapValuesLimit", (function () { return At })), n.d(e, "mapValuesSeries", (function () { return Pt })), n.d(e, "memoize", (function () { return Dt })), n.d(e, "nextTick", (function () { return It })), n.d(e, "parallel", (function () { return Mt })), n.d(e, "parallelLimit", (function () { return Lt })), n.d(e, "priorityQueue", (function () { return Bt })), n.d(e, "queue", (function () { return Ft })), n.d(e, "race", (function () { return zt })), n.d(e, "reduce", (function () { return G })), n.d(e, "reduceRight", (function () { return Ht })), n.d(e, "reflect", (function () { return Ut })), n.d(e, "reflectAll", (function () { return $t })), n.d(e, "reject", (function () { return Wt })), n.d(e, "rejectLimit", (function () { return Gt })), n.d(e, "rejectSeries", (function () { return Yt })), n.d(e, "retry", (function () { return Kt })), n.d(e, "retryable", (function () { return Zt })), n.d(e, "seq", (function () { return Y })), n.d(e, "series", (function () { return Jt })), n.d(e, "setImmediate", (function () { return c })), n.d(e, "some", (function () { return te })), n.d(e, "someLimit", (function () { return ee })), n.d(e, "someSeries", (function () { return ne })), n.d(e, "sortBy", (function () { return ie })), n.d(e, "timeout", (function () { return re })), n.d(e, "times", (function () { return oe })), n.d(e, "timesLimit", (function () { return se })), n.d(e, "timesSeries", (function () { return ae })), n.d(e, "transform", (function () { return le })), n.d(e, "tryEach", (function () { return ce })), n.d(e, "unmemoize", (function () { return he })), n.d(e, "until", (function () { return de })), n.d(e, "waterfall", (function () { return pe })), n.d(e, "whilst", (function () { return ue })), n.d(e, "all", (function () { return ft })), n.d(e, "allLimit", (function () { return mt })), n.d(e, "allSeries", (function () { return gt })), n.d(e, "any", (function () { return te })), n.d(e, "anyLimit", (function () { return ee })), n.d(e, "anySeries", (function () { return ne })), n.d(e, "find", (function () { return nt })), n.d(e, "findLimit", (function () { return it })), n.d(e, "findSeries", (function () { return rt })), n.d(e, "flatMap", (function () { return Z })), n.d(e, "flatMapLimit", (function () { return Q })), n.d(e, "flatMapSeries", (function () { return J })), n.d(e, "forEach", (function () { return ht })), n.d(e, "forEachSeries", (function () { return dt })), n.d(e, "forEachLimit", (function () { return ut })), n.d(e, "forEachOf", (function () { return O })), n.d(e, "forEachOfSeries", (function () { return P })), n.d(e, "forEachOfLimit", (function () { return S })), n.d(e, "inject", (function () { return G })), n.d(e, "foldl", (function () { return G })), n.d(e, "foldr", (function () { return Ht })), n.d(e, "select", (function () { return bt })), n.d(e, "selectLimit", (function () { return wt })), n.d(e, "selectSeries", (function () { return xt })), n.d(e, "wrapSync", (function () { return h })), n.d(e, "during", (function () { return ue })), n.d(e, "doDuring", (function () { return at })); var s = "function" == typeof setImmediate && setImmediate, o = "object" == typeof process && "function" == typeof process.nextTick; function a(t) { setTimeout(t, 0) } function l(t) { return (e, ...n) => t(() => e(...n)) } var c = l(s ? setImmediate : o ? process.nextTick : a); function h(t) { return p(t) ? function (...e) { const n = e.pop(); return u(t.apply(this, e), n) } : r((function (e, n) { var i; try { i = t.apply(this, e) } catch (r) { return n(r) } if (i && "function" == typeof i.then) return u(i, n); n(null, i) })) } function u(t, e) { return t.then(t => { d(e, null, t) }, t => { d(e, t && t.message ? t : new Error(t)) }) } function d(t, e, n) { try { t(e, n) } catch (i) { c(t => { throw t }, i) } } function p(t) { return "AsyncFunction" === t[Symbol.toStringTag] } function f(t) { if ("function" != typeof t) throw new Error("expected a function"); return p(t) ? h(t) : t } function m(t, e = t.length) { if (!e) throw new Error("arity is undefined"); function n(...n) { return "function" == typeof n[e - 1] ? t.apply(this, n) : new Promise((i, r) => { n[e - 1] = (t, ...e) => { if (t) return r(t); i(e.length > 1 ? e : e[0]) }, t.apply(this, n) }) } return Object.defineProperty(n, "name", { value: `awaitable(${t.name})` }), n } function g(t) { return function (e, ...n) { return m((function (i) { var r = this; return t(e, (t, e) => { f(t).apply(r, n.concat(e)) }, i) })) } } function y(t, e, n, i) { e = e || []; var r = [], s = 0, o = f(n); return t(e, (t, e, n) => { var i = s++; o(t, (t, e) => { r[i] = e, n(t) }) }, t => { i(t, r) }) } function _(t) { return t && "number" == typeof t.length && t.length >= 0 && t.length % 1 == 0 } const v = {}; function b(t) { function e(...e) { if (null !== t) { var n = t; t = null, n.apply(this, e) } } return Object.assign(e, t), e } function w(t) { return function (...e) { if (null === t) throw new Error("Callback was already called."); var n = t; t = null, n.apply(this, e) } } function x(t, e, n, i) { let r = !1, s = !1, o = !1, a = 0, l = 0; function c() { a >= e || o || r || (o = !0, t.next().then(({ value: t, done: e }) => { if (!s && !r) { if (o = !1, e) return r = !0, void (a <= 0 && i(null)); a++, n(t, l, h), l++, c() } }).catch(u)) } function h(t, e) { if (a -= 1, !s) return t ? u(t) : !1 === t ? (r = !0, void (s = !0)) : e === v || r && a <= 0 ? (r = !0, i(null)) : void c() } function u(t) { s || (o = !1, r = !0, i(t)) } c() } var C = t => (e, n, i) => { if (i = b(i), t <= 0) throw new RangeError("concurrency limit cannot be less than 1"); if (!e) return i(null); if ("AsyncGenerator" === e[Symbol.toStringTag]) return x(e, t, n, i); if (function (t) { return "function" == typeof t[Symbol.asyncIterator] }(e)) return x(e[Symbol.asyncIterator](), t, n, i); var r = function (t) { if (_(t)) return function (t) { var e = -1, n = t.length; return function () { return ++e < n ? { value: t[e], key: e } : null } }(t); var e, n, i, r, s = function (t) { return t[Symbol.iterator] && t[Symbol.iterator]() }(t); return s ? function (t) { var e = -1; return function () { var n = t.next(); return n.done ? null : (e++, { value: n.value, key: e }) } }(s) : (n = (e = t) ? Object.keys(e) : [], i = -1, r = n.length, function () { var t = n[++i]; return i < r ? { value: e[t], key: t } : null }) }(e), s = !1, o = !1, a = 0, l = !1; function c(t, e) { if (!o) if (a -= 1, t) s = !0, i(t); else if (!1 === t) s = !0, o = !0; else { if (e === v || s && a <= 0) return s = !0, i(null); l || h() } } function h() { for (l = !0; a < t && !s;) { var e = r(); if (null === e) return s = !0, void (a <= 0 && i(null)); a += 1, n(e.value, e.key, w(c)) } l = !1 } h() }, S = m((function (t, e, n, i) { return C(e)(t, f(n), i) }), 4); function k(t, e, n) { n = b(n); var i = 0, r = 0, { length: s } = t, o = !1; function a(t, e) { !1 === t && (o = !0), !0 !== o && (t ? n(t) : ++r !== s && e !== v || n(null)) } for (0 === s && n(null); i < s; i++)e(t[i], i, w(a)) } function E(t, e, n) { return S(t, 1 / 0, e, n) } var O = m((function (t, e, n) { return (_(t) ? k : E)(t, f(e), n) }), 3), A = m((function (t, e, n) { return y(O, t, e, n) }), 3), T = g(A), P = m((function (t, e, n) { return S(t, 1, e, n) }), 3), D = m((function (t, e, n) { return y(P, t, e, n) }), 3), I = g(D); const R = Symbol("promiseCallback"); function M() { let t, e; function n(n, ...i) { if (n) return e(n); t(i.length > 1 ? i : i[0]) } return n[R] = new Promise((n, i) => { t = n, e = i }), n } function L(t, e, n) { "number" != typeof e && (n = e, e = null), n = b(n || M()); var i = Object.keys(t).length; if (!i) return n(null); e || (e = i); var r = {}, s = 0, o = !1, a = !1, l = Object.create(null), c = [], h = [], u = {}; function d(t, e) { c.push(() => function (t, e) { if (!a) { var i = w((e, ...i) => { if (s--, !1 !== e) if (i.length < 2 && ([i] = i), e) { var c = {}; if (Object.keys(r).forEach(t => { c[t] = r[t] }), c[t] = i, a = !0, l = Object.create(null), o) return; n(e, c) } else r[t] = i, (l[t] || []).forEach(t => t()), p(); else o = !0 }); s++; var c = f(e[e.length - 1]); e.length > 1 ? c(r, i) : c(i) } }(t, e)) } function p() { if (!o) { if (0 === c.length && 0 === s) return n(null, r); for (; c.length && s < e;)c.shift()() } } function m(e) { var n = []; return Object.keys(t).forEach(i => { const r = t[i]; Array.isArray(r) && r.indexOf(e) >= 0 && n.push(i) }), n } return Object.keys(t).forEach(e => { var n = t[e]; if (!Array.isArray(n)) return d(e, [n]), void h.push(e); var i = n.slice(0, n.length - 1), r = i.length; if (0 === r) return d(e, n), void h.push(e); u[e] = r, i.forEach(s => { if (!t[s]) throw new Error("async.auto task `" + e + "` has a non-existent dependency `" + s + "` in " + i.join(", ")); var o, a; (a = l[o = s]) || (a = l[o] = []), a.push(() => { 0 == --r && d(e, n) }) }) }), function () { for (var t = 0; h.length;)t++, m(h.pop()).forEach(t => { 0 == --u[t] && h.push(t) }); if (t !== i) throw new Error("async.auto cannot execute tasks due to a recursive dependency") }(), p(), n[R] } var F = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/, N = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/, V = /,/, j = /(=.+)?(\s*)$/, B = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm; function z(t, e) { var n = {}; return Object.keys(t).forEach(e => { var i, r = t[e], s = p(r), o = !s && 1 === r.length || s && 0 === r.length; if (Array.isArray(r)) i = [...r], r = i.pop(), n[e] = i.concat(i.length > 0 ? a : r); else if (o) n[e] = r; else { if (i = function (t) { const e = t.toString().replace(B, ""); let n = e.match(F); if (n || (n = e.match(N)), !n) throw new Error("could not parse args in autoInject\nSource:\n" + e); let [, i] = n; return i.replace(/\s/g, "").split(V).map(t => t.replace(j, "").trim()) }(r), 0 === r.length && !s && 0 === i.length) throw new Error("autoInject task functions require explicit parameters."); s || i.pop(), n[e] = i.concat(a) } function a(t, e) { var n = i.map(e => t[e]); n.push(e), f(r)(...n) } }), L(n, e) } class H { constructor() { this.head = this.tail = null, this.length = 0 } removeLink(t) { return t.prev ? t.prev.next = t.next : this.head = t.next, t.next ? t.next.prev = t.prev : this.tail = t.prev, t.prev = t.next = null, this.length -= 1, t } empty() { for (; this.head;)this.shift(); return this } insertAfter(t, e) { e.prev = t, e.next = t.next, t.next ? t.next.prev = e : this.tail = e, t.next = e, this.length += 1 } insertBefore(t, e) { e.prev = t.prev, e.next = t, t.prev ? t.prev.next = e : this.head = e, t.prev = e, this.length += 1 } unshift(t) { this.head ? this.insertBefore(this.head, t) : U(this, t) } push(t) { this.tail ? this.insertAfter(this.tail, t) : U(this, t) } shift() { return this.head && this.removeLink(this.head) } pop() { return this.tail && this.removeLink(this.tail) } toArray() { return [...this] } *[Symbol.iterator]() { for (var t = this.head; t;)yield t.data, t = t.next } remove(t) { for (var e = this.head; e;) { var { next: n } = e; t(e) && this.removeLink(e), e = n } return this } } function U(t, e) { t.length = 1, t.head = t.tail = e } function $(t, e, n) { if (null == e) e = 1; else if (0 === e) throw new RangeError("Concurrency must not be zero"); var i = f(t), r = 0, s = []; const o = { error: [], drain: [], saturated: [], unsaturated: [], empty: [] }; function a(t, e) { return t ? e ? void (o[t] = o[t].filter(t => t !== e)) : o[t] = [] : Object.keys(o).forEach(t => o[t] = []) } function l(t, ...e) { o[t].forEach(t => t(...e)) } var h = !1; function u(t, e, n, i) { if (null != i && "function" != typeof i) throw new Error("task callback must be a function"); var r, s; function o(t, ...e) { return t ? n ? s(t) : r() : e.length <= 1 ? r(e[0]) : void r(e) } y.started = !0; var a = { data: t, callback: n ? o : i || o }; if (e ? y._tasks.unshift(a) : y._tasks.push(a), h || (h = !0, c(() => { h = !1, y.process() })), n || !i) return new Promise((t, e) => { r = t, s = e }) } function d(t) { return function (e, ...n) { r -= 1; for (var i = 0, o = t.length; i < o; i++) { var a = t[i], c = s.indexOf(a); 0 === c ? s.shift() : c > 0 && s.splice(c, 1), a.callback(e, ...n), null != e && l("error", e, a.data) } r <= y.concurrency - y.buffer && l("unsaturated"), y.idle() && l("drain"), y.process() } } function p(t) { return !(0 !== t.length || !y.idle() || (c(() => l("drain")), 0)) } const m = t => e => { if (!e) return new Promise((e, n) => { !function (t, i) { const r = (...i) => { a(t, r), ((t, i) => { if (t) return n(t); e(i) })(...i) }; o[t].push(r) }(t) }); a(t), function (t, e) { o[t].push(e) }(t, e) }; var g = !1, y = { _tasks: new H, *[Symbol.iterator]() { yield* y._tasks[Symbol.iterator]() }, concurrency: e, payload: n, buffer: e / 4, started: !1, paused: !1, push(t, e) { if (Array.isArray(t)) { if (p(t)) return; return t.map(t => u(t, !1, !1, e)) } return u(t, !1, !1, e) }, pushAsync(t, e) { if (Array.isArray(t)) { if (p(t)) return; return t.map(t => u(t, !1, !0, e)) } return u(t, !1, !0, e) }, kill() { a(), y._tasks.empty() }, unshift(t, e) { if (Array.isArray(t)) { if (p(t)) return; return t.map(t => u(t, !0, !1, e)) } return u(t, !0, !1, e) }, unshiftAsync(t, e) { if (Array.isArray(t)) { if (p(t)) return; return t.map(t => u(t, !0, !0, e)) } return u(t, !0, !0, e) }, remove(t) { y._tasks.remove(t) }, process() { if (!g) { for (g = !0; !y.paused && r < y.concurrency && y._tasks.length;) { var t = [], e = [], n = y._tasks.length; y.payload && (n = Math.min(n, y.payload)); for (var o = 0; o < n; o++) { var a = y._tasks.shift(); t.push(a), s.push(a), e.push(a.data) } r += 1, 0 === y._tasks.length && l("empty"), r === y.concurrency && l("saturated"); var c = w(d(t)); i(e, c) } g = !1 } }, length: () => y._tasks.length, running: () => r, workersList: () => s, idle: () => y._tasks.length + r === 0, pause() { y.paused = !0 }, resume() { !1 !== y.paused && (y.paused = !1, c(y.process)) } }; return Object.defineProperties(y, { saturated: { writable: !1, value: m("saturated") }, unsaturated: { writable: !1, value: m("unsaturated") }, empty: { writable: !1, value: m("empty") }, drain: { writable: !1, value: m("drain") }, error: { writable: !1, value: m("error") } }), y } function q(t, e) { return $(t, 1, e) } function W(t, e, n) { return $(t, e, n) } var G = m((function (t, e, n, i) { i = b(i); var r = f(n); return P(t, (t, n, i) => { r(e, t, (t, n) => { e = n, i(t) }) }, t => i(t, e)) }), 4); function Y(...t) { var e = t.map(f); return function (...t) { var n = this, i = t[t.length - 1]; return "function" == typeof i ? t.pop() : i = M(), G(e, t, (t, e, i) => { e.apply(n, t.concat((t, ...e) => { i(t, e) })) }, (t, e) => i(t, ...e)), i[R] } } function X(...t) { return Y(...t.reverse()) } var K = m((function (t, e, n, i) { return y(C(e), t, n, i) }), 4), Q = m((function (t, e, n, i) { var r = f(n); return K(t, e, (t, e) => { r(t, (t, ...n) => t ? e(t) : e(t, n)) }, (t, e) => { for (var n = [], r = 0; r < e.length; r++)e[r] && (n = n.concat(...e[r])); return i(t, n) }) }), 4), Z = m((function (t, e, n) { return Q(t, 1 / 0, e, n) }), 3), J = m((function (t, e, n) { return Q(t, 1, e, n) }), 3); function tt(...t) { return function (...e) { return e.pop()(null, ...t) } } function et(t, e) { return (n, i, r, s) => { var o, a = !1; const l = f(r); n(i, (n, i, r) => { l(n, (i, s) => i || !1 === i ? r(i) : t(s) && !o ? (a = !0, o = e(!0, n), r(null, v)) : void r()) }, t => { if (t) return s(t); s(null, a ? o : e(!1)) }) } } var nt = m((function (t, e, n) { return et(t => t, (t, e) => e)(O, t, e, n) }), 3), it = m((function (t, e, n, i) { return et(t => t, (t, e) => e)(C(e), t, n, i) }), 4), rt = m((function (t, e, n) { return et(t => t, (t, e) => e)(C(1), t, e, n) }), 3); function st(t) { return (e, ...n) => f(e)(...n, (e, ...n) => { "object" == typeof console && (e ? console.error && console.error(e) : console[t] && n.forEach(e => console[t](e))) }) } var ot = st("dir"), at = m((function (t, e, n) { n = w(n); var i, r = f(t), s = f(e); function o(t, ...e) { if (t) return n(t); !1 !== t && (i = e, s(...e, a)) } function a(t, e) { return t ? n(t) : !1 !== t ? e ? void r(o) : n(null, ...i) : void 0 } return a(null, !0) }), 3); function lt(t, e, n) { const i = f(e); return at(t, (...t) => { const e = t.pop(); i(...t, (t, n) => e(t, !n)) }, n) } function ct(t) { return (e, n, i) => t(e, i) } var ht = m((function (t, e, n) { return O(t, ct(f(e)), n) }), 3), ut = m((function (t, e, n, i) { return C(e)(t, ct(f(n)), i) }), 4), dt = m((function (t, e, n) { return ut(t, 1, e, n) }), 3); function pt(t) { return p(t) ? t : function (...e) { var n = e.pop(), i = !0; e.push((...t) => { i ? c(() => n(...t)) : n(...t) }), t.apply(this, e), i = !1 } } var ft = m((function (t, e, n) { return et(t => !t, t => !t)(O, t, e, n) }), 3), mt = m((function (t, e, n, i) { return et(t => !t, t => !t)(C(e), t, n, i) }), 4), gt = m((function (t, e, n) { return et(t => !t, t => !t)(P, t, e, n) }), 3); function yt(t, e, n, i) { var r = new Array(e.length); t(e, (t, e, i) => { n(t, (t, n) => { r[e] = !!n, i(t) }) }, t => { if (t) return i(t); for (var n = [], s = 0; s < e.length; s++)r[s] && n.push(e[s]); i(null, n) }) } function _t(t, e, n, i) { var r = []; t(e, (t, e, i) => { n(t, (n, s) => { if (n) return i(n); s && r.push({ index: e, value: t }), i(n) }) }, t => { if (t) return i(t); i(null, r.sort((t, e) => t.index - e.index).map(t => t.value)) }) } function vt(t, e, n, i) { return (_(e) ? yt : _t)(t, e, f(n), i) } var bt = m((function (t, e, n) { return vt(O, t, e, n) }), 3), wt = m((function (t, e, n, i) { return vt(C(e), t, n, i) }), 4), xt = m((function (t, e, n) { return vt(P, t, e, n) }), 3), Ct = m((function (t, e) { var n = w(e), i = f(pt(t)); return function t(e) { if (e) return n(e); !1 !== e && i(t) }() }), 2), St = m((function (t, e, n, i) { var r = f(n); return K(t, e, (t, e) => { r(t, (n, i) => n ? e(n) : e(n, { key: i, val: t })) }, (t, e) => { for (var n = {}, { hasOwnProperty: r } = Object.prototype, s = 0; s < e.length; s++)if (e[s]) { var { key: o } = e[s], { val: a } = e[s]; r.call(n, o) ? n[o].push(a) : n[o] = [a] } return i(t, n) }) }), 4); function kt(t, e, n) { return St(t, 1 / 0, e, n) } function Et(t, e, n) { return St(t, 1, e, n) } var Ot = st("log"), At = m((function (t, e, n, i) { i = b(i); var r = {}, s = f(n); return C(e)(t, (t, e, n) => { s(t, e, (t, i) => { if (t) return n(t); r[e] = i, n(t) }) }, t => i(t, r)) }), 4); function Tt(t, e, n) { return At(t, 1 / 0, e, n) } function Pt(t, e, n) { return At(t, 1, e, n) } function Dt(t, e = (t => t)) { var n = Object.create(null), i = Object.create(null), s = f(t), o = r((t, r) => { var o = e(...t); o in n ? c(() => r(null, ...n[o])) : o in i ? i[o].push(r) : (i[o] = [r], s(...t, (t, ...e) => { t || (n[o] = e); var r = i[o]; delete i[o]; for (var s = 0, a = r.length; s < a; s++)r[s](t, ...e) })) }); return o.memo = n, o.unmemoized = t, o } var It = l(o ? process.nextTick : s ? setImmediate : a), Rt = m((t, e, n) => { var i = _(e) ? [] : {}; t(e, (t, e, n) => { f(t)((t, ...r) => { r.length < 2 && ([r] = r), i[e] = r, n(t) }) }, t => n(t, i)) }, 3); function Mt(t, e) { return Rt(O, t, e) } function Lt(t, e, n) { return Rt(C(e), t, n) } function Ft(t, e) { var n = f(t); return $((t, e) => { n(t[0], e) }, e, 1) } class Nt { constructor() { this.heap = [], this.pushCount = Number.MIN_SAFE_INTEGER } get length() { return this.heap.length } empty() { return this.heap = [], this } percUp(t) { let e; for (; t > 0 && jt(this.heap[t], this.heap[e = Vt(t)]);) { let n = this.heap[t]; this.heap[t] = this.heap[e], this.heap[e] = n, t = e } } percDown(t) { let e; for (; (e = 1 + (t << 1)) < this.heap.length && (e + 1 < this.heap.length && jt(this.heap[e + 1], this.heap[e]) && (e += 1), !jt(this.heap[t], this.heap[e]));) { let n = this.heap[t]; this.heap[t] = this.heap[e], this.heap[e] = n, t = e } } push(t) { t.pushCount = ++this.pushCount, this.heap.push(t), this.percUp(this.heap.length - 1) } unshift(t) { return this.heap.push(t) } shift() { let [t] = this.heap; return this.heap[0] = this.heap[this.heap.length - 1], this.heap.pop(), this.percDown(0), t } toArray() { return [...this] } *[Symbol.iterator]() { for (let t = 0; t < this.heap.length; t++)yield this.heap[t].data } remove(t) { let e = 0; for (let n = 0; n < this.heap.length; n++)t(this.heap[n]) || (this.heap[e] = this.heap[n], e++); this.heap.splice(e); for (let n = Vt(this.heap.length - 1); n >= 0; n--)this.percDown(n); return this } } function Vt(t) { return (t + 1 >> 1) - 1 } function jt(t, e) { return t.priority !== e.priority ? t.priority < e.priority : t.pushCount < e.pushCount } function Bt(t, e) { var n = Ft(t, e); return n._tasks = new Nt, n.push = function (t, e = 0, i = (() => { })) { if ("function" != typeof i) throw new Error("task callback must be a function"); if (n.started = !0, Array.isArray(t) || (t = [t]), 0 === t.length && n.idle()) return c(() => n.drain()); for (var r = 0, s = t.length; r < s; r++)n._tasks.push({ data: t[r], priority: e, callback: i }); c(n.process) }, delete n.unshift, n } var zt = m((function (t, e) { if (e = b(e), !Array.isArray(t)) return e(new TypeError("First argument to race must be an array of functions")); if (!t.length) return e(); for (var n = 0, i = t.length; n < i; n++)f(t[n])(e) }), 2); function Ht(t, e, n, i) { var r = [...t].reverse(); return G(r, e, n, i) } function Ut(t) { var e = f(t); return r((function (t, n) { return t.push((t, ...e) => { let i = {}; if (t && (i.error = t), e.length > 0) { var r = e; e.length <= 1 && ([r] = e), i.value = r } n(null, i) }), e.apply(this, t) })) } function $t(t) { var e; return Array.isArray(t) ? e = t.map(Ut) : (e = {}, Object.keys(t).forEach(n => { e[n] = Ut.call(this, t[n]) })), e } function qt(t, e, n, i) { const r = f(n); return vt(t, e, (t, e) => { r(t, (t, n) => { e(t, !n) }) }, i) } var Wt = m((function (t, e, n) { return qt(O, t, e, n) }), 3), Gt = m((function (t, e, n, i) { return qt(C(e), t, n, i) }), 4), Yt = m((function (t, e, n) { return qt(P, t, e, n) }), 3); function Xt(t) { return function () { return t } } function Kt(t, e, n) { var i = { times: 5, intervalFunc: Xt(0) }; if (arguments.length < 3 && "function" == typeof t ? (n = e || M(), e = t) : (Qt(i, t), n = n || M()), "function" != typeof e) throw new Error("Invalid arguments for async.retry"); var r = f(e), s = 1; function o() { r((t, ...e) => { !1 !== t && (t && s++ < i.times && ("function" != typeof i.errorFilter || i.errorFilter(t)) ? setTimeout(o, i.intervalFunc(s - 1)) : n(t, ...e)) }) } return o(), n[R] } function Qt(t, e) { if ("object" == typeof e) t.times = +e.times || 5, t.intervalFunc = "function" == typeof e.interval ? e.interval : Xt(+e.interval || 0), t.errorFilter = e.errorFilter; else { if ("number" != typeof e && "string" != typeof e) throw new Error("Invalid arguments for async.retry"); t.times = +e || 5 } } function Zt(t, e) { e || (e = t, t = null); let n = t && t.arity || e.length; p(e) && (n += 1); var i = f(e); return r((e, r) => { function s(t) { i(...e, t) } return (e.length < n - 1 || null == r) && (e.push(r), r = M()), t ? Kt(t, s, r) : Kt(s, r), r[R] }) } function Jt(t, e) { return Rt(P, t, e) } var te = m((function (t, e, n) { return et(Boolean, t => t)(O, t, e, n) }), 3), ee = m((function (t, e, n, i) { return et(Boolean, t => t)(C(e), t, n, i) }), 4), ne = m((function (t, e, n) { return et(Boolean, t => t)(P, t, e, n) }), 3), ie = m((function (t, e, n) { var i = f(e); return A(t, (t, e) => { i(t, (n, i) => { if (n) return e(n); e(n, { value: t, criteria: i }) }) }, (t, e) => { if (t) return n(t); n(null, e.sort(r).map(t => t.value)) }); function r(t, e) { var n = t.criteria, i = e.criteria; return n < i ? -1 : n > i ? 1 : 0 } }), 3); function re(t, e, n) { var i = f(t); return r((r, s) => { var o, a = !1; r.push((...t) => { a || (s(...t), clearTimeout(o)) }), o = setTimeout((function () { var e = new Error('Callback function "' + (t.name || "anonymous") + '" timed out.'); e.code = "ETIMEDOUT", n && (e.info = n), a = !0, s(e) }), e), i(...r) }) } function se(t, e, n, i) { var r = f(n); return K(function (t) { for (var e = Array(t); t--;)e[t] = t; return e }(t), e, r, i) } function oe(t, e, n) { return se(t, 1 / 0, e, n) } function ae(t, e, n) { return se(t, 1, e, n) } function le(t, e, n, i) { arguments.length <= 3 && "function" == typeof e && (i = n, n = e, e = Array.isArray(t) ? [] : {}), i = b(i || M()); var r = f(n); return O(t, (t, n, i) => { r(e, t, n, i) }, t => i(t, e)), i[R] } var ce = m((function (t, e) { var n, i = null; return dt(t, (t, e) => { f(t)((t, ...r) => { if (!1 === t) return e(t); r.length < 2 ? [n] = r : n = r, i = t, e(t ? null : {}) }) }, () => e(i, n)) })); function he(t) { return (...e) => (t.unmemoized || t)(...e) } var ue = m((function (t, e, n) { n = w(n); var i = f(e), r = f(t), s = []; function o(t, ...e) { if (t) return n(t); s = e, !1 !== t && r(a) } function a(t, e) { return t ? n(t) : !1 !== t ? e ? void i(o) : n(null, ...s) : void 0 } return r(a) }), 3); function de(t, e, n) { const i = f(t); return ue(t => i((e, n) => t(e, !n)), e, n) } var pe = m((function (t, e) { if (e = b(e), !Array.isArray(t)) return e(new Error("First argument to waterfall must be an array of functions")); if (!t.length) return e(); var n = 0; function i(e) { f(t[n++])(...e, w(r)) } function r(r, ...s) { if (!1 !== r) return r || n === t.length ? e(r, ...s) : void i(s) } i([]) })); e.default = { apply: i, applyEach: T, applyEachSeries: I, asyncify: h, auto: L, autoInject: z, cargo: q, cargoQueue: W, compose: X, concat: Z, concatLimit: Q, concatSeries: J, constant: tt, detect: nt, detectLimit: it, detectSeries: rt, dir: ot, doUntil: lt, doWhilst: at, each: ht, eachLimit: ut, eachOf: O, eachOfLimit: S, eachOfSeries: P, eachSeries: dt, ensureAsync: pt, every: ft, everyLimit: mt, everySeries: gt, filter: bt, filterLimit: wt, filterSeries: xt, forever: Ct, groupBy: kt, groupByLimit: St, groupBySeries: Et, log: Ot, map: A, mapLimit: K, mapSeries: D, mapValues: Tt, mapValuesLimit: At, mapValuesSeries: Pt, memoize: Dt, nextTick: It, parallel: Mt, parallelLimit: Lt, priorityQueue: Bt, queue: Ft, race: zt, reduce: G, reduceRight: Ht, reflect: Ut, reflectAll: $t, reject: Wt, rejectLimit: Gt, rejectSeries: Yt, retry: Kt, retryable: Zt, seq: Y, series: Jt, setImmediate: c, some: te, someLimit: ee, someSeries: ne, sortBy: ie, timeout: re, times: oe, timesLimit: se, timesSeries: ae, transform: le, tryEach: ce, unmemoize: he, until: de, waterfall: pe, whilst: ue, all: ft, allLimit: mt, allSeries: gt, any: te, anyLimit: ee, anySeries: ne, find: nt, findLimit: it, findSeries: rt, flatMap: Z, flatMapLimit: Q, flatMapSeries: J, forEach: ht, forEachSeries: dt, forEachLimit: ut, forEachOf: O, forEachOfSeries: P, forEachOfLimit: S, inject: G, foldl: G, foldr: Ht, select: bt, selectLimit: wt, selectSeries: xt, wrapSync: h, during: ue, doDuring: at } }, Yvos: function (t, e) { t.exports = function (t, e) { var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } }, ZkHo: function (t, e, n) { var i = n("nY9P"), r = n("LSMI"), s = n("cP7b"), o = n("pjLp"); e.polling = function (t) { var e = !1, n = !1, o = !1 !== t.jsonp; if ("undefined" != typeof location) { var a = "https:" === location.protocol, l = location.port; l || (l = a ? 443 : 80), e = t.hostname !== location.hostname || l !== t.port, n = t.secure !== a } if (t.xdomain = e, t.xscheme = n, "open" in new i(t) && !t.forceJSONP) return new r(t); if (!o) throw new Error("JSONP disabled"); return new s(t) }, e.websocket = o }, bAYg: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z"; e.definition = { prefix: "fas", iconName: "star", icon: [576, 512, i, "f005", r] }, e.faStar = e.definition, e.prefix = "fas", e.iconName = "star", e.width = 576, e.height = 512, e.ligatures = i, e.unicode = "f005", e.svgPathData = r }, bOPS: function (t, e, n) { var i = n("Uxeu"), r = n("NOtv")("socket.io-client:url"); t.exports = function (t, e) { var n = t; e = e || "undefined" != typeof location && location, null == t && (t = e.protocol + "//" + e.host), "string" == typeof t && ("/" === t.charAt(0) && (t = "/" === t.charAt(1) ? e.protocol + t : e.host + t), /^(https?|wss?):\/\//.test(t) || (r("protocol-less url %s", t), t = void 0 !== e ? e.protocol + "//" + t : "https://" + t), r("parse %s", t), n = i(t)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/"; var s = -1 !== n.host.indexOf(":") ? "[" + n.host + "]" : n.host; return n.id = n.protocol + "://" + s + ":" + n.port, n.href = n.protocol + "://" + s + (e && e.port === n.port ? "" : ":" + n.port), n } }, brUr: function (t, e, n) { function i(t) { var n; function i() { if (i.enabled) { var t = i, r = +new Date, s = r - (n || r); t.diff = s, t.prev = n, t.curr = r, n = r; for (var o = new Array(arguments.length), a = 0; a < o.length; a++)o[a] = arguments[a]; o[0] = e.coerce(o[0]), "string" != typeof o[0] && o.unshift("%O"); var l = 0; o[0] = o[0].replace(/%([a-zA-Z%])/g, (function (n, i) { if ("%%" === n) return n; l++; var r = e.formatters[i]; return "function" == typeof r && (n = r.call(t, o[l]), o.splice(l, 1), l--), n })), e.formatArgs.call(t, o); var c = i.log || e.log || console.log.bind(console); c.apply(t, o) } } return i.namespace = t, i.enabled = e.enabled(t), i.useColors = e.useColors(), i.color = function (t) { var n, i = 0; for (n in t) i = (i << 5) - i + t.charCodeAt(n), i |= 0; return e.colors[Math.abs(i) % e.colors.length] }(t), i.destroy = r, "function" == typeof e.init && e.init(i), e.instances.push(i), i } function r() { var t = e.instances.indexOf(this); return -1 !== t && (e.instances.splice(t, 1), !0) } (e = t.exports = i.debug = i.default = i).coerce = function (t) { return t instanceof Error ? t.stack || t.message : t }, e.disable = function () { e.enable("") }, e.enable = function (t) { var n; e.save(t), e.names = [], e.skips = []; var i = ("string" == typeof t ? t : "").split(/[\s,]+/), r = i.length; for (n = 0; n < r; n++)i[n] && ("-" === (t = i[n].replace(/\*/g, ".*?"))[0] ? e.skips.push(new RegExp("^" + t.substr(1) + "$")) : e.names.push(new RegExp("^" + t + "$"))); for (n = 0; n < e.instances.length; n++) { var s = e.instances[n]; s.enabled = e.enabled(s.namespace) } }, e.enabled = function (t) { if ("*" === t[t.length - 1]) return !0; var n, i; for (n = 0, i = e.skips.length; n < i; n++)if (e.skips[n].test(t)) return !1; for (n = 0, i = e.names.length; n < i; n++)if (e.names[n].test(t)) return !0; return !1 }, e.humanize = n("V/HI"), e.instances = [], e.names = [], e.skips = [], e.formatters = {} }, cP7b: function (t, e, n) { var i = n("7snx"), r = n("Yvos"), s = n("opsh"); t.exports = h; var o, a = /\n/g, l = /\\n/g; function c() { } function h(t) { i.call(this, t), this.query = this.query || {}, o || (o = s.___eio = s.___eio || []), this.index = o.length; var e = this; o.push((function (t) { e.onData(t) })), this.query.j = this.index, "function" == typeof addEventListener && addEventListener("beforeunload", (function () { e.script && (e.script.onerror = c) }), !1) } r(h, i), h.prototype.supportsBinary = !1, h.prototype.doClose = function () { this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), i.prototype.doClose.call(this) }, h.prototype.doPoll = function () { var t = this, e = document.createElement("script"); this.script && (this.script.parentNode.removeChild(this.script), this.script = null), e.async = !0, e.src = this.uri(), e.onerror = function (e) { t.onError("jsonp poll error", e) }; var n = document.getElementsByTagName("script")[0]; n ? n.parentNode.insertBefore(e, n) : (document.head || document.body).appendChild(e), this.script = e, "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout((function () { var t = document.createElement("iframe"); document.body.appendChild(t), document.body.removeChild(t) }), 100) }, h.prototype.doWrite = function (t, e) { var n = this; if (!this.form) { var i, r = document.createElement("form"), s = document.createElement("textarea"), o = this.iframeId = "eio_iframe_" + this.index; r.className = "socketio", r.style.position = "absolute", r.style.top = "-1000px", r.style.left = "-1000px", r.target = o, r.method = "POST", r.setAttribute("accept-charset", "utf-8"), s.name = "d", r.appendChild(s), document.body.appendChild(r), this.form = r, this.area = s } function c() { h(), e() } function h() { if (n.iframe) try { n.form.removeChild(n.iframe) } catch (t) { n.onError("jsonp polling iframe removal error", t) } try { i = document.createElement('<iframe src="javascript:0" name="' + n.iframeId + '">') } catch (t) { (i = document.createElement("iframe")).name = n.iframeId, i.src = "javascript:0" } i.id = n.iframeId, n.form.appendChild(i), n.iframe = i } this.form.action = this.uri(), h(), t = t.replace(l, "\\\n"), this.area.value = t.replace(a, "\\n"); try { this.form.submit() } catch (u) { } this.iframe.attachEvent ? this.iframe.onreadystatechange = function () { "complete" === n.iframe.readyState && c() } : this.iframe.onload = c } }, dCbE: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M608 320h-64v64h22.4c5.3 0 9.6 3.6 9.6 8v16c0 4.4-4.3 8-9.6 8H73.6c-5.3 0-9.6-3.6-9.6-8v-16c0-4.4 4.3-8 9.6-8H96v-64H32c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32h576c17.7 0 32-14.3 32-32v-96c0-17.7-14.3-32-32-32zm-96 64V64.3c0-17.9-14.5-32.3-32.3-32.3H160.4C142.5 32 128 46.5 128 64.3V384h384zM211.2 202l25.5-25.3c4.2-4.2 11-4.2 15.2.1l41.3 41.6 95.2-94.4c4.2-4.2 11-4.2 15.2.1l25.3 25.5c4.2 4.2 4.2 11-.1 15.2L300.5 292c-4.2 4.2-11 4.2-15.2-.1l-74.1-74.7c-4.3-4.2-4.2-11 0-15.2z"; e.definition = { prefix: "fas", iconName: "vote-yea", icon: [640, 512, i, "f772", r] }, e.faVoteYea = e.definition, e.prefix = "fas", e.iconName = "vote-yea", e.width = 640, e.height = 512, e.ligatures = i, e.unicode = "f772", e.svgPathData = r }, fxjp: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"; e.definition = { prefix: "fas", iconName: "user", icon: [448, 512, i, "f007", r] }, e.faUser = e.definition, e.prefix = "fas", e.iconName = "user", e.width = 448, e.height = 512, e.ligatures = i, e.unicode = "f007", e.svgPathData = r }, g5Dd: function (t, e) { !function () { "use strict"; for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(256), i = 0; i < t.length; i++)n[t.charCodeAt(i)] = i; e.encode = function (e) { var n, i = new Uint8Array(e), r = i.length, s = ""; for (n = 0; n < r; n += 3)s += t[i[n] >> 2], s += t[(3 & i[n]) << 4 | i[n + 1] >> 4], s += t[(15 & i[n + 1]) << 2 | i[n + 2] >> 6], s += t[63 & i[n + 2]]; return r % 3 == 2 ? s = s.substring(0, s.length - 1) + "=" : r % 3 == 1 && (s = s.substring(0, s.length - 2) + "=="), s }, e.decode = function (t) { var e, i, r, s, o, a = .75 * t.length, l = t.length, c = 0; "=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--); var h = new ArrayBuffer(a), u = new Uint8Array(h); for (e = 0; e < l; e += 4)i = n[t.charCodeAt(e)], r = n[t.charCodeAt(e + 1)], s = n[t.charCodeAt(e + 2)], o = n[t.charCodeAt(e + 3)], u[c++] = i << 2 | r >> 4, u[c++] = (15 & r) << 4 | s >> 2, u[c++] = (3 & s) << 6 | 63 & o; return h } }() }, hRW6: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm80 168c17.7 0 32 14.3 32 32s-14.3 32-32 32-32-14.3-32-32 14.3-32 32-32zM152 416c-26.5 0-48-21-48-47 0-20 28.5-60.4 41.6-77.8 3.2-4.3 9.6-4.3 12.8 0C171.5 308.6 200 349 200 369c0 26-21.5 47-48 47zm16-176c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm170.2 154.2C315.8 367.4 282.9 352 248 352c-21.2 0-21.2-32 0-32 44.4 0 86.3 19.6 114.7 53.8 13.8 16.4-11.2 36.5-24.5 20.4z"; e.definition = { prefix: "fas", iconName: "sad-tear", icon: [496, 512, i, "f5b4", r] }, e.faSadTear = e.definition, e.prefix = "fas", e.iconName = "sad-tear", e.width = 496, e.height = 512, e.ligatures = i, e.unicode = "f5b4", e.svgPathData = r }, "hmj/": function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"; e.definition = { prefix: "fas", iconName: "chevron-down", icon: [448, 512, i, "f078", r] }, e.faChevronDown = e.definition, e.prefix = "fas", e.iconName = "chevron-down", e.width = 448, e.height = 512, e.ligatures = i, e.unicode = "f078", e.svgPathData = r }, isOO: function (t, e, n) { "use strict"; var i = this && this.__spreadArrays || function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; var i = Array(t), r = 0; for (e = 0; e < n; e++)for (var s = arguments[e], o = 0, a = s.length; o < a; o++, r++)i[r] = s[o]; return i }; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n("Y3lY"), s = n("4jMP"), o = function () { function t(t, e) { this.online = !1, this.savedRequests = [], t && (this.socketURL = t), e && (this.options = e) } return t.prototype.disconnect = function () { this.lastReceivedBlock = null, this.socket.disconnect() }, t.prototype.setEndpoint = function (t) { t ? this.socketURL = t : console.error("URL not informed") }, t.prototype.connect = function (t) { var e = this; if (this.onData && (this.dataQueue = r.queue((function (t, n) { e.options.async ? e.onData(t, (function () { n() })) : (e.onData(t), n()) }), 1), this.dataQueue.error((function (t) { t && console.error("task experienced an error") })), this.dataQueue.drain((function () { })), this.dataQueue.empty(this.onEmpty)), !this.socketURL) throw new Error("endpoint was not defined!"); this.socket = s(this.socketURL, { transports: ["websocket", "polling"] }), this.socket.on("connect", (function () { e.online = !0, e.onConnect && e.onConnect(), t && t() })), this.socket.on("error", (function (t) { console.log(t) })), this.socket.on("lib_update", (function (t) { e.onLIB && e.onLIB(t) })), this.socket.on("message", (function (t) { if (e.onData && (t.message || t.messages)) switch (t.type) { case "delta_trace": t.messages ? t.messages.forEach((function (n) { e.processDeltaTrace(n, t.mode) })) : e.processDeltaTrace(JSON.parse(t.message), t.mode); break; case "action_trace": t.messages ? t.messages.forEach((function (n) { e.processActionTrace(n, t.mode) })) : e.processActionTrace(JSON.parse(t.message), t.mode) } })), this.socket.on("status", (function (t) { switch (t) { case "relay_restored": e.online || (e.online = !0, e.resendRequests()); break; case "relay_down": e.online = !1; break; default: console.log(t) } })), this.socket.on("disconnect", (function () { e.online = !1, console.log("disconnected!") })) }, t.prototype.processActionTrace = function (t, e) { var n = "@" + t.act.name; if (t[n]) { var i = t[n]; Object.keys(i).forEach((function (e) { t.act.data || (t.act.data = {}), t.act.data[e] = i[e] })), delete t[n] } this.dataQueue.push({ type: "action", mode: e, content: t }), this.lastReceivedBlock = t.block_num }, t.prototype.processDeltaTrace = function (t, e) { var n = "@" + t.table; if (t[n + ".data"] && (n += ".data"), t[n]) { var i = t[n]; Object.keys(i).forEach((function (e) { t.data || (t.data = {}), t.data[e] = i[e] })), delete t[n] } this.dataQueue.push({ type: "delta", mode: e, content: t }), this.lastReceivedBlock = t.block_num }, t.prototype.resendRequests = function () { var t = this; console.log("RESENDING SAVED REQUESTS"); var e = i(this.savedRequests); this.savedRequests = [], e.forEach((function (e) { switch (e.type) { case "action": t.streamActions(e.req); break; case "delta": t.streamDeltas(e.req) } })) }, t.prototype.streamActions = function (t) { this.socket.connected && (this.checkLastBlock(t), this.socket.emit("action_stream_request", t, (function (t) { console.log("action stream response:", t) })), this.savedRequests.push({ type: "action", req: t })) }, t.prototype.streamDeltas = function (t) { this.socket.connected && (this.checkLastBlock(t), this.socket.emit("delta_stream_request", t, (function (t) { console.log("delta stream response:", t) })), this.savedRequests.push({ type: "delta", req: t })) }, t.prototype.checkLastBlock = function (t) { 0 !== t.start_from && this.lastReceivedBlock && t.start_from < this.lastReceivedBlock && (t.start_from = this.lastReceivedBlock) }, t }(); e.HyperionSocketClient = o }, "j/BV": function (t, e) { t.exports = function (t) { return n && Buffer.isBuffer(t) || i && (t instanceof ArrayBuffer || function (t) { return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer }(t)) }; var n = "function" == typeof Buffer && "function" == typeof Buffer.isBuffer, i = "function" == typeof ArrayBuffer }, kSER: function (t, e) { t.exports = function (t, e) { for (var n = [], i = (e = e || 0) || 0; i < t.length; i++)n[i - e] = t[i]; return n } }, mT4a: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M504 255.531c.253 136.64-111.18 248.372-247.82 248.468-59.015.042-113.223-20.53-155.822-54.911-11.077-8.94-11.905-25.541-1.839-35.607l11.267-11.267c8.609-8.609 22.353-9.551 31.891-1.984C173.062 425.135 212.781 440 256 440c101.705 0 184-82.311 184-184 0-101.705-82.311-184-184-184-48.814 0-93.149 18.969-126.068 49.932l50.754 50.754c10.08 10.08 2.941 27.314-11.313 27.314H24c-8.837 0-16-7.163-16-16V38.627c0-14.254 17.234-21.393 27.314-11.314l49.372 49.372C129.209 34.136 189.552 8 256 8c136.81 0 247.747 110.78 248 247.531zm-180.912 78.784l9.823-12.63c8.138-10.463 6.253-25.542-4.21-33.679L288 256.349V152c0-13.255-10.745-24-24-24h-16c-13.255 0-24 10.745-24 24v135.651l65.409 50.874c10.463 8.137 25.541 6.253 33.679-4.21z"; e.definition = { prefix: "fas", iconName: "history", icon: [512, 512, i, "f1da", r] }, e.faHistory = e.definition, e.prefix = "fas", e.iconName = "history", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f1da", e.svgPathData = r }, muhD: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"; e.definition = { prefix: "fas", iconName: "chevron-right", icon: [320, 512, i, "f054", r] }, e.faChevronRight = e.definition, e.prefix = "fas", e.iconName = "chevron-right", e.width = 320, e.height = 512, e.ligatures = i, e.unicode = "f054", e.svgPathData = r }, n62F: function (t, e) { t.exports = function (t, e, n) { return t.on(e, n), { destroy: function () { t.removeListener(e, n) } } } }, nY9P: function (t, e, n) { var i = n("yeub"), r = n("opsh"); t.exports = function (t) { var e = t.xdomain, n = t.xscheme, s = t.enablesXDR; try { if ("undefined" != typeof XMLHttpRequest && (!e || i)) return new XMLHttpRequest } catch (o) { } try { if ("undefined" != typeof XDomainRequest && !n && s) return new XDomainRequest } catch (o) { } if (!e) try { return new (r[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP") } catch (o) { } } }, nbjS: function (t, e, n) { var i, r = n("+gph"), s = n("WLGk"), o = n("ypnn"), a = n("zMFY"), l = n("1nsi"); "undefined" != typeof ArrayBuffer && (i = n("g5Dd")); var c = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent), h = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent), u = c || h; e.protocol = 3; var d = e.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 }, p = r(d), f = { type: "error", data: "parser error" }, m = n("14A5"); function g(t, e, n) { for (var i = new Array(t.length), r = a(t.length, n), s = function (t, n, r) { e(n, (function (e, n) { i[t] = n, r(e, i) })) }, o = 0; o < t.length; o++)s(o, t[o], r) } e.encodePacket = function (t, n, i, r) { "function" == typeof n && (r = n, n = !1), "function" == typeof i && (r = i, i = null); var s = void 0 === t.data ? void 0 : t.data.buffer || t.data; if ("undefined" != typeof ArrayBuffer && s instanceof ArrayBuffer) return function (t, n, i) { if (!n) return e.encodeBase64Packet(t, i); var r = t.data, s = new Uint8Array(r), o = new Uint8Array(1 + r.byteLength); o[0] = d[t.type]; for (var a = 0; a < s.length; a++)o[a + 1] = s[a]; return i(o.buffer) }(t, n, r); if (void 0 !== m && s instanceof m) return function (t, n, i) { if (!n) return e.encodeBase64Packet(t, i); if (u) return function (t, n, i) { if (!n) return e.encodeBase64Packet(t, i); var r = new FileReader; return r.onload = function () { e.encodePacket({ type: t.type, data: r.result }, n, !0, i) }, r.readAsArrayBuffer(t.data) }(t, n, i); var r = new Uint8Array(1); return r[0] = d[t.type], i(new m([r.buffer, t.data])) }(t, n, r); if (s && s.base64) return function (t, n) { return n("b" + e.packets[t.type] + t.data.data) }(t, r); var o = d[t.type]; return void 0 !== t.data && (o += i ? l.encode(String(t.data), { strict: !1 }) : String(t.data)), r("" + o) }, e.encodeBase64Packet = function (t, n) { var i, r = "b" + e.packets[t.type]; if (void 0 !== m && t.data instanceof m) { var s = new FileReader; return s.onload = function () { var t = s.result.split(",")[1]; n(r + t) }, s.readAsDataURL(t.data) } try { i = String.fromCharCode.apply(null, new Uint8Array(t.data)) } catch (c) { for (var o = new Uint8Array(t.data), a = new Array(o.length), l = 0; l < o.length; l++)a[l] = o[l]; i = String.fromCharCode.apply(null, a) } return r += btoa(i), n(r) }, e.decodePacket = function (t, n, i) { if (void 0 === t) return f; if ("string" == typeof t) { if ("b" === t.charAt(0)) return e.decodeBase64Packet(t.substr(1), n); if (i && !1 === (t = function (t) { try { t = l.decode(t, { strict: !1 }) } catch (e) { return !1 } return t }(t))) return f; var r = t.charAt(0); return Number(r) == r && p[r] ? t.length > 1 ? { type: p[r], data: t.substring(1) } : { type: p[r] } : f } r = new Uint8Array(t)[0]; var s = o(t, 1); return m && "blob" === n && (s = new m([s])), { type: p[r], data: s } }, e.decodeBase64Packet = function (t, e) { var n = p[t.charAt(0)]; if (!i) return { type: n, data: { base64: !0, data: t.substr(1) } }; var r = i.decode(t.substr(1)); return "blob" === e && m && (r = new m([r])), { type: n, data: r } }, e.encodePayload = function (t, n, i) { "function" == typeof n && (i = n, n = null); var r = s(t); return n && r ? m && !u ? e.encodePayloadAsBlob(t, i) : e.encodePayloadAsArrayBuffer(t, i) : t.length ? void g(t, (function (t, i) { e.encodePacket(t, !!r && n, !1, (function (t) { i(null, function (t) { return t.length + ":" + t }(t)) })) }), (function (t, e) { return i(e.join("")) })) : i("0:") }, e.decodePayload = function (t, n, i) { if ("string" != typeof t) return e.decodePayloadAsBinary(t, n, i); var r; if ("function" == typeof n && (i = n, n = null), "" === t) return i(f, 0, 1); for (var s, o, a = "", l = 0, c = t.length; l < c; l++) { var h = t.charAt(l); if (":" === h) { if ("" === a || a != (s = Number(a))) return i(f, 0, 1); if (a != (o = t.substr(l + 1, s)).length) return i(f, 0, 1); if (o.length) { if (r = e.decodePacket(o, n, !1), f.type === r.type && f.data === r.data) return i(f, 0, 1); if (!1 === i(r, l + s, c)) return } l += s, a = "" } else a += h } return "" !== a ? i(f, 0, 1) : void 0 }, e.encodePayloadAsArrayBuffer = function (t, n) { if (!t.length) return n(new ArrayBuffer(0)); g(t, (function (t, n) { e.encodePacket(t, !0, !0, (function (t) { return n(null, t) })) }), (function (t, e) { var i = e.reduce((function (t, e) { var n; return t + (n = "string" == typeof e ? e.length : e.byteLength).toString().length + n + 2 }), 0), r = new Uint8Array(i), s = 0; return e.forEach((function (t) { var e = "string" == typeof t, n = t; if (e) { for (var i = new Uint8Array(t.length), o = 0; o < t.length; o++)i[o] = t.charCodeAt(o); n = i.buffer } r[s++] = e ? 0 : 1; var a = n.byteLength.toString(); for (o = 0; o < a.length; o++)r[s++] = parseInt(a[o]); for (r[s++] = 255, i = new Uint8Array(n), o = 0; o < i.length; o++)r[s++] = i[o] })), n(r.buffer) })) }, e.encodePayloadAsBlob = function (t, n) { g(t, (function (t, n) { e.encodePacket(t, !0, !0, (function (t) { var e = new Uint8Array(1); if (e[0] = 1, "string" == typeof t) { for (var i = new Uint8Array(t.length), r = 0; r < t.length; r++)i[r] = t.charCodeAt(r); t = i.buffer, e[0] = 0 } var s = (t instanceof ArrayBuffer ? t.byteLength : t.size).toString(), o = new Uint8Array(s.length + 1); for (r = 0; r < s.length; r++)o[r] = parseInt(s[r]); if (o[s.length] = 255, m) { var a = new m([e.buffer, o.buffer, t]); n(null, a) } })) }), (function (t, e) { return n(new m(e)) })) }, e.decodePayloadAsBinary = function (t, n, i) { "function" == typeof n && (i = n, n = null); for (var r = t, s = []; r.byteLength > 0;) { for (var a = new Uint8Array(r), l = 0 === a[0], c = "", h = 1; 255 !== a[h]; h++) { if (c.length > 310) return i(f, 0, 1); c += a[h] } r = o(r, 2 + c.length), c = parseInt(c); var u = o(r, 0, c); if (l) try { u = String.fromCharCode.apply(null, new Uint8Array(u)) } catch (m) { var d = new Uint8Array(u); for (u = "", h = 0; h < d.length; h++)u += String.fromCharCode(d[h]) } s.push(u), r = o(r, c) } var p = s.length; s.forEach((function (t, r) { i(e.decodePacket(t, n, !0), r, p) })) } }, opsh: function (t, e) { t.exports = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")() }, pjLp: function (t, e, n) { var i, r, s = n("9WME"), o = n("nbjS"), a = n("TypT"), l = n("Yvos"), c = n("Aplp"), h = n("NOtv")("engine.io-client:websocket"); if ("undefined" != typeof WebSocket ? i = WebSocket : "undefined" != typeof self && (i = self.WebSocket || self.MozWebSocket), "undefined" == typeof window) try { r = n(1) } catch (p) { } var u = i || r; function d(t) { t && t.forceBase64 && (this.supportsBinary = !1), this.perMessageDeflate = t.perMessageDeflate, this.usingBrowserWebSocket = i && !t.forceNode, this.protocols = t.protocols, this.usingBrowserWebSocket || (u = r), s.call(this, t) } t.exports = d, l(d, s), d.prototype.name = "websocket", d.prototype.supportsBinary = !0, d.prototype.doOpen = function () { if (this.check()) { var t = this.uri(), e = this.protocols, n = { agent: this.agent, perMessageDeflate: this.perMessageDeflate }; n.pfx = this.pfx, n.key = this.key, n.passphrase = this.passphrase, n.cert = this.cert, n.ca = this.ca, n.ciphers = this.ciphers, n.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (n.headers = this.extraHeaders), this.localAddress && (n.localAddress = this.localAddress); try { this.ws = this.usingBrowserWebSocket && !this.isReactNative ? e ? new u(t, e) : new u(t) : new u(t, e, n) } catch (i) { return this.emit("error", i) } void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners() } }, d.prototype.addEventListeners = function () { var t = this; this.ws.onopen = function () { t.onOpen() }, this.ws.onclose = function () { t.onClose() }, this.ws.onmessage = function (e) { t.onData(e.data) }, this.ws.onerror = function (e) { t.onError("websocket error", e) } }, d.prototype.write = function (t) { var e = this; this.writable = !1; for (var n = t.length, i = 0, r = n; i < r; i++)!function (t) { o.encodePacket(t, e.supportsBinary, (function (i) { if (!e.usingBrowserWebSocket) { var r = {}; t.options && (r.compress = t.options.compress), e.perMessageDeflate && ("string" == typeof i ? Buffer.byteLength(i) : i.length) < e.perMessageDeflate.threshold && (r.compress = !1) } try { e.usingBrowserWebSocket ? e.ws.send(i) : e.ws.send(i, r) } catch (p) { h("websocket closed before onclose event") } --n || (e.emit("flush"), setTimeout((function () { e.writable = !0, e.emit("drain") }), 0)) })) }(t[i]) }, d.prototype.onClose = function () { s.prototype.onClose.call(this) }, d.prototype.doClose = function () { void 0 !== this.ws && this.ws.close() }, d.prototype.uri = function () { var t = this.query || {}, e = this.secure ? "wss" : "ws", n = ""; return this.port && ("wss" === e && 443 !== Number(this.port) || "ws" === e && 80 !== Number(this.port)) && (n = ":" + this.port), this.timestampRequests && (t[this.timestampParam] = c()), this.supportsBinary || (t.b64 = 1), (t = a.encode(t)).length && (t = "?" + t), e + "://" + (-1 !== this.hostname.indexOf(":") ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t }, d.prototype.check = function () { return !(!u || "__initialize" in u && this.name === d.prototype.name) } }, sGxO: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"; e.definition = { prefix: "fas", iconName: "lock", icon: [448, 512, i, "f023", r] }, e.faLock = e.definition, e.prefix = "fas", e.iconName = "lock", e.width = 448, e.height = 512, e.ligatures = i, e.unicode = "f023", e.svgPathData = r }, uXkJ: function (t, e, n) { var i = n("5KXg")("socket.io-parser"), r = n("3dqp"), s = n("OTwl"), o = n("WqQy"), a = n("j/BV"); function l() { } e.protocol = 4, e.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], e.CONNECT = 0, e.DISCONNECT = 1, e.EVENT = 2, e.ACK = 3, e.ERROR = 4, e.BINARY_EVENT = 5, e.BINARY_ACK = 6, e.Encoder = l, e.Decoder = u; var c = e.ERROR + '"encode error"'; function h(t) { var n = "" + t.type; if (e.BINARY_EVENT !== t.type && e.BINARY_ACK !== t.type || (n += t.attachments + "-"), t.nsp && "/" !== t.nsp && (n += t.nsp + ","), null != t.id && (n += t.id), null != t.data) { var r = function (t) { try { return JSON.stringify(t) } catch (e) { return !1 } }(t.data); if (!1 === r) return c; n += r } return i("encoded %j as %s", t, n), n } function u() { this.reconstructor = null } function d(t) { this.reconPack = t, this.buffers = [] } function p(t) { return { type: e.ERROR, data: "parser error: " + t } } l.prototype.encode = function (t, n) { i("encoding packet %j", t), e.BINARY_EVENT === t.type || e.BINARY_ACK === t.type ? function (t, e) { s.removeBlobs(t, (function (t) { var n = s.deconstructPacket(t), i = h(n.packet), r = n.buffers; r.unshift(i), e(r) })) }(t, n) : n([h(t)]) }, r(u.prototype), u.prototype.add = function (t) { var n; if ("string" == typeof t) n = function (t) { var n = 0, r = { type: Number(t.charAt(0)) }; if (null == e.types[r.type]) return p("unknown packet type " + r.type); if (e.BINARY_EVENT === r.type || e.BINARY_ACK === r.type) { for (var s = ""; "-" !== t.charAt(++n) && (s += t.charAt(n), n != t.length);); if (s != Number(s) || "-" !== t.charAt(n)) throw new Error("Illegal attachments"); r.attachments = Number(s) } if ("/" === t.charAt(n + 1)) for (r.nsp = ""; ++n && "," !== (l = t.charAt(n)) && (r.nsp += l, n !== t.length);); else r.nsp = "/"; var a = t.charAt(n + 1); if ("" !== a && Number(a) == a) { for (r.id = ""; ++n;) { var l; if (null == (l = t.charAt(n)) || Number(l) != l) { --n; break } if (r.id += t.charAt(n), n === t.length) break } r.id = Number(r.id) } if (t.charAt(++n)) { var c = function (t) { try { return JSON.parse(t) } catch (e) { return !1 } }(t.substr(n)); if (!1 === c || r.type !== e.ERROR && !o(c)) return p("invalid payload"); r.data = c } return i("decoded %s as %j", t, r), r }(t), e.BINARY_EVENT === n.type || e.BINARY_ACK === n.type ? (this.reconstructor = new d(n), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", n)) : this.emit("decoded", n); else { if (!a(t) && !t.base64) throw new Error("Unknown type: " + t); if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet"); (n = this.reconstructor.takeBinaryData(t)) && (this.reconstructor = null, this.emit("decoded", n)) } }, u.prototype.destroy = function () { this.reconstructor && this.reconstructor.finishedReconstruction() }, d.prototype.takeBinaryData = function (t) { if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) { var e = s.reconstructPacket(this.reconPack, this.buffers); return this.finishedReconstruction(), e } return null }, d.prototype.finishedReconstruction = function () { this.reconPack = null, this.buffers = [] } }, vjuW: function (t, e, n) { var i = n("uXkJ"), r = n("3dqp"), s = n("kSER"), o = n("n62F"), a = n("QN7Q"), l = n("NOtv")("socket.io-client:socket"), c = n("TypT"), h = n("WLGk"); t.exports = p; var u = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 }, d = r.prototype.emit; function p(t, e, n) { this.io = t, this.nsp = e, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, n && n.query && (this.query = n.query), this.io.autoConnect && this.open() } r(p.prototype), p.prototype.subEvents = function () { if (!this.subs) { var t = this.io; this.subs = [o(t, "open", a(this, "onopen")), o(t, "packet", a(this, "onpacket")), o(t, "close", a(this, "onclose"))] } }, p.prototype.open = p.prototype.connect = function () { return this.connected || (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting")), this }, p.prototype.send = function () { var t = s(arguments); return t.unshift("message"), this.emit.apply(this, t), this }, p.prototype.emit = function (t) { if (u.hasOwnProperty(t)) return d.apply(this, arguments), this; var e = s(arguments), n = { type: (void 0 !== this.flags.binary ? this.flags.binary : h(e)) ? i.BINARY_EVENT : i.EVENT, data: e, options: {} }; return n.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof e[e.length - 1] && (l("emitting packet with ack id %d", this.ids), this.acks[this.ids] = e.pop(), n.id = this.ids++), this.connected ? this.packet(n) : this.sendBuffer.push(n), this.flags = {}, this }, p.prototype.packet = function (t) { t.nsp = this.nsp, this.io.packet(t) }, p.prototype.onopen = function () { if (l("transport is open - connecting"), "/" !== this.nsp) if (this.query) { var t = "object" == typeof this.query ? c.encode(this.query) : this.query; l("sending connect packet with query %s", t), this.packet({ type: i.CONNECT, query: t }) } else this.packet({ type: i.CONNECT }) }, p.prototype.onclose = function (t) { l("close (%s)", t), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", t) }, p.prototype.onpacket = function (t) { if (t.nsp === this.nsp || t.type === i.ERROR && "/" === t.nsp) switch (t.type) { case i.CONNECT: this.onconnect(); break; case i.EVENT: case i.BINARY_EVENT: this.onevent(t); break; case i.ACK: case i.BINARY_ACK: this.onack(t); break; case i.DISCONNECT: this.ondisconnect(); break; case i.ERROR: this.emit("error", t.data) } }, p.prototype.onevent = function (t) { var e = t.data || []; l("emitting event %j", e), null != t.id && (l("attaching ack callback to event"), e.push(this.ack(t.id))), this.connected ? d.apply(this, e) : this.receiveBuffer.push(e) }, p.prototype.ack = function (t) { var e = this, n = !1; return function () { if (!n) { n = !0; var r = s(arguments); l("sending ack %j", r), e.packet({ type: h(r) ? i.BINARY_ACK : i.ACK, id: t, data: r }) } } }, p.prototype.onack = function (t) { var e = this.acks[t.id]; "function" == typeof e ? (l("calling ack %s with %j", t.id, t.data), e.apply(this, t.data), delete this.acks[t.id]) : l("bad ack %s", t.id) }, p.prototype.onconnect = function () { this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered() }, p.prototype.emitBuffered = function () { var t; for (t = 0; t < this.receiveBuffer.length; t++)d.apply(this, this.receiveBuffer[t]); for (this.receiveBuffer = [], t = 0; t < this.sendBuffer.length; t++)this.packet(this.sendBuffer[t]); this.sendBuffer = [] }, p.prototype.ondisconnect = function () { l("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect") }, p.prototype.destroy = function () { if (this.subs) { for (var t = 0; t < this.subs.length; t++)this.subs[t].destroy(); this.subs = null } this.io.destroy(this) }, p.prototype.close = p.prototype.disconnect = function () { return this.connected && (l("performing disconnect (%s)", this.nsp), this.packet({ type: i.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this }, p.prototype.compress = function (t) { return this.flags.compress = t, this }, p.prototype.binary = function (t) { return this.flags.binary = t, this } }, weDv: function (t, e, n) { var i = n("ZkHo"), r = n("3dqp"), s = n("NOtv")("engine.io-client:socket"), o = n("7jRU"), a = n("nbjS"), l = n("Uxeu"), c = n("TypT"); function h(t, e) { if (!(this instanceof h)) return new h(t, e); e = e || {}, t && "object" == typeof t && (e = t, t = null), t ? (t = l(t), e.hostname = t.host, e.secure = "https" === t.protocol || "wss" === t.protocol, e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = l(e.host).host), this.secure = null != e.secure ? e.secure : "undefined" != typeof location && "https:" === location.protocol, e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.agent = e.agent || !1, this.hostname = e.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = e.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? 443 : 80), this.query = e.query || {}, "string" == typeof this.query && (this.query = c.decode(this.query)), this.upgrade = !1 !== e.upgrade, this.path = (e.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!e.forceJSONP, this.jsonp = !1 !== e.jsonp, this.forceBase64 = !!e.forceBase64, this.enablesXDR = !!e.enablesXDR, this.withCredentials = !1 !== e.withCredentials, this.timestampParam = e.timestampParam || "t", this.timestampRequests = e.timestampRequests, this.transports = e.transports || ["polling", "websocket"], this.transportOptions = e.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = e.policyPort || 843, this.rememberUpgrade = e.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = e.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== e.perMessageDeflate && (e.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = e.pfx || null, this.key = e.key || null, this.passphrase = e.passphrase || null, this.cert = e.cert || null, this.ca = e.ca || null, this.ciphers = e.ciphers || null, this.rejectUnauthorized = void 0 === e.rejectUnauthorized || e.rejectUnauthorized, this.forceNode = !!e.forceNode, this.isReactNative = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), ("undefined" == typeof self || this.isReactNative) && (e.extraHeaders && Object.keys(e.extraHeaders).length > 0 && (this.extraHeaders = e.extraHeaders), e.localAddress && (this.localAddress = e.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open() } t.exports = h, h.priorWebsocketSuccess = !1, r(h.prototype), h.protocol = a.protocol, h.Socket = h, h.Transport = n("9WME"), h.transports = n("ZkHo"), h.parser = n("nbjS"), h.prototype.createTransport = function (t) { s('creating transport "%s"', t); var e = function (t) { var e = {}; for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]); return e }(this.query); e.EIO = a.protocol, e.transport = t; var n = this.transportOptions[t] || {}; return this.id && (e.sid = this.id), new i[t]({ query: e, socket: this, agent: n.agent || this.agent, hostname: n.hostname || this.hostname, port: n.port || this.port, secure: n.secure || this.secure, path: n.path || this.path, forceJSONP: n.forceJSONP || this.forceJSONP, jsonp: n.jsonp || this.jsonp, forceBase64: n.forceBase64 || this.forceBase64, enablesXDR: n.enablesXDR || this.enablesXDR, withCredentials: n.withCredentials || this.withCredentials, timestampRequests: n.timestampRequests || this.timestampRequests, timestampParam: n.timestampParam || this.timestampParam, policyPort: n.policyPort || this.policyPort, pfx: n.pfx || this.pfx, key: n.key || this.key, passphrase: n.passphrase || this.passphrase, cert: n.cert || this.cert, ca: n.ca || this.ca, ciphers: n.ciphers || this.ciphers, rejectUnauthorized: n.rejectUnauthorized || this.rejectUnauthorized, perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate, extraHeaders: n.extraHeaders || this.extraHeaders, forceNode: n.forceNode || this.forceNode, localAddress: n.localAddress || this.localAddress, requestTimeout: n.requestTimeout || this.requestTimeout, protocols: n.protocols || void 0, isReactNative: this.isReactNative }) }, h.prototype.open = function () { var t; if (this.rememberUpgrade && h.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) t = "websocket"; else { if (0 === this.transports.length) { var e = this; return void setTimeout((function () { e.emit("error", "No transports available") }), 0) } t = this.transports[0] } this.readyState = "opening"; try { t = this.createTransport(t) } catch (n) { return this.transports.shift(), void this.open() } t.open(), this.setTransport(t) }, h.prototype.setTransport = function (t) { s("setting transport %s", t.name); var e = this; this.transport && (s("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = t, t.on("drain", (function () { e.onDrain() })).on("packet", (function (t) { e.onPacket(t) })).on("error", (function (t) { e.onError(t) })).on("close", (function () { e.onClose("transport close") })) }, h.prototype.probe = function (t) { s('probing transport "%s"', t); var e = this.createTransport(t, { probe: 1 }), n = !1, i = this; function r() { i.onlyBinaryUpgrades && (n = n || !this.supportsBinary && i.transport.supportsBinary), n || (s('probe transport "%s" opened', t), e.send([{ type: "ping", data: "probe" }]), e.once("packet", (function (r) { if (!n) if ("pong" === r.type && "probe" === r.data) { if (s('probe transport "%s" pong', t), i.upgrading = !0, i.emit("upgrading", e), !e) return; h.priorWebsocketSuccess = "websocket" === e.name, s('pausing current transport "%s"', i.transport.name), i.transport.pause((function () { n || "closed" !== i.readyState && (s("changing transport and sending upgrade packet"), d(), i.setTransport(e), e.send([{ type: "upgrade" }]), i.emit("upgrade", e), e = null, i.upgrading = !1, i.flush()) })) } else { s('probe transport "%s" failed', t); var o = new Error("probe error"); o.transport = e.name, i.emit("upgradeError", o) } }))) } function o() { n || (n = !0, d(), e.close(), e = null) } function a(n) { var r = new Error("probe error: " + n); r.transport = e.name, o(), s('probe transport "%s" failed because of error: %s', t, n), i.emit("upgradeError", r) } function l() { a("transport closed") } function c() { a("socket closed") } function u(t) { e && t.name !== e.name && (s('"%s" works - aborting "%s"', t.name, e.name), o()) } function d() { e.removeListener("open", r), e.removeListener("error", a), e.removeListener("close", l), i.removeListener("close", c), i.removeListener("upgrading", u) } h.priorWebsocketSuccess = !1, e.once("open", r), e.once("error", a), e.once("close", l), this.once("close", c), this.once("upgrading", u), e.open() }, h.prototype.onOpen = function () { if (s("socket open"), this.readyState = "open", h.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) { s("starting upgrade probes"); for (var t = 0, e = this.upgrades.length; t < e; t++)this.probe(this.upgrades[t]) } }, h.prototype.onPacket = function (t) { if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (s('socket receive: type "%s", data "%s"', t.type, t.data), this.emit("packet", t), this.emit("heartbeat"), t.type) { case "open": this.onHandshake(JSON.parse(t.data)); break; case "pong": this.setPing(), this.emit("pong"); break; case "error": var e = new Error("server error"); e.code = t.data, this.onError(e); break; case "message": this.emit("data", t.data), this.emit("message", t.data) } else s('packet received with socket readyState "%s"', this.readyState) }, h.prototype.onHandshake = function (t) { this.emit("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat)) }, h.prototype.onHeartbeat = function (t) { clearTimeout(this.pingTimeoutTimer); var e = this; e.pingTimeoutTimer = setTimeout((function () { "closed" !== e.readyState && e.onClose("ping timeout") }), t || e.pingInterval + e.pingTimeout) }, h.prototype.setPing = function () { var t = this; clearTimeout(t.pingIntervalTimer), t.pingIntervalTimer = setTimeout((function () { s("writing ping packet - expecting pong within %sms", t.pingTimeout), t.ping(), t.onHeartbeat(t.pingTimeout) }), t.pingInterval) }, h.prototype.ping = function () { var t = this; this.sendPacket("ping", (function () { t.emit("ping") })) }, h.prototype.onDrain = function () { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush() }, h.prototype.flush = function () { "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (s("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush")) }, h.prototype.write = h.prototype.send = function (t, e, n) { return this.sendPacket("message", t, e, n), this }, h.prototype.sendPacket = function (t, e, n, i) { if ("function" == typeof e && (i = e, e = void 0), "function" == typeof n && (i = n, n = null), "closing" !== this.readyState && "closed" !== this.readyState) { (n = n || {}).compress = !1 !== n.compress; var r = { type: t, data: e, options: n }; this.emit("packetCreate", r), this.writeBuffer.push(r), i && this.once("flush", i), this.flush() } }, h.prototype.close = function () { if ("opening" === this.readyState || "open" === this.readyState) { this.readyState = "closing"; var t = this; this.writeBuffer.length ? this.once("drain", (function () { this.upgrading ? i() : e() })) : this.upgrading ? i() : e() } function e() { t.onClose("forced close"), s("socket closing - telling transport to close"), t.transport.close() } function n() { t.removeListener("upgrade", n), t.removeListener("upgradeError", n), e() } function i() { t.once("upgrade", n), t.once("upgradeError", n) } return this }, h.prototype.onError = function (t) { s("socket error %j", t), h.priorWebsocketSuccess = !1, this.emit("error", t), this.onClose("transport error", t) }, h.prototype.onClose = function (t, e) { "opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState || (s('socket close with reason: "%s"', t), clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0) }, h.prototype.filterUpgrades = function (t) { for (var e = [], n = 0, i = t.length; n < i; n++)~o(this.transports, t[n]) && e.push(t[n]); return e } }, xf7l: function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = [], r = "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"; e.definition = { prefix: "fas", iconName: "link", icon: [512, 512, i, "f0c1", r] }, e.faLink = e.definition, e.prefix = "fas", e.iconName = "link", e.width = 512, e.height = 512, e.ligatures = i, e.unicode = "f0c1", e.svgPathData = r }, yLV6: function (t, e, n) { var i; !function (r, s, o, a) { "use strict"; var l, c = ["", "webkit", "Moz", "MS", "ms", "o"], h = s.createElement("div"), u = Math.round, d = Math.abs, p = Date.now; function f(t, e, n) { return setTimeout(w(t, n), e) } function m(t, e, n) { return !!Array.isArray(t) && (g(t, n[e], n), !0) } function g(t, e, n) { var i; if (t) if (t.forEach) t.forEach(e, n); else if (void 0 !== t.length) for (i = 0; i < t.length;)e.call(n, t[i], i, t), i++; else for (i in t) t.hasOwnProperty(i) && e.call(n, t[i], i, t) } function y(t, e, n) { var i = "DEPRECATED METHOD: " + e + "\n" + n + " AT \n"; return function () { var e = new Error("get-stack-trace"), n = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", s = r.console && (r.console.warn || r.console.log); return s && s.call(r.console, i, n), t.apply(this, arguments) } } l = "function" != typeof Object.assign ? function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), n = 1; n < arguments.length; n++) { var i = arguments[n]; if (null != i) for (var r in i) i.hasOwnProperty(r) && (e[r] = i[r]) } return e } : Object.assign; var _ = y((function (t, e, n) { for (var i = Object.keys(e), r = 0; r < i.length;)(!n || n && void 0 === t[i[r]]) && (t[i[r]] = e[i[r]]), r++; return t }), "extend", "Use `assign`."), v = y((function (t, e) { return _(t, e, !0) }), "merge", "Use `assign`."); function b(t, e, n) { var i, r = e.prototype; (i = t.prototype = Object.create(r)).constructor = t, i._super = r, n && l(i, n) } function w(t, e) { return function () { return t.apply(e, arguments) } } function x(t, e) { return "function" == typeof t ? t.apply(e && e[0] || void 0, e) : t } function C(t, e) { return void 0 === t ? e : t } function S(t, e, n) { g(A(e), (function (e) { t.addEventListener(e, n, !1) })) } function k(t, e, n) { g(A(e), (function (e) { t.removeEventListener(e, n, !1) })) } function E(t, e) { for (; t;) { if (t == e) return !0; t = t.parentNode } return !1 } function O(t, e) { return t.indexOf(e) > -1 } function A(t) { return t.trim().split(/\s+/g) } function T(t, e, n) { if (t.indexOf && !n) return t.indexOf(e); for (var i = 0; i < t.length;) { if (n && t[i][n] == e || !n && t[i] === e) return i; i++ } return -1 } function P(t) { return Array.prototype.slice.call(t, 0) } function D(t, e, n) { for (var i = [], r = [], s = 0; s < t.length;) { var o = e ? t[s][e] : t[s]; T(r, o) < 0 && i.push(t[s]), r[s] = o, s++ } return n && (i = e ? i.sort((function (t, n) { return t[e] > n[e] })) : i.sort()), i } function I(t, e) { for (var n, i, r = e[0].toUpperCase() + e.slice(1), s = 0; s < c.length;) { if ((i = (n = c[s]) ? n + r : e) in t) return i; s++ } } var R = 1; function M(t) { var e = t.ownerDocument || t; return e.defaultView || e.parentWindow || r } var L = "ontouchstart" in r, F = void 0 !== I(r, "PointerEvent"), N = L && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), V = ["x", "y"], j = ["clientX", "clientY"]; function B(t, e) { var n = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { x(t.options.enable, [t]) && n.handler(e) }, this.init() } function z(t, e, n) { var i = n.pointers.length, r = n.changedPointers.length, s = 1 & e && i - r == 0, o = 12 & e && i - r == 0; n.isFirst = !!s, n.isFinal = !!o, s && (t.session = {}), n.eventType = e, function (t, e) { var n = t.session, i = e.pointers, r = i.length; n.firstInput || (n.firstInput = H(e)), r > 1 && !n.firstMultiple ? n.firstMultiple = H(e) : 1 === r && (n.firstMultiple = !1); var s = n.firstInput, o = n.firstMultiple, a = o ? o.center : s.center, l = e.center = U(i); e.timeStamp = p(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = G(a, l), e.distance = W(a, l), function (t, e) { var n = e.center, i = t.offsetDelta || {}, r = t.prevDelta || {}, s = t.prevInput || {}; 1 !== e.eventType && 4 !== s.eventType || (r = t.prevDelta = { x: s.deltaX || 0, y: s.deltaY || 0 }, i = t.offsetDelta = { x: n.x, y: n.y }), e.deltaX = r.x + (n.x - i.x), e.deltaY = r.y + (n.y - i.y) }(n, e), e.offsetDirection = q(e.deltaX, e.deltaY); var c, h, u = $(e.deltaTime, e.deltaX, e.deltaY); e.overallVelocityX = u.x, e.overallVelocityY = u.y, e.overallVelocity = d(u.x) > d(u.y) ? u.x : u.y, e.scale = o ? (c = o.pointers, W((h = i)[0], h[1], j) / W(c[0], c[1], j)) : 1, e.rotation = o ? function (t, e) { return G(e[1], e[0], j) + G(t[1], t[0], j) }(o.pointers, i) : 0, e.maxPointers = n.prevInput ? e.pointers.length > n.prevInput.maxPointers ? e.pointers.length : n.prevInput.maxPointers : e.pointers.length, function (t, e) { var n, i, r, s, o = t.lastInterval || e, a = e.timeStamp - o.timeStamp; if (8 != e.eventType && (a > 25 || void 0 === o.velocity)) { var l = e.deltaX - o.deltaX, c = e.deltaY - o.deltaY, h = $(a, l, c); i = h.x, r = h.y, n = d(h.x) > d(h.y) ? h.x : h.y, s = q(l, c), t.lastInterval = e } else n = o.velocity, i = o.velocityX, r = o.velocityY, s = o.direction; e.velocity = n, e.velocityX = i, e.velocityY = r, e.direction = s }(n, e); var f = t.element; E(e.srcEvent.target, f) && (f = e.srcEvent.target), e.target = f }(t, n), t.emit("hammer.input", n), t.recognize(n), t.session.prevInput = n } function H(t) { for (var e = [], n = 0; n < t.pointers.length;)e[n] = { clientX: u(t.pointers[n].clientX), clientY: u(t.pointers[n].clientY) }, n++; return { timeStamp: p(), pointers: e, center: U(e), deltaX: t.deltaX, deltaY: t.deltaY } } function U(t) { var e = t.length; if (1 === e) return { x: u(t[0].clientX), y: u(t[0].clientY) }; for (var n = 0, i = 0, r = 0; r < e;)n += t[r].clientX, i += t[r].clientY, r++; return { x: u(n / e), y: u(i / e) } } function $(t, e, n) { return { x: e / t || 0, y: n / t || 0 } } function q(t, e) { return t === e ? 1 : d(t) >= d(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : 16 } function W(t, e, n) { n || (n = V); var i = e[n[0]] - t[n[0]], r = e[n[1]] - t[n[1]]; return Math.sqrt(i * i + r * r) } function G(t, e, n) { return n || (n = V), 180 * Math.atan2(e[n[1]] - t[n[1]], e[n[0]] - t[n[0]]) / Math.PI } B.prototype = { handler: function () { }, init: function () { this.evEl && S(this.element, this.evEl, this.domHandler), this.evTarget && S(this.target, this.evTarget, this.domHandler), this.evWin && S(M(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && k(this.element, this.evEl, this.domHandler), this.evTarget && k(this.target, this.evTarget, this.domHandler), this.evWin && k(M(this.element), this.evWin, this.domHandler) } }; var Y = { mousedown: 1, mousemove: 2, mouseup: 4 }; function X() { this.evEl = "mousedown", this.evWin = "mousemove mouseup", this.pressed = !1, B.apply(this, arguments) } b(X, B, { handler: function (t) { var e = Y[t.type]; 1 & e && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: "mouse", srcEvent: t })) } }); var K = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }, Q = { 2: "touch", 3: "pen", 4: "mouse", 5: "kinect" }, Z = "pointerdown", J = "pointermove pointerup pointercancel"; function tt() { this.evEl = Z, this.evWin = J, B.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } r.MSPointerEvent && !r.PointerEvent && (Z = "MSPointerDown", J = "MSPointerMove MSPointerUp MSPointerCancel"), b(tt, B, { handler: function (t) { var e = this.store, n = !1, i = t.type.toLowerCase().replace("ms", ""), r = K[i], s = Q[t.pointerType] || t.pointerType, o = "touch" == s, a = T(e, t.pointerId, "pointerId"); 1 & r && (0 === t.button || o) ? a < 0 && (e.push(t), a = e.length - 1) : 12 & r && (n = !0), a < 0 || (e[a] = t, this.callback(this.manager, r, { pointers: e, changedPointers: [t], pointerType: s, srcEvent: t }), n && e.splice(a, 1)) } }); var et = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function nt() { this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, B.apply(this, arguments) } function it(t, e) { var n = P(t.touches), i = P(t.changedTouches); return 12 & e && (n = D(n.concat(i), "identifier", !0)), [n, i] } b(nt, B, { handler: function (t) { var e = et[t.type]; if (1 === e && (this.started = !0), this.started) { var n = it.call(this, t, e); 12 & e && n[0].length - n[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: "touch", srcEvent: t }) } } }); var rt = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function st() { this.evTarget = "touchstart touchmove touchend touchcancel", this.targetIds = {}, B.apply(this, arguments) } function ot(t, e) { var n = P(t.touches), i = this.targetIds; if (3 & e && 1 === n.length) return i[n[0].identifier] = !0, [n, n]; var r, s, o = P(t.changedTouches), a = [], l = this.target; if (s = n.filter((function (t) { return E(t.target, l) })), 1 === e) for (r = 0; r < s.length;)i[s[r].identifier] = !0, r++; for (r = 0; r < o.length;)i[o[r].identifier] && a.push(o[r]), 12 & e && delete i[o[r].identifier], r++; return a.length ? [D(s.concat(a), "identifier", !0), a] : void 0 } function at() { B.apply(this, arguments); var t = w(this.handler, this); this.touch = new st(this.manager, t), this.mouse = new X(this.manager, t), this.primaryTouch = null, this.lastTouches = [] } function lt(t, e) { 1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, ct.call(this, e)) : 12 & t && ct.call(this, e) } function ct(t) { var e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { var n = { x: e.clientX, y: e.clientY }; this.lastTouches.push(n); var i = this.lastTouches; setTimeout((function () { var t = i.indexOf(n); t > -1 && i.splice(t, 1) }), 2500) } } function ht(t) { for (var e = t.srcEvent.clientX, n = t.srcEvent.clientY, i = 0; i < this.lastTouches.length; i++) { var r = this.lastTouches[i], s = Math.abs(e - r.x), o = Math.abs(n - r.y); if (s <= 25 && o <= 25) return !0 } return !1 } b(st, B, { handler: function (t) { var e = rt[t.type], n = ot.call(this, t, e); n && this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: "touch", srcEvent: t }) } }), b(at, B, { handler: function (t, e, n) { var i = "mouse" == n.pointerType; if (!(i && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) { if ("touch" == n.pointerType) lt.call(this, e, n); else if (i && ht.call(this, n)) return; this.callback(t, e, n) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var ut = I(h.style, "touchAction"), dt = void 0 !== ut, pt = function () { if (!dt) return !1; var t = {}, e = r.CSS && r.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (n) { t[n] = !e || r.CSS.supports("touch-action", n) })), t }(); function ft(t, e) { this.manager = t, this.set(e) } function mt(t) { this.options = l({}, this.defaults, t || {}), this.id = R++, this.manager = null, this.options.enable = C(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function gt(t) { return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : "" } function yt(t) { return 16 == t ? "down" : 8 == t ? "up" : 2 == t ? "left" : 4 == t ? "right" : "" } function _t(t, e) { var n = e.manager; return n ? n.get(t) : t } function vt() { mt.apply(this, arguments) } function bt() { vt.apply(this, arguments), this.pX = null, this.pY = null } function wt() { vt.apply(this, arguments) } function xt() { mt.apply(this, arguments), this._timer = null, this._input = null } function Ct() { vt.apply(this, arguments) } function St() { vt.apply(this, arguments) } function kt() { mt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Et(t, e) { return (e = e || {}).recognizers = C(e.recognizers, Et.defaults.preset), new Ot(t, e) } function Ot(t, e) { var n; this.options = l({}, Et.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((n = this).options.inputClass || (F ? tt : N ? st : L ? at : X))(n, z), this.touchAction = new ft(this, this.options.touchAction), At(this, !0), g(this.options.recognizers, (function (t) { var e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }), this) } function At(t, e) { var n, i = t.element; i.style && (g(t.options.cssProps, (function (r, s) { n = I(i.style, s), e ? (t.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = t.oldCssProps[n] || "" })), e || (t.oldCssProps = {})) } ft.prototype = { set: function (t) { "compute" == t && (t = this.compute()), dt && this.manager.element.style && pt[t] && (this.manager.element.style[ut] = t), this.actions = t.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var t = []; return g(this.manager.recognizers, (function (e) { x(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) })), function (t) { if (O(t, "none")) return "none"; var e = O(t, "pan-x"), n = O(t, "pan-y"); return e && n ? "none" : e || n ? e ? "pan-x" : "pan-y" : O(t, "manipulation") ? "manipulation" : "auto" }(t.join(" ")) }, preventDefaults: function (t) { var e = t.srcEvent, n = t.offsetDirection; if (this.manager.session.prevented) e.preventDefault(); else { var i = this.actions, r = O(i, "none") && !pt.none, s = O(i, "pan-y") && !pt["pan-y"], o = O(i, "pan-x") && !pt["pan-x"]; if (r && 1 === t.pointers.length && t.distance < 2 && t.deltaTime < 250) return; if (!o || !s) return r || s && 6 & n || o && 24 & n ? this.preventSrc(e) : void 0 } }, preventSrc: function (t) { this.manager.session.prevented = !0, t.preventDefault() } }, mt.prototype = { defaults: {}, set: function (t) { return l(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (t) { if (m(t, "recognizeWith", this)) return this; var e = this.simultaneous; return e[(t = _t(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function (t) { return m(t, "dropRecognizeWith", this) || (t = _t(t, this), delete this.simultaneous[t.id]), this }, requireFailure: function (t) { if (m(t, "requireFailure", this)) return this; var e = this.requireFail; return -1 === T(e, t = _t(t, this)) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function (t) { if (m(t, "dropRequireFailure", this)) return this; t = _t(t, this); var e = T(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (t) { return !!this.simultaneous[t.id] }, emit: function (t) { var e = this, n = this.state; function i(n) { e.manager.emit(n, t) } n < 8 && i(e.options.event + gt(n)), i(e.options.event), t.additionalEvent && i(t.additionalEvent), n >= 8 && i(e.options.event + gt(n)) }, tryEmit: function (t) { if (this.canEmit()) return this.emit(t); this.state = 32 }, canEmit: function () { for (var t = 0; t < this.requireFail.length;) { if (!(33 & this.requireFail[t].state)) return !1; t++ } return !0 }, recognize: function (t) { var e = l({}, t); if (!x(this.options.enable, [this, e])) return this.reset(), void (this.state = 32); 56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e) }, process: function (t) { }, getTouchAction: function () { }, reset: function () { } }, b(vt, mt, { defaults: { pointers: 1 }, attrTest: function (t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function (t) { var e = this.state, n = t.eventType, i = 6 & e, r = this.attrTest(t); return i && (8 & n || !r) ? 16 | e : i || r ? 4 & n ? 8 | e : 2 & e ? 4 | e : 2 : 32 } }), b(bt, vt, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function () { var t = this.options.direction, e = []; return 6 & t && e.push("pan-y"), 24 & t && e.push("pan-x"), e }, directionTest: function (t) { var e = this.options, n = !0, i = t.distance, r = t.direction, s = t.deltaX, o = t.deltaY; return r & e.direction || (6 & e.direction ? (r = 0 === s ? 1 : s < 0 ? 2 : 4, n = s != this.pX, i = Math.abs(t.deltaX)) : (r = 0 === o ? 1 : o < 0 ? 8 : 16, n = o != this.pY, i = Math.abs(t.deltaY))), t.direction = r, n && i > e.threshold && r & e.direction }, attrTest: function (t) { return vt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t)) }, emit: function (t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = yt(t.direction); e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), b(wt, vt, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return ["none"] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function (t) { 1 !== t.scale && (t.additionalEvent = this.options.event + (t.scale < 1 ? "in" : "out")), this._super.emit.call(this, t) } }), b(xt, mt, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return ["auto"] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, i = t.distance < e.threshold, r = t.deltaTime > e.time; if (this._input = t, !i || !n || 12 & t.eventType && !r) this.reset(); else if (1 & t.eventType) this.reset(), this._timer = f((function () { this.state = 8, this.tryEmit() }), e.time, this); else if (4 & t.eventType) return 8; return 32 }, reset: function () { clearTimeout(this._timer) }, emit: function (t) { 8 === this.state && (t && 4 & t.eventType ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = p(), this.manager.emit(this.options.event, this._input))) } }), b(Ct, vt, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return ["none"] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state) } }), b(St, vt, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function () { return bt.prototype.getTouchAction.call(this) }, attrTest: function (t) { var e, n = this.options.direction; return 30 & n ? e = t.overallVelocity : 6 & n ? e = t.overallVelocityX : 24 & n && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && n & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && d(e) > this.options.velocity && 4 & t.eventType }, emit: function (t) { var e = yt(t.offsetDirection); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), b(kt, mt, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return ["manipulation"] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, i = t.distance < e.threshold, r = t.deltaTime < e.time; if (this.reset(), 1 & t.eventType && 0 === this.count) return this.failTimeout(); if (i && r && n) { if (4 != t.eventType) return this.failTimeout(); var s = !this.pTime || t.timeStamp - this.pTime < e.interval, o = !this.pCenter || W(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, o && s ? this.count += 1 : this.count = 1, this._input = t, 0 == this.count % e.taps) return this.hasRequireFailures() ? (this._timer = f((function () { this.state = 8, this.tryEmit() }), e.interval, this), 2) : 8 } return 32 }, failTimeout: function () { return this._timer = f((function () { this.state = 32 }), this.options.interval, this), 32 }, reset: function () { clearTimeout(this._timer) }, emit: function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Et.VERSION = "2.0.7", Et.defaults = { domEvents: !1, touchAction: "compute", enable: !0, inputTarget: null, inputClass: null, preset: [[Ct, { enable: !1 }], [wt, { enable: !1 }, ["rotate"]], [St, { direction: 6 }], [bt, { direction: 6 }, ["swipe"]], [kt], [kt, { event: "doubletap", taps: 2 }, ["tap"]], [xt]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }, Ot.prototype = { set: function (t) { return l(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function (t) { this.session.stopped = t ? 2 : 1 }, recognize: function (t) { var e = this.session; if (!e.stopped) { var n; this.touchAction.preventDefaults(t); var i = this.recognizers, r = e.curRecognizer; (!r || r && 8 & r.state) && (r = e.curRecognizer = null); for (var s = 0; s < i.length;)n = i[s], 2 === e.stopped || r && n != r && !n.canRecognizeWith(r) ? n.reset() : n.recognize(t), !r && 14 & n.state && (r = e.curRecognizer = n), s++ } }, get: function (t) { if (t instanceof mt) return t; for (var e = this.recognizers, n = 0; n < e.length; n++)if (e[n].options.event == t) return e[n]; return null }, add: function (t) { if (m(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function (t) { if (m(t, "remove", this)) return this; if (t = this.get(t)) { var e = this.recognizers, n = T(e, t); -1 !== n && (e.splice(n, 1), this.touchAction.update()) } return this }, on: function (t, e) { if (void 0 !== t && void 0 !== e) { var n = this.handlers; return g(A(t), (function (t) { n[t] = n[t] || [], n[t].push(e) })), this } }, off: function (t, e) { if (void 0 !== t) { var n = this.handlers; return g(A(t), (function (t) { e ? n[t] && n[t].splice(T(n[t], e), 1) : delete n[t] })), this } }, emit: function (t, e) { this.options.domEvents && function (t, e) { var n = s.createEvent("Event"); n.initEvent(t, !0, !0), n.gesture = e, e.target.dispatchEvent(n) }(t, e); var n = this.handlers[t] && this.handlers[t].slice(); if (n && n.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault() }; for (var i = 0; i < n.length;)n[i](e), i++ } }, destroy: function () { this.element && At(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, l(Et, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: 32, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: 24, DIRECTION_ALL: 30, Manager: Ot, Input: B, TouchAction: ft, TouchInput: st, MouseInput: X, PointerEventInput: tt, TouchMouseInput: at, SingleTouchInput: nt, Recognizer: mt, AttrRecognizer: vt, Tap: kt, Pan: bt, Swipe: St, Pinch: wt, Rotate: Ct, Press: xt, on: S, off: k, each: g, merge: v, extend: _, assign: l, inherit: b, bindFn: w, prefixed: I }), (void 0 !== r ? r : "undefined" != typeof self ? self : {}).Hammer = Et, void 0 === (i = (function () { return Et }).call(e, n, e, t)) || (t.exports = i) }(window, document) }, yeub: function (t, e) { try { t.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest } catch (n) { t.exports = !1 } }, ypnn: function (t, e) { t.exports = function (t, e, n) { var i = t.byteLength; if (e = e || 0, n = n || i, t.slice) return t.slice(e, n); if (e < 0 && (e += i), n < 0 && (n += i), n > i && (n = i), e >= i || e >= n || 0 === i) return new ArrayBuffer(0); for (var r = new Uint8Array(t), s = new Uint8Array(n - e), o = e, a = 0; o < n; o++, a++)s[a] = r[o]; return s.buffer } }, zMFY: function (t, e) { function n() { } t.exports = function (t, e, i) { var r = !1; return i = i || n, s.count = t, 0 === t ? e() : s; function s(t, n) { if (s.count <= 0) throw new Error("after called too many times"); --s.count, t ? (r = !0, e(t), e = i) : 0 !== s.count || r || e(null, n) } } }, zUnb: function (t, e, n) { "use strict"; function i(t) { return "function" == typeof t } n.r(e), n("yLV6"); let r = !1; const s = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else r && console.log("RxJS: Back to a better error behavior. Thank you. <3"); r = t }, get useDeprecatedSynchronousErrorHandling() { return r } }; function o(t) { setTimeout(() => { throw t }, 0) } const a = { closed: !0, next(t) { }, error(t) { if (s.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, l = (() => Array.isArray || (t => t && "number" == typeof t.length))(); function c(t) { return null !== t && "object" == typeof t } const h = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let u = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: n, _unsubscribe: r, _subscriptions: s } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof t) n.remove(this); else if (null !== n) for (let t = 0; t < n.length; ++t)n[t].remove(this); if (i(r)) try { r.call(this) } catch (o) { e = o instanceof h ? d(o.errors) : [o] } if (l(s)) { let t = -1, n = s.length; for (; ++t < n;) { const n = s[t]; if (c(n)) try { n.unsubscribe() } catch (o) { e = e || [], o instanceof h ? e = e.concat(d(o.errors)) : e.push(o) } } } if (e) throw new h(e) } add(e) { let n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: i } = n; if (null === i) n._parentOrParents = this; else if (i instanceof t) { if (i === this) return n; n._parentOrParents = [i, this] } else { if (-1 !== i.indexOf(this)) return n; i.push(this) } const r = this._subscriptions; return null === r ? this._subscriptions = [n] : r.push(n), n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function d(t) { return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), []) } const p = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())(); class f extends u { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!t) { this.destination = a; break } if ("object" == typeof t) { t instanceof f ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new m(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new m(this, t, e, n) } } [p]() { return this } static create(t, e, n) { const i = new f(t, e, n); return i.syncErrorThrowable = !1, i } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class m extends f { constructor(t, e, n, r) { let s; super(), this._parentSubscriber = t; let o = this; i(e) ? s = e : e && (s = e.next, n = e.error, r = e.complete, e !== a && (o = Object.create(e), i(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = s, this._error = n, this._complete = r } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; s.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = s; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); s.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), s.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(t, e, n) { if (!s.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (i) { return s.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = i, t.syncErrorThrown = !0, !0) : (o(i), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const g = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")(); function y(t) { return t } function _(...t) { return v(t) } function v(t) { return 0 === t.length ? y : 1 === t.length ? t[0] : function (e) { return t.reduce((t, e) => e(t), e) } } let b = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: i } = this, r = function (t, e, n) { if (t) { if (t instanceof f) return t; if (t[p]) return t[p]() } return t || e || n ? new f(t, e, n) : new f(a) }(t, e, n); if (r.add(i ? i.call(r, this.source) : this.source || s.useDeprecatedSynchronousErrorHandling && !r.syncErrorThrowable ? this._subscribe(r) : this._trySubscribe(r)), s.useDeprecatedSynchronousErrorHandling && r.syncErrorThrowable && (r.syncErrorThrowable = !1, r.syncErrorThrown)) throw r.syncErrorValue; return r } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { s.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: i } = t; if (e || i) return !1; t = n && n instanceof f ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = w(e))((e, n) => { let i; i = this.subscribe(e => { try { t(e) } catch (r) { n(r), i && i.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [g]() { return this } pipe(...t) { return 0 === t.length ? this : v(t)(this) } toPromise(t) { return new (t = w(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function w(t) { if (t || (t = s.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const x = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })(); class C extends u { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class S extends f { constructor(t) { super(t), this.destination = t } } let k = (() => { class t extends b { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [p]() { return new S(this) } lift(t) { const e = new E(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new x; if (!this.isStopped) { const { observers: e } = this, n = e.length, i = e.slice(); for (let r = 0; r < n; r++)i[r].next(t) } } error(t) { if (this.closed) throw new x; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, i = e.slice(); for (let r = 0; r < n; r++)i[r].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new x; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let i = 0; i < e; i++)n[i].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new x; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new x; return this.hasError ? (t.error(this.thrownError), u.EMPTY) : this.isStopped ? (t.complete(), u.EMPTY) : (this.observers.push(t), new C(this, t)) } asObservable() { const t = new b; return t.source = this, t } } return t.create = (t, e) => new E(t, e), t })(); class E extends k { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : u.EMPTY } } function O(t) { return t && "function" == typeof t.schedule } class A extends f { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } const T = t => e => { for (let n = 0, i = t.length; n < i && !e.closed; n++)e.next(t[n]); e.complete() }; function P() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const D = P(), I = t => t && "number" == typeof t.length && "function" != typeof t; function R(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const M = t => { if (t && "function" == typeof t[g]) return i = t, t => { const e = i[g](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (I(t)) return T(t); if (R(t)) return n = t, t => (n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, o), t); if (t && "function" == typeof t[D]) return e = t, t => { const n = e[D](); for (; ;) { const e = n.next(); if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = c(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected.` + " You can provide an Observable, Promise, Array, or Iterable.") } var e, n, i }; function L(t, e, n, i, r = new A(t, n, i)) { if (!r.closed) return e instanceof b ? e.subscribe(r) : M(e)(r) } class F extends f { notifyNext(t, e, n, i, r) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } function N(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new V(t, e)) } } class V { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new j(t, this.project, this.thisArg)) } } class j extends f { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function B(t, e) { return new b(n => { const i = new u; let r = 0; return i.add(e.schedule((function () { r !== t.length ? (n.next(t[r++]), n.closed || i.add(this.schedule())) : n.complete() }))), i }) } function z(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[g] }(t)) return function (t, e) { return new b(n => { const i = new u; return i.add(e.schedule(() => { const r = t[g](); i.add(r.subscribe({ next(t) { i.add(e.schedule(() => n.next(t))) }, error(t) { i.add(e.schedule(() => n.error(t))) }, complete() { i.add(e.schedule(() => n.complete())) } })) })), i }) }(t, e); if (R(t)) return function (t, e) { return new b(n => { const i = new u; return i.add(e.schedule(() => t.then(t => { i.add(e.schedule(() => { n.next(t), i.add(e.schedule(() => n.complete())) })) }, t => { i.add(e.schedule(() => n.error(t))) }))), i }) }(t, e); if (I(t)) return B(t, e); if (function (t) { return t && "function" == typeof t[D] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new b(n => { const i = new u; let r; return i.add(() => { r && "function" == typeof r.return && r.return() }), i.add(e.schedule(() => { r = t[D](), i.add(e.schedule((function () { if (n.closed) return; let t, e; try { const n = r.next(); t = n.value, e = n.done } catch (i) { return void n.error(i) } e ? n.complete() : (n.next(t), this.schedule()) }))) })), i }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof b ? t : new b(M(t)) } function H(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? i => i.pipe(H((n, i) => z(t(n, i)).pipe(N((t, r) => e(n, t, i, r))), n)) : ("number" == typeof e && (n = e), e => e.lift(new U(t, n))) } class U { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new $(t, this.project, this.concurrent)) } } class $ extends F { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (i) { return void this.destination.error(i) } this.active++, this._innerSub(e, t, n) } _innerSub(t, e, n) { const i = new A(this, e, n), r = this.destination; r.add(i); const s = L(this, t, void 0, void 0, i); s !== i && r.add(s) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t, e, n, i, r) { this.destination.next(e) } notifyComplete(t) { const e = this.buffer; this.remove(t), this.active--, e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function q(t = Number.POSITIVE_INFINITY) { return H(y, t) } function W(t, e) { return e ? B(t, e) : new b(T(t)) } function G(...t) { let e = Number.POSITIVE_INFINITY, n = null, i = t[t.length - 1]; return O(i) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof i && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof b ? t[0] : q(e)(W(t, n)) } function Y() { return function (t) { return t.lift(new X(t)) } } class X { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const i = new K(t, n), r = e.subscribe(i); return i.closed || (i.connection = n.connect()), r } } class K extends f { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, i = t._connection; this.connection = null, !i || n && i !== n || i.unsubscribe() } } class Q extends b { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new u, t.add(this.source.subscribe(new J(this.getSubject(), this))), t.closed && (this._connection = null, t = u.EMPTY)), t } refCount() { return Y()(this) } } const Z = (() => { const t = Q.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class J extends S { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function tt(t, e) { return function (n) { let i; if (i = "function" == typeof t ? t : function () { return t }, "function" == typeof e) return n.lift(new et(i, e)); const r = Object.create(n, Z); return r.source = n, r.subjectFactory = i, r } } class et { constructor(t, e) { this.subjectFactory = t, this.selector = e } call(t, e) { const { selector: n } = this, i = this.subjectFactory(), r = n(i).subscribe(t); return r.add(e.subscribe(i)), r } } function nt() { return new k } function it(t) { return { toString: t }.toString() } function rt(t, e, n) { return it(() => { const i = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function r(...t) { if (this instanceof r) return i.apply(this, t), this; const e = new r(...t); return n.annotation = e, n; function n(t, n, i) { const r = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", { value: [] }).__parameters__; for (; r.length <= i;)r.push(null); return (r[i] = r[i] || []).push(e), t } } return n && (r.prototype = Object.create(n.prototype)), r.prototype.ngMetadataName = t, r.annotationCls = r, r }) } const st = rt("Inject", t => ({ token: t })), ot = rt("Optional"), at = rt("Self"), lt = rt("SkipSelf"); var ct = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); function ht(t) { for (let e in t) if (t[e] === ht) return e; throw Error("Could not find renamed property on target object.") } function ut(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function dt(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function pt(t) { return { factory: t.factory, providers: t.providers || [], imports: t.imports || [] } } function ft(t) { return mt(t, t[yt]) || mt(t, t[bt]) } function mt(t, e) { return e && e.token === t ? e : null } function gt(t) { return t && (t.hasOwnProperty(_t) || t.hasOwnProperty(wt)) ? t[_t] : null } const yt = ht({ "\u0275prov": ht }), _t = ht({ "\u0275inj": ht }), vt = ht({ "\u0275provFallback": ht }), bt = ht({ ngInjectableDef: ht }), wt = ht({ ngInjectorDef: ht }); function xt(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(xt).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function Ct(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const St = ht({ __forward_ref__: ht }); function kt(t) { return t.__forward_ref__ = kt, t.toString = function () { return xt(this()) }, t } function Et(t) { return Ot(t) ? t() : t } function Ot(t) { return "function" == typeof t && t.hasOwnProperty(St) && t.__forward_ref__ === kt } const At = "undefined" != typeof globalThis && globalThis, Tt = "undefined" != typeof window && window, Pt = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Dt = "undefined" != typeof global && global, It = At || Dt || Tt || Pt, Rt = ht({ "\u0275cmp": ht }), Mt = ht({ "\u0275dir": ht }), Lt = ht({ "\u0275pipe": ht }), Ft = ht({ "\u0275mod": ht }), Nt = ht({ "\u0275loc": ht }), Vt = ht({ "\u0275fac": ht }), jt = ht({ __NG_ELEMENT_ID__: ht }); class Bt { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = dt({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const zt = new Bt("INJECTOR", -1), Ht = {}, Ut = /\n/gm, $t = ht({ provide: String, useValue: ht }); let qt, Wt = void 0; function Gt(t) { const e = Wt; return Wt = t, e } function Yt(t) { const e = qt; return qt = t, e } function Xt(t, e = ct.Default) { if (void 0 === Wt) throw new Error("inject() must be called from an injection context"); return null === Wt ? Zt(t, void 0, e) : Wt.get(t, e & ct.Optional ? null : void 0, e) } function Kt(t, e = ct.Default) { return (qt || Xt)(Et(t), e) } const Qt = Kt; function Zt(t, e, n) { const i = ft(t); if (i && "root" == i.providedIn) return void 0 === i.value ? i.value = i.factory() : i.value; if (n & ct.Optional) return null; if (void 0 !== e) return e; throw new Error(`Injector: NOT_FOUND [${xt(t)}]`) } function Jt(t) { const e = []; for (let n = 0; n < t.length; n++) { const i = Et(t[n]); if (Array.isArray(i)) { if (0 === i.length) throw new Error("Arguments array must have arguments."); let t = void 0, n = ct.Default; for (let e = 0; e < i.length; e++) { const r = i[e]; r instanceof ot || "Optional" === r.ngMetadataName || r === ot ? n |= ct.Optional : r instanceof lt || "SkipSelf" === r.ngMetadataName || r === lt ? n |= ct.SkipSelf : r instanceof at || "Self" === r.ngMetadataName || r === at ? n |= ct.Self : t = r instanceof st || r === st ? r.token : r } e.push(Kt(t, n)) } else e.push(Kt(i)) } return e } class te { get(t, e = Ht) { if (e === Ht) { const e = new Error(`NullInjectorError: No provider for ${xt(t)}!`); throw e.name = "NullInjectorError", e } return e } } class ee { } class ne { } function ie(t, e) { t.forEach(t => Array.isArray(t) ? ie(t, e) : e(t)) } function re(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function se(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function oe(t, e) { const n = []; for (let i = 0; i < t; i++)n.push(e); return n } function ae(t, e, n) { let i = ce(t, e); return i >= 0 ? t[1 | i] = n : (i = ~i, function (t, e, n, i) { let r = t.length; if (r == e) t.push(n, i); else if (1 === r) t.push(i, t[0]), t[0] = n; else { for (r--, t.push(t[r - 1], t[r]); r > e;)t[r] = t[r - 2], r--; t[e] = n, t[e + 1] = i } }(t, i, e, n)), i } function le(t, e) { const n = ce(t, e); if (n >= 0) return t[1 | n] } function ce(t, e) { return function (t, e, n) { let i = 0, r = t.length >> 1; for (; r !== i;) { const n = i + (r - i >> 1), s = t[n << 1]; if (e === s) return n << 1; s > e ? r = n : i = n + 1 } return ~(r << 1) }(t, e) } const he = function () { var t = { OnPush: 0, Default: 1 }; return t[t.OnPush] = "OnPush", t[t.Default] = "Default", t }(), ue = function () { var t = { Emulated: 0, Native: 1, None: 2, ShadowDom: 3 }; return t[t.Emulated] = "Emulated", t[t.Native] = "Native", t[t.None] = "None", t[t.ShadowDom] = "ShadowDom", t }(), de = {}, pe = []; let fe = 0; function me(t) { return it(() => { const e = t.type, n = e.prototype, i = {}, r = { type: e, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: i, inputs: null, outputs: null, exportAs: t.exportAs || null, onChanges: null, onInit: n.ngOnInit || null, doCheck: n.ngDoCheck || null, afterContentInit: n.ngAfterContentInit || null, afterContentChecked: n.ngAfterContentChecked || null, afterViewInit: n.ngAfterViewInit || null, afterViewChecked: n.ngAfterViewChecked || null, onDestroy: n.ngOnDestroy || null, onPush: t.changeDetection === he.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || pe, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || ue.Emulated, id: "c", styles: t.styles || pe, _: null, setInput: null, schemas: t.schemas || null, tView: null }, s = t.directives, o = t.features, a = t.pipes; return r.id += fe++, r.inputs = be(t.inputs, i), r.outputs = be(t.outputs), o && o.forEach(t => t(r)), r.directiveDefs = s ? () => ("function" == typeof s ? s() : s).map(ge) : null, r.pipeDefs = a ? () => ("function" == typeof a ? a() : a).map(ye) : null, r }) } function ge(t) { return Ce(t) || function (t) { return t[Mt] || null }(t) } function ye(t) { return function (t) { return t[Lt] || null }(t) } const _e = {}; function ve(t) { const e = { type: t.type, bootstrap: t.bootstrap || pe, declarations: t.declarations || pe, imports: t.imports || pe, exports: t.exports || pe, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && it(() => { _e[t.id] = t.type }), e } function be(t, e) { if (null == t) return de; const n = {}; for (const i in t) if (t.hasOwnProperty(i)) { let r = t[i], s = r; Array.isArray(r) && (s = r[1], r = r[0]), n[r] = i, e && (e[r] = s) } return n } const we = me; function xe(t) { return { type: t.type, name: t.name, factory: null, pure: !1 !== t.pure, onDestroy: t.type.prototype.ngOnDestroy || null } } function Ce(t) { return t[Rt] || null } function Se(t, e) { return t.hasOwnProperty(Vt) ? t[Vt] : null } function ke(t, e) { const n = t[Ft] || null; if (!n && !0 === e) throw new Error(`Type ${xt(t)} does not have '\u0275mod' property.`); return n } function Ee(t) { return Array.isArray(t) && "object" == typeof t[1] } function Oe(t) { return Array.isArray(t) && !0 === t[1] } function Ae(t) { return 0 != (8 & t.flags) } function Te(t) { return 2 == (2 & t.flags) } function Pe(t) { return 1 == (1 & t.flags) } function De(t) { return null !== t.template } function Ie(t) { return 0 != (512 & t[2]) } let Re = void 0; function Me() { return void 0 !== Re ? Re : "undefined" != typeof document ? document : void 0 } function Le(t) { return !!t.listen } const Fe = { createRenderer: (t, e) => Me() }; function Ne(t) { for (; Array.isArray(t);)t = t[0]; return t } function Ve(t, e) { return Ne(e[t + 19]) } function je(t, e) { return Ne(e[t.index]) } function Be(t, e) { return t.data[e + 19] } function ze(t, e) { return t[e + 19] } function He(t, e) { const n = e[t]; return Ee(n) ? n : n[0] } function Ue(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function $e(t) { return 4 == (4 & t[2]) } function qe(t) { return 128 == (128 & t[2]) } function We(t, e) { return null === t || null == e ? null : t[e] } function Ge(t) { t[18] = 0 } const Ye = { lFrame: _n(null), bindingsEnabled: !0, checkNoChangesMode: !1 }; function Xe() { return Ye.bindingsEnabled } function Ke() { return Ye.lFrame.lView } function Qe() { return Ye.lFrame.tView } function Ze(t) { Ye.lFrame.contextLView = t } function Je() { return Ye.lFrame.previousOrParentTNode } function tn(t, e) { Ye.lFrame.previousOrParentTNode = t, Ye.lFrame.isParent = e } function en() { return Ye.lFrame.isParent } function nn() { Ye.lFrame.isParent = !1 } function rn() { return Ye.checkNoChangesMode } function sn(t) { Ye.checkNoChangesMode = t } function on() { const t = Ye.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function an() { return Ye.lFrame.bindingIndex } function ln() { return Ye.lFrame.bindingIndex++ } function cn(t) { const e = Ye.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function hn(t, e) { const n = Ye.lFrame; n.bindingIndex = n.bindingRootIndex = t, un(e) } function un(t) { Ye.lFrame.currentDirectiveIndex = t } function dn(t) { const e = Ye.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] } function pn() { return Ye.lFrame.currentQueryIndex } function fn(t) { Ye.lFrame.currentQueryIndex = t } function mn(t, e) { const n = yn(); Ye.lFrame = n, n.previousOrParentTNode = e, n.lView = t } function gn(t, e) { const n = yn(), i = t[1]; Ye.lFrame = n, n.previousOrParentTNode = e, n.lView = t, n.tView = i, n.contextLView = t, n.bindingIndex = i.bindingStartIndex } function yn() { const t = Ye.lFrame, e = null === t ? null : t.child; return null === e ? _n(t) : e } function _n(t) { const e = { previousOrParentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: 0, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentSanitizer: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null }; return null !== t && (t.child = e), e } function vn() { const t = Ye.lFrame; return Ye.lFrame = t.parent, t.previousOrParentTNode = null, t.lView = null, t } const bn = vn; function wn() { const t = vn(); t.isParent = !0, t.tView = null, t.selectedIndex = 0, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.currentSanitizer = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function xn() { return Ye.lFrame.selectedIndex } function Cn(t) { Ye.lFrame.selectedIndex = t } function Sn() { const t = Ye.lFrame; return Be(t.tView, t.selectedIndex) } function kn() { Ye.lFrame.currentNamespace = "http://www.w3.org/2000/svg" } function En() { Ye.lFrame.currentNamespace = null } function On(t, e) { for (let n = e.directiveStart, i = e.directiveEnd; n < i; n++) { const e = t.data[n]; e.afterContentInit && (t.contentHooks || (t.contentHooks = [])).push(-n, e.afterContentInit), e.afterContentChecked && ((t.contentHooks || (t.contentHooks = [])).push(n, e.afterContentChecked), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, e.afterContentChecked)), e.afterViewInit && (t.viewHooks || (t.viewHooks = [])).push(-n, e.afterViewInit), e.afterViewChecked && ((t.viewHooks || (t.viewHooks = [])).push(n, e.afterViewChecked), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, e.afterViewChecked)), null != e.onDestroy && (t.destroyHooks || (t.destroyHooks = [])).push(n, e.onDestroy) } } function An(t, e, n) { Dn(t, e, 3, n) } function Tn(t, e, n, i) { (3 & t[2]) === n && Dn(t, e, n, i) } function Pn(t, e) { let n = t[2]; (3 & n) === e && (n &= 1023, n += 1, t[2] = n) } function Dn(t, e, n, i) { const r = null != i ? i : -1; let s = 0; for (let o = void 0 !== i ? 65535 & t[18] : 0; o < e.length; o++)if ("number" == typeof e[o + 1]) { if (s = e[o], null != i && s >= i) break } else e[o] < 0 && (t[18] += 65536), (s < r || -1 == r) && (In(t, n, e, o), t[18] = (4294901760 & t[18]) + o + 2), o++ } function In(t, e, n, i) { const r = n[i] < 0, s = n[i + 1], o = t[r ? -n[i] : n[i]]; r ? t[2] >> 10 < t[18] >> 16 && (3 & t[2]) === e && (t[2] += 1024, s.call(o)) : s.call(o) } class Rn { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function Mn(t, e, n) { const i = Le(t); let r = 0; for (; r < n.length;) { const s = n[r]; if ("number" == typeof s) { if (0 !== s) break; r++; const o = n[r++], a = n[r++], l = n[r++]; i ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = s, a = n[++r]; Fn(o) ? i && t.setProperty(e, o, a) : i ? t.setAttribute(e, o, a) : e.setAttribute(o, a), r++ } } return r } function Ln(t) { return 3 === t || 4 === t || 6 === t } function Fn(t) { return 64 === t.charCodeAt(0) } function Nn(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let i = 0; i < e.length; i++) { const r = e[i]; "number" == typeof r ? n = r : 0 === n || Vn(t, n, r, null, -1 === n || 2 === n ? e[++i] : null) } } return t } function Vn(t, e, n, i, r) { let s = 0, o = t.length; if (-1 === e) o = -1; else for (; s < t.length;) { const n = t[s++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = s - 1; break } } } for (; s < t.length;) { const e = t[s]; if ("number" == typeof e) break; if (e === n) { if (null === i) return void (null !== r && (t[s + 1] = r)); if (i === t[s + 1]) return void (t[s + 2] = r) } s++, null !== i && s++, null !== r && s++ } -1 !== o && (t.splice(o, 0, e), s = o + 1), t.splice(s++, 0, n), null !== i && t.splice(s++, 0, i), null !== r && t.splice(s++, 0, r) } function jn(t) { return -1 !== t } function Bn(t) { return 32767 & t } function zn(t) { return t >> 16 } function Hn(t, e) { let n = zn(t), i = e; for (; n > 0;)i = i[15], n--; return i } function Un(t) { return "string" == typeof t ? t : null == t ? "" : "" + t } function $n(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : Un(t) } const qn = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(It))(); function Wn(t) { return { name: "body", target: t.ownerDocument.body } } function Gn(t) { return t instanceof Function ? t() : t } let Yn = !0; function Xn(t) { const e = Yn; return Yn = t, e } let Kn = 0; function Qn(t, e) { const n = Jn(t, e); if (-1 !== n) return n; const i = e[1]; i.firstCreatePass && (t.injectorIndex = e.length, Zn(i.data, t), Zn(e, null), Zn(i.blueprint, null)); const r = ti(t, e), s = t.injectorIndex; if (jn(r)) { const t = Bn(r), n = Hn(r, e), i = n[1].data; for (let r = 0; r < 8; r++)e[s + r] = n[t + r] | i[t + r] } return e[s + 8] = r, s } function Zn(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Jn(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null == e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function ti(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = e[6], i = 1; for (; n && -1 === n.injectorIndex;)n = (e = e[15]) ? e[6] : null, i++; return n ? n.injectorIndex | i << 16 : -1 } function ei(t, e, n) { !function (t, e, n) { let i = "string" != typeof n ? n[jt] : n.charCodeAt(0) || 0; null == i && (i = n[jt] = Kn++); const r = 255 & i, s = 1 << r, o = 64 & r, a = 32 & r, l = e.data; 128 & r ? o ? a ? l[t + 7] |= s : l[t + 6] |= s : a ? l[t + 5] |= s : l[t + 4] |= s : o ? a ? l[t + 3] |= s : l[t + 2] |= s : a ? l[t + 1] |= s : l[t] |= s }(t, e, n) } function ni(t, e, n, i = ct.Default, r) { if (null !== t) { const r = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t[jt]; return "number" == typeof e && e > 0 ? 255 & e : e }(n); if ("function" == typeof r) { mn(e, t); try { const t = r(); if (null != t || i & ct.Optional) return t; throw new Error(`No provider for ${$n(n)}!`) } finally { bn() } } else if ("number" == typeof r) { if (-1 === r) return new ci(t, e); let s = null, o = Jn(t, e), a = -1, l = i & ct.Host ? e[16][6] : null; for ((-1 === o || i & ct.SkipSelf) && (a = -1 === o ? ti(t, e) : e[o + 8], li(i, !1) ? (s = e[1], o = Bn(a), e = Hn(a, e)) : o = -1); -1 !== o;) { a = e[o + 8]; const t = e[1]; if (ai(r, o, t.data)) { const t = ri(o, e, n, s, i, l); if (t !== ii) return t } li(i, e[1].data[o + 8] === l) && ai(r, o, e) ? (s = t, o = Bn(a), e = Hn(a, e)) : o = -1 } } } if (i & ct.Optional && void 0 === r && (r = null), 0 == (i & (ct.Self | ct.Host))) { const t = e[9], s = Yt(void 0); try { return t ? t.get(n, r, i & ct.Optional) : Zt(n, r, i & ct.Optional) } finally { Yt(s) } } if (i & ct.Optional) return r; throw new Error(`NodeInjector: NOT_FOUND [${$n(n)}]`) } const ii = {}; function ri(t, e, n, i, r, s) { const o = e[1], a = o.data[t + 8], l = si(a, o, n, null == i ? Te(a) && Yn : i != o && 3 === a.type, r & ct.Host && s === a); return null !== l ? oi(e, o, l, a) : ii } function si(t, e, n, i, r) { const s = t.providerIndexes, o = e.data, a = 65535 & s, l = t.directiveStart, c = s >> 16, h = r ? a + c : t.directiveEnd; for (let u = i ? a : a + c; u < h; u++) { const t = o[u]; if (u < l && n === t || u >= l && t.type === n) return u } if (r) { const t = o[l]; if (t && De(t) && t.type === n) return l } return null } function oi(t, e, n, i) { let r = t[n]; const s = e.data; if (r instanceof Rn) { const o = r; if (o.resolving) throw new Error(`Circular dep for ${$n(s[n])}`); const a = Xn(o.canSeeViewProviders); let l; o.resolving = !0, o.injectImpl && (l = Yt(o.injectImpl)), mn(t, i); try { r = t[n] = o.factory(void 0, s, t, i), e.firstCreatePass && n >= i.directiveStart && function (t, e, n) { const { onChanges: i, onInit: r, doCheck: s } = e; i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, i)), r && (n.preOrderHooks || (n.preOrderHooks = [])).push(-t, r), s && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s)) }(n, s[n], e) } finally { o.injectImpl && Yt(l), Xn(a), o.resolving = !1, bn() } } return r } function ai(t, e, n) { const i = 64 & t, r = 32 & t; let s; return s = 128 & t ? i ? r ? n[e + 7] : n[e + 6] : r ? n[e + 5] : n[e + 4] : i ? r ? n[e + 3] : n[e + 2] : r ? n[e + 1] : n[e], !!(s & 1 << t) } function li(t, e) { return !(t & ct.Self || t & ct.Host && e) } class ci { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return ni(this._tNode, this._lView, t, void 0, e) } } function hi(t) { return it(() => { const e = Object.getPrototypeOf(t.prototype).constructor, n = e[Vt] || function t(e) { const n = e; if (Ot(e)) return () => { const e = t(Et(n)); return e ? e() : null }; let i = Se(n); if (null === i) { const t = gt(n); i = t && t.factory } return i || null }(e); return null !== n ? n : t => new t }) } function ui(t) { return t.ngDebugContext } function di(t) { return t.ngOriginalError } function pi(t, ...e) { t.error(...e) } class fi { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), i = function (t) { return t.ngErrorLogger || pi }(t); i(this._console, "ERROR", t), e && i(this._console, "ORIGINAL ERROR", e), n && i(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? ui(t) ? ui(t) : this._findContext(di(t)) : null } _findOriginalError(t) { let e = di(t); for (; e && di(e);)e = di(e); return e } } class mi { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + " (see http://g.co/ng/security#xss)" } } class gi extends mi { getTypeName() { return "HTML" } } class yi extends mi { getTypeName() { return "Style" } } class _i extends mi { getTypeName() { return "Script" } } class vi extends mi { getTypeName() { return "URL" } } class bi extends mi { getTypeName() { return "ResourceURL" } } function wi(t) { return t instanceof mi ? t.changingThisBreaksApplicationSecurity : t } function xi(t, e) { const n = Ci(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see http://g.co/ng/security#xss)`) } return n === e } function Ci(t) { return t instanceof mi && t.getTypeName() || null } let Si = !0, ki = !1; function Ei() { return ki = !0, Si } class Oi { constructor(t) { this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"); let e = this.inertDocument.body; if (null == e) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t), e = this.inertDocument.createElement("body"), t.appendChild(e) } e.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', !e.querySelector || e.querySelector("svg") ? (e.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', this.getInertBodyElement = e.querySelector && e.querySelector("svg img") && function () { try { return !!window.DOMParser } catch (t) { return !1 } }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR } getInertBodyElement_XHR(t) { t = "<body><remove></remove>" + t + "</body>"; try { t = encodeURI(t) } catch (i) { return null } const e = new XMLHttpRequest; e.responseType = "document", e.open("GET", "data:text/html;charset=utf-8," + t, !1), e.send(void 0); const n = e.response.body; return n.removeChild(n.firstChild), n } getInertBodyElement_DOMParser(t) { t = "<body><remove></remove>" + t + "</body>"; try { const e = (new window.DOMParser).parseFromString(t, "text/html").body; return e.removeChild(e.firstChild), e } catch (e) { return null } } getInertBodyElement_InertDocument(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = t, e; const n = this.inertDocument.createElement("body"); return n.innerHTML = t, this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n } stripCustomNsAttrs(t) { const e = t.attributes; for (let i = e.length - 1; 0 < i; i--) { const n = e.item(i).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Ai = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, Ti = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Pi(t) { return (t = String(t)).match(Ai) || t.match(Ti) ? t : (Ei() && console.warn(`WARNING: sanitizing unsafe URL value ${t} (see http://g.co/ng/security#xss)`), "unsafe:" + t) } function Di(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function Ii(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const Ri = Di("area,br,col,hr,img,wbr"), Mi = Di("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Li = Di("rp,rt"), Fi = Ii(Li, Mi), Ni = Ii(Ri, Ii(Mi, Di("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Ii(Li, Di("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Fi), Vi = Di("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), ji = Di("srcset"), Bi = Ii(Vi, ji, Di("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Di("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), zi = Di("script,style,template"); class Hi { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Ni.hasOwnProperty(e)) return this.sanitizedSomething = !0, !zi.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let r = 0; r < n.length; r++) { const t = n.item(r), e = t.name, s = e.toLowerCase(); if (!Bi.hasOwnProperty(s)) { this.sanitizedSomething = !0; continue } let o = t.value; Vi[s] && (o = Pi(o)), ji[s] && (i = o, o = (i = String(i)).split(",").map(t => Pi(t.trim())).join(", ")), this.buf.push(" ", e, '="', qi(o), '"') } var i; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); Ni.hasOwnProperty(e) && !Ri.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(qi(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const Ui = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, $i = /([^\#-~ |!])/g; function qi(t) { return t.replace(/&/g, "&amp;").replace(Ui, (function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" })).replace($i, (function (t) { return "&#" + t.charCodeAt(0) + ";" })).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Wi; function Gi(t, e) { let n = null; try { Wi = Wi || new Oi(t); let i = e ? String(e) : ""; n = Wi.getInertBodyElement(i); let r = 5, s = i; do { if (0 === r) throw new Error("Failed to sanitize html because the input is unstable"); r--, i = s, s = n.innerHTML, n = Wi.getInertBodyElement(i) } while (i !== s); const o = new Hi, a = o.sanitizeChildren(Yi(n) || n); return Ei() && o.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), a } finally { if (n) { const t = Yi(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } } function Yi(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } const Xi = function () { var t = { NONE: 0, HTML: 1, STYLE: 2, SCRIPT: 3, URL: 4, RESOURCE_URL: 5 }; return t[t.NONE] = "NONE", t[t.HTML] = "HTML", t[t.STYLE] = "STYLE", t[t.SCRIPT] = "SCRIPT", t[t.URL] = "URL", t[t.RESOURCE_URL] = "RESOURCE_URL", t }(), Ki = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:attr|calc|var))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), Qi = /^url\(([^)]+)\)$/; function Zi(t) { const e = tr(); return e ? e.sanitize(Xi.HTML, t) || "" : xi(t, "HTML") ? wi(t) : Gi(Me(), Un(t)) } function Ji(t) { const e = tr(); return e ? e.sanitize(Xi.URL, t) || "" : xi(t, "URL") ? wi(t) : Pi(Un(t)) } function tr() { const t = Ke(); return t && t[12] } function er(t, e) { t.__ngContext__ = e } function nr(t) { throw new Error(`Multiple components match node with tagname ${t.tagName}`) } function ir() { throw new Error("Cannot mix multi providers and regular providers") } function rr(t, e, n) { let i = t.length; for (; ;) { const r = t.indexOf(e, n); if (-1 === r) return r; if (0 === r || t.charCodeAt(r - 1) <= 32) { const n = e.length; if (r + n === i || t.charCodeAt(r + n) <= 32) return r } n = r + 1 } } function sr(t, e, n) { let i = 0; for (; i < t.length;) { let r = t[i++]; if (n && "class" === r) { if (r = t[i], -1 !== rr(r.toLowerCase(), e, 0)) return !0 } else if (1 === r) { for (; i < t.length && "string" == typeof (r = t[i++]);)if (r.toLowerCase() === e) return !0; return !1 } } return !1 } function or(t) { return 0 === t.type && "ng-template" !== t.tagName } function ar(t, e, n) { return e === (0 !== t.type || n ? t.tagName : "ng-template") } function lr(t, e, n) { let i = 4; const r = t.attrs || [], s = function (t) { for (let e = 0; e < t.length; e++)if (Ln(t[e])) return e; return t.length }(r); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !ar(t, l, n) || "" === l && 1 === e.length) { if (cr(i)) return !1; o = !0 } } else { const c = 8 & i ? l : e[++a]; if (8 & i && null !== t.attrs) { if (!sr(t.attrs, c, n)) { if (cr(i)) return !1; o = !0 } continue } const h = hr(8 & i ? "class" : l, r, or(t), n); if (-1 === h) { if (cr(i)) return !1; o = !0; continue } if ("" !== c) { let t; t = h > s ? "" : r[h + 1].toLowerCase(); const e = 8 & i ? t : null; if (e && -1 !== rr(e, c, 0) || 2 & i && c !== t) { if (cr(i)) return !1; o = !0 } } } } else { if (!o && !cr(i) && !cr(l)) return !1; if (o && cr(l)) continue; o = !1, i = l | 1 & i } } return cr(i) || o } function cr(t) { return 0 == (1 & t) } function hr(t, e, n, i) { if (null === e) return -1; let r = 0; if (i || !n) { let n = !1; for (; r < e.length;) { const i = e[r]; if (i === t) return r; if (3 === i || 6 === i) n = !0; else { if (1 === i || 2 === i) { let t = e[++r]; for (; "string" == typeof t;)t = e[++r]; continue } if (4 === i) break; if (0 === i) { r += 4; continue } } r += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const i = t[n]; if ("number" == typeof i) return -1; if (i === e) return n; n++ } return -1 }(e, t) } function ur(t, e, n = !1) { for (let i = 0; i < e.length; i++)if (lr(t, e[i], n)) return !0; return !1 } function dr(t, e) { t: for (let n = 0; n < e.length; n++) { const i = e[n]; if (t.length === i.length) { for (let e = 0; e < t.length; e++)if (t[e] !== i[e]) continue t; return !0 } } return !1 } function pr(t, e) { return t ? ":not(" + e.trim() + ")" : e } function fr(t) { let e = t[0], n = 1, i = 2, r = "", s = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & i) { const e = t[++n]; r += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & i ? r += "." + o : 4 & i && (r += " " + o); else "" === r || cr(o) || (e += pr(s, r), r = ""), i = o, s = s || !cr(i); n++ } return "" !== r && (e += pr(s, r)), e } const mr = {}; function gr(t) { const e = t[3]; return Oe(e) ? e[3] : e } function yr(t) { _r(Qe(), Ke(), xn() + t, rn()) } function _r(t, e, n, i) { if (!i) if (3 == (3 & e[2])) { const i = t.preOrderCheckHooks; null !== i && An(e, i, n) } else { const i = t.preOrderHooks; null !== i && Tn(e, i, 0, n) } Cn(n) } function vr(t, e) { return t << 17 | e << 2 } function br(t) { return t >> 17 & 32767 } function wr(t) { return 2 | t } function xr(t) { return (131068 & t) >> 2 } function Cr(t, e) { return -131069 & t | e << 2 } function Sr(t) { return 1 | t } function kr(t, e) { const n = t.contentQueries; if (null !== n) for (let i = 0; i < n.length; i += 2) { const r = n[i], s = n[i + 1]; if (-1 !== s) { const n = t.data[s]; fn(r), n.contentQueries(2, e[s], s) } } } function Er(t, e, n) { return Le(e) ? e.createElement(t, n) : null === n ? e.createElement(t) : e.createElementNS(n, t) } function Or(t, e, n, i, r, s, o, a, l, c) { const h = e.blueprint.slice(); return h[0] = r, h[2] = 140 | i, Ge(h), h[3] = h[15] = t, h[8] = n, h[10] = o || t && t[10], h[11] = a || t && t[11], h[12] = l || t && t[12] || null, h[9] = c || t && t[9] || null, h[6] = s, h[16] = 2 == e.type ? t[16] : h, h } function Ar(t, e, n, i, r, s) { const o = n + 19, a = t.data[o] || function (t, e, n, i, r, s) { const o = Je(), a = en(), l = a ? o : o && o.parent, c = t.data[n] = Vr(0, l && l !== e ? l : null, i, n, r, s); return null === t.firstChild && (t.firstChild = c), o && (!a || null != o.child || null === c.parent && 2 !== o.type ? a || (o.next = c) : o.child = c), c }(t, e, o, i, r, s); return tn(a, !0), a } function Tr(t, e, n) { gn(e, e[6]); try { const i = t.viewQuery; null !== i && as(1, i, n); const r = t.template; null !== r && Ir(t, e, r, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && kr(t, e), t.staticViewQueries && as(2, t.viewQuery, n); const s = t.components; null !== s && function (t, e) { for (let n = 0; n < e.length; n++)ns(t, e[n]) }(e, s) } catch (i) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), i } finally { e[2] &= -5, wn() } } function Pr(t, e, n, i) { const r = e[2]; if (256 == (256 & r)) return; gn(e, e[6]); const s = rn(); try { Ge(e), Ye.lFrame.bindingIndex = t.bindingStartIndex, null !== n && Ir(t, e, n, 2, i); const o = 3 == (3 & r); if (!s) if (o) { const n = t.preOrderCheckHooks; null !== n && An(e, n, null) } else { const n = t.preOrderHooks; null !== n && Tn(e, n, 0, null), Pn(e, 0) } if (function (t) { let e = t[13]; for (; null !== e;) { let n; if (Oe(e) && (n = e[2]) >> 1 == -1) { for (let t = 9; t < e.length; t++) { const n = e[t], i = n[1]; qe(n) && Pr(i, n, i.template, n[8]) } 0 != (1 & n) && ts(e, t[16]) } e = e[4] } }(e), null !== t.contentQueries && kr(t, e), !s) if (o) { const n = t.contentCheckHooks; null !== n && An(e, n) } else { const n = t.contentHooks; null !== n && Tn(e, n, 1), Pn(e, 1) } !function (t, e) { try { const n = t.expandoInstructions; if (null !== n) { let i = t.expandoStartIndex, r = -1, s = -1; for (let t = 0; t < n.length; t++) { const o = n[t]; "number" == typeof o ? o <= 0 ? (s = 0 - o, Cn(s), i += 9 + n[++t], r = i) : i += o : (null !== o && (hn(i, r), o(2, e[r])), r++) } } } finally { Cn(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)es(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && as(2, l, i), !s) if (o) { const n = t.viewCheckHooks; null !== n && An(e, n) } else { const n = t.viewHooks; null !== n && Tn(e, n, 2), Pn(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), s || (e[2] &= -73) } finally { wn() } } function Dr(t, e, n, i) { const r = e[10], s = !rn(), o = $e(e); try { s && !o && r.begin && r.begin(), o && Tr(t, e, i), Pr(t, e, n, i) } finally { s && !o && r.end && r.end() } } function Ir(t, e, n, i, r) { const s = xn(); try { Cn(-1), 2 & i && e.length > 19 && _r(t, e, 0, rn()), n(i, r) } finally { Cn(s) } } function Rr(t, e, n) { if (Ae(e)) { const i = e.directiveEnd; for (let r = e.directiveStart; r < i; r++) { const e = t.data[r]; e.contentQueries && e.contentQueries(1, n[r], r) } } } function Mr(t, e, n) { Xe() && (function (t, e, n, i) { const r = n.directiveStart, s = n.directiveEnd; t.firstCreatePass || Qn(n, e), er(i, e); const o = n.initialInputs; for (let a = r; a < s; a++) { const i = t.data[a], s = De(i); s && Kr(e, n, i); const l = oi(e, t, a, n); er(l, e), null !== o && Qr(0, a - r, l, i, 0, o), s && (He(n.index, e)[8] = l) } }(t, e, n, je(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const i = n.directiveStart, r = n.directiveEnd, s = t.expandoInstructions, o = t.firstCreatePass, a = n.index - 19, l = Ye.lFrame.currentDirectiveIndex; try { Cn(a); for (let n = i; n < r; n++) { const i = t.data[n], r = e[n]; un(n), null !== i.hostBindings || 0 !== i.hostVars || null !== i.hostAttrs ? $r(i, r) : o && s.push(null) } } finally { Cn(-1), un(l) } }(t, e, n)) } function Lr(t, e, n = je) { const i = e.localNames; if (null !== i) { let r = e.index + 1; for (let s = 0; s < i.length; s += 2) { const o = i[s + 1], a = -1 === o ? n(e, t) : t[o]; t[r++] = a } } } function Fr(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Nr(1, -1, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Nr(t, e, n, i, r, s, o, a, l, c) { const h = 19 + i, u = h + r, d = function (t, e) { const n = []; for (let i = 0; i < e; i++)n.push(i < t ? null : mr); return n }(h, u); return d[1] = { type: t, id: e, blueprint: d, template: n, queries: null, viewQuery: a, node: null, data: d.slice().fill(null, h), bindingStartIndex: h, expandoStartIndex: u, expandoInstructions: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof s ? s() : s, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: c, incompleteFirstPass: !1 } } function Vr(t, e, n, i, r, s) { return { type: n, index: i, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, tagName: r, attrs: s, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, residualStyles: void 0, classes: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } } function jr(t, e, n) { for (let i in t) if (t.hasOwnProperty(i)) { const r = t[i]; (n = null === n ? {} : n).hasOwnProperty(i) ? n[i].push(e, r) : n[i] = [e, r] } return n } function Br(t, e, n, i, r, s, o, a) { const l = je(e, n); let c, h = e.inputs; var u; !a && null != h && (c = h[i]) ? (ps(t, n, c, i, r), Te(e) && function (t, e) { const n = He(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 === e.type && (i = "class" === (u = i) ? "className" : "for" === u ? "htmlFor" : "formaction" === u ? "formAction" : "innerHtml" === u ? "innerHTML" : "readonly" === u ? "readOnly" : "tabindex" === u ? "tabIndex" : u, r = null != o ? o(r, e.tagName || "", i) : r, Le(s) ? s.setProperty(l, i, r) : Fn(i) || (l.setProperty ? l.setProperty(i, r) : l[i] = r)) } function zr(t, e, n, i) { let r = !1; if (Xe()) { const s = function (t, e, n) { const i = t.directiveRegistry; let r = null; if (i) for (let s = 0; s < i.length; s++) { const o = i[s]; ur(n, o.selectors, !1) && (r || (r = []), ei(Qn(n, e), t, o.type), De(o) ? (2 & n.flags && nr(n), Wr(t, n), r.unshift(o)) : r.push(o)) } return r }(t, e, n), o = null === i ? null : { "": -1 }; if (null !== s) { let i = 0; r = !0, Yr(n, t.data.length, s.length); for (let t = 0; t < s.length; t++) { const e = s[t]; e.providersResolver && e.providersResolver(e) } qr(t, n, s.length); let a = !1, l = !1; for (let r = 0; r < s.length; r++) { const c = s[r]; n.mergedAttrs = Nn(n.mergedAttrs, c.hostAttrs), Xr(t, e, c), Gr(t.data.length - 1, c, o), null !== c.contentQueries && (n.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (n.flags |= 128), !a && (c.onChanges || c.onInit || c.doCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index - 19), a = !0), l || !c.onChanges && !c.doCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index - 19), l = !0), Hr(t, c), i += c.hostVars } !function (t, e) { const n = e.directiveEnd, i = t.data, r = e.attrs, s = []; let o = null, a = null; for (let l = e.directiveStart; l < n; l++) { const t = i[l], n = t.inputs, c = null === r || or(e) ? null : Zr(n, r); s.push(c), o = jr(n, l, o), a = jr(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = s, e.inputs = o, e.outputs = a }(t, n), Ur(t, e, i) } o && function (t, e, n) { if (e) { const i = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const r = n[e[t + 1]]; if (null == r) throw new Error(`Export of name '${e[t + 1]}' not found!`); i.push(e[t], r) } } }(n, i, o) } return n.mergedAttrs = Nn(n.mergedAttrs, n.attrs), r } function Hr(t, e) { const n = t.expandoInstructions; n.push(e.hostBindings), 0 !== e.hostVars && n.push(e.hostVars) } function Ur(t, e, n) { for (let i = 0; i < n; i++)e.push(mr), t.blueprint.push(mr), t.data.push(null) } function $r(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function qr(t, e, n) { const i = 19 - e.index, r = t.data.length - (65535 & e.providerIndexes); (t.expandoInstructions || (t.expandoInstructions = [])).push(i, r, n) } function Wr(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Gr(t, e, n) { if (n) { if (e.exportAs) for (let i = 0; i < e.exportAs.length; i++)n[e.exportAs[i]] = t; De(e) && (n[""] = t) } } function Yr(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function Xr(t, e, n) { t.data.push(n); const i = n.factory || (n.factory = Se(n.type)), r = new Rn(i, De(n), null); t.blueprint.push(r), e.push(r) } function Kr(t, e, n) { const i = je(e, t), r = Fr(n), s = t[10], o = is(t, Or(t, r, null, n.onPush ? 64 : 16, i, e, s, s.createRenderer(i, n))); t[e.index] = o } function Qr(t, e, n, i, r, s) { const o = s[e]; if (null !== o) { const t = i.setInput; for (let e = 0; e < o.length;) { const r = o[e++], s = o[e++], a = o[e++]; null !== t ? i.setInput(n, a, r, s) : n[s] = a } } } function Zr(t, e) { let n = null, i = 0; for (; i < e.length;) { const r = e[i]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; t.hasOwnProperty(r) && (null === n && (n = []), n.push(r, t[r], e[i + 1])), i += 2 } else i += 2; else i += 4 } return n } function Jr(t, e, n, i) { return new Array(t, !0, -2, e, null, null, i, n, null) } function ts(t, e) { const n = t[5]; for (let i = 0; i < n.length; i++) { const t = n[i], r = t[3][3][16]; if (r !== e && 0 == (16 & r[2])) { const e = t[1]; Pr(e, t, e.template, t[8]) } } } function es(t, e) { const n = He(e, t); if (qe(n) && 80 & n[2]) { const t = n[1]; Pr(t, n, t.template, n[8]) } } function ns(t, e) { const n = He(e, t), i = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(i, n), Tr(i, n, n[8]) } function is(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function rs(t) { for (; t;) { t[2] |= 64; const e = gr(t); if (Ie(t) && !e) return t; t = e } return null } function ss(t, e, n) { const i = e[10]; i.begin && i.begin(); try { Pr(t, e, t.template, n) } catch (r) { throw ds(e, r), r } finally { i.end && i.end() } } function os(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], i = Ue(n), r = i[1]; Dr(r, i, r.template, n) } }(t[8]) } function as(t, e, n) { fn(0), e(t, n) } const ls = (() => Promise.resolve(null))(); function cs(t) { return t[7] || (t[7] = []) } function hs(t) { return t.cleanup || (t.cleanup = []) } function us(t, e, n) { return (null === t || De(t)) && (n = function (t) { for (; Array.isArray(t);) { if ("object" == typeof t[1]) return t; t = t[0] } return null }(n[e.index])), n[11] } function ds(t, e) { const n = t[9], i = n ? n.get(fi, null) : null; i && i.handleError(e) } function ps(t, e, n, i, r) { for (let s = 0; s < n.length;) { const o = n[s++], a = n[s++], l = e[o], c = t.data[o]; null !== c.setInput ? c.setInput(l, r, i, a) : l[a] = r } } function fs(t, e, n) { const i = Ve(e, t), r = t[11]; Le(r) ? r.setValue(i, n) : i.textContent = n } function ms(t, e) { const n = e[3]; return -1 === t.index ? Oe(n) ? n : null : n } function gs(t, e) { const n = ms(t, e); return n ? As(e[11], n[7]) : null } function ys(t, e, n, i, r) { if (null != i) { let s, o = !1; Oe(i) ? s = i : Ee(i) && (o = !0, i = i[0]); const a = Ne(i); 0 === t && null !== n ? null == r ? Es(e, n, a) : ks(e, n, a, r || null) : 1 === t && null !== n ? ks(e, n, a, r || null) : 2 === t ? function (t, e, n) { const i = As(t, e); i && function (t, e, n, i) { Le(t) ? t.removeChild(e, n, i) : e.removeChild(n) }(t, i, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != s && function (t, e, n, i, r) { const s = n[7]; s !== Ne(n) && ys(e, t, i, s, r); for (let o = 9; o < n.length; o++) { const r = n[o]; Rs(r[1], r, t, e, i, s) } }(e, t, s, n, r) } } function _s(t, e, n, i) { const r = gs(t.node, e); r && Rs(t, e, e[11], n ? 1 : 2, r, i) } function vs(t, e) { const n = t[5], i = n.indexOf(e); n.splice(i, 1) } function bs(t, e) { if (t.length <= 9) return; const n = 9 + e, i = t[n]; if (i) { const r = i[17]; null !== r && r !== t && vs(r, i), e > 0 && (t[n - 1][4] = i[4]); const s = se(t, 9 + e); _s(i[1], i, !1, null); const o = s[5]; null !== o && o.detachView(s[1]), i[3] = null, i[4] = null, i[2] &= -129 } return i } function ws(t, e) { if (!(256 & e[2])) { const n = e[11]; Le(n) && n.destroyNode && Rs(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return Cs(t[1], t); for (; e;) { let n = null; if (Ee(e)) n = e[13]; else { const t = e[9]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)Ee(e) && Cs(e[1], e), e = xs(e, t); null === e && (e = t), Ee(e) && Cs(e[1], e), n = e && e[4] } e = n } }(e) } } function xs(t, e) { let n; return Ee(t) && (n = t[6]) && 2 === n.type ? ms(n, t) : t[3] === e ? null : t[3] } function Cs(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let i = 0; i < n.length; i += 2) { const t = e[n[i]]; if (!(t instanceof Rn)) { const e = n[i + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2)e[n + 1].call(t[e[n]]); else e.call(t) } } }(t, e), function (t, e) { const n = t.cleanup; if (null !== n) { const t = e[7]; for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const r = n[i + 1], s = "function" == typeof r ? r(e) : Ne(e[r]), o = t[n[i + 2]], a = n[i + 3]; "boolean" == typeof a ? s.removeEventListener(n[i], o, a) : a >= 0 ? t[a]() : t[-a].unsubscribe(), i += 2 } else n[i].call(t[n[i + 1]]); e[7] = null } }(t, e); const n = e[6]; n && 3 === n.type && Le(e[11]) && e[11].destroy(); const i = e[17]; if (null !== i && Oe(e[3])) { i !== e[3] && vs(i, e); const n = e[5]; null !== n && n.detachView(t) } } } function Ss(t, e, n) { let i = e.parent; for (; null != i && (4 === i.type || 5 === i.type);)i = (e = i).parent; if (null == i) { const t = n[6]; return 2 === t.type ? gs(t, n) : n[0] } if (e && 5 === e.type && 4 & e.flags) return je(e, n).parentNode; if (2 & i.flags) { const e = t.data, n = e[e[i.index].directiveStart].encapsulation; if (n !== ue.ShadowDom && n !== ue.Native) return null } return je(i, n) } function ks(t, e, n, i) { Le(t) ? t.insertBefore(e, n, i) : e.insertBefore(n, i, !0) } function Es(t, e, n) { Le(t) ? t.appendChild(e, n) : e.appendChild(n) } function Os(t, e, n, i) { null !== i ? ks(t, e, n, i) : Es(t, e, n) } function As(t, e) { return Le(t) ? t.parentNode(e) : e.parentNode } function Ts(t, e) { if (2 === t.type) { const n = ms(t, e); return null === n ? null : Ds(n.indexOf(e, 9) - 9, n) } return 4 === t.type || 5 === t.type ? je(t, e) : null } function Ps(t, e, n, i) { const r = Ss(t, i, e); if (null != r) { const t = e[11], s = Ts(i.parent || e[6], e); if (Array.isArray(n)) for (let e = 0; e < n.length; e++)Os(t, r, n[e], s); else Os(t, r, n, s) } } function Ds(t, e) { const n = 9 + t + 1; if (n < e.length) { const t = e[n], i = t[1].firstChild; if (null !== i) return function t(e, n) { if (null !== n) { const i = n.type; if (3 === i) return je(n, e); if (0 === i) return Ds(-1, e[n.index]); if (4 === i || 5 === i) { const i = n.child; if (null !== i) return t(e, i); { const t = e[n.index]; return Oe(t) ? Ds(-1, t) : Ne(t) } } { const i = e[16], r = i[6], s = gr(i), o = r.projection[n.projection]; return null != o ? t(s, o) : t(e, n.next) } } return null }(t, i) } return e[7] } function Is(t, e, n, i, r, s, o) { for (; null != n;) { const a = i[n.index], l = n.type; o && 0 === e && (a && er(Ne(a), i), n.flags |= 4), 64 != (64 & n.flags) && (4 === l || 5 === l ? (Is(t, e, n.child, i, r, s, !1), ys(e, t, r, a, s)) : 1 === l ? Ms(t, e, i, n, r, s) : ys(e, t, r, a, s)), n = o ? n.projectionNext : n.next } } function Rs(t, e, n, i, r, s) { Is(n, i, t.node.child, e, r, s, !1) } function Ms(t, e, n, i, r, s) { const o = n[16], a = o[6].projection[i.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)ys(e, t, r, a[l], s); else Is(t, e, a, o[3], r, s, !0) } function Ls(t, e, n) { Le(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Fs(t, e, n) { Le(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } class Ns { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._viewContainerRef = null, this._tViewNode = null } get rootNodes() { const t = this._lView; return null == t[0] ? function t(e, n, i, r, s = !1) { for (; null !== i;) { const o = n[i.index]; if (null !== o && r.push(Ne(o)), Oe(o)) for (let e = 9; e < o.length; e++) { const n = o[e], i = n[1].firstChild; null !== i && t(n[1], n, i, r) } const a = i.type; if (4 === a || 5 === a) t(e, n, i.child, r); else if (1 === a) { const e = n[16], s = e[6], o = gr(e); let a = s.projection[i.projection]; null !== a && null !== o && t(o[1], o, a, r, !0) } i = s ? i.projectionNext : i.next } return r }(t[1], t, t[6].child, []) : [] } get context() { return this._lView[8] } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._viewContainerRef) { const t = this._viewContainerRef.indexOf(this); t > -1 && this._viewContainerRef.detach(t), this._viewContainerRef = null } ws(this._lView[1], this._lView) } onDestroy(t) { var e, n, i; e = this._lView[1], i = t, cs(n = this._lView).push(i), e.firstCreatePass && hs(e).push(n[7].length - 1, null) } markForCheck() { rs(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { ss(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { sn(!0); try { ss(t, e, n) } finally { sn(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef(t) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._viewContainerRef = t } detachFromAppRef() { var t; this._appRef = null, Rs(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class Vs extends Ns { constructor(t) { super(t), this._view = t } detectChanges() { os(this._view) } checkNoChanges() { !function (t) { sn(!0); try { os(t) } finally { sn(!1) } }(this._view) } get context() { return null } } let js, Bs, zs; function Hs(t, e, n) { return js || (js = class extends t { }), new js(je(e, n)) } function Us(t, e, n, i) { return Bs || (Bs = class extends t { constructor(t, e, n) { super(), this._declarationView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = Or(this._declarationView, e, t, 16, null, e.node); n[17] = this._declarationView[this._declarationTContainer.index]; const i = this._declarationView[5]; null !== i && (n[5] = i.createEmbeddedView(e)), Tr(e, n, t); const r = new Ns(n); return r._tViewNode = n[6], r } }), 0 === n.type ? new Bs(i, n, Hs(e, n, i)) : null } function $s(t, e, n, i) { let r; zs || (zs = class extends t { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostView = n } get element() { return Hs(e, this._hostTNode, this._hostView) } get injector() { return new ci(this._hostTNode, this._hostView) } get parentInjector() { const t = ti(this._hostTNode, this._hostView), e = Hn(t, this._hostView), n = function (t, e, n) { if (n.parent && -1 !== n.parent.injectorIndex) { const t = n.parent.injectorIndex; let e = n.parent; for (; null != e.parent && t == e.parent.injectorIndex;)e = e.parent; return e } let i = zn(t), r = e, s = e[6]; for (; i > 1;)r = r[15], s = r[6], i--; return s }(t, this._hostView, this._hostTNode); return jn(t) && null != n ? new ci(n, e) : new ci(null, this._hostView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { return null !== this._lContainer[8] && this._lContainer[8][t] || null } get length() { return this._lContainer.length - 9 } createEmbeddedView(t, e, n) { const i = t.createEmbeddedView(e || {}); return this.insert(i, n), i } createComponent(t, e, n, i, r) { const s = n || this.parentInjector; if (!r && null == t.ngModule && s) { const t = s.get(ee, null); t && (r = t) } const o = t.create(s, i, void 0, r); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, i = n[1]; if (t.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); if (this.allocateContainerIfNeeded(), Oe(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], i = new zs(e, e[6], e[3]); i.detach(i.indexOf(t)) } } const r = this._adjustIndex(e); return function (t, e, n, i) { const r = 9 + i, s = n.length; i > 0 && (n[r - 1][4] = e), i < s - 9 ? (e[4] = n[r], re(n, 9 + i, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[5], i = e[3][3][16]; 16 != (16 & i[2]) && e[16] !== i && (t[2] |= 1), null === n ? t[5] = [e] : n.push(e) }(o, e); const a = e[5]; null !== a && a.insertView(t), e[2] |= 128 }(i, n, this._lContainer, r), _s(i, n, !0, Ds(r, this._lContainer)), t.attachToViewContainerRef(this), re(this._lContainer[8], r, t), t } move(t, e) { if (t.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); return this.insert(t, e) } indexOf(t) { const e = this._lContainer[8]; return null !== e ? e.indexOf(t) : -1 } remove(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1); (function (t, e) { const n = bs(t, e); n && ws(n[1], n) })(this._lContainer, e), se(this._lContainer[8], e) } detach(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1), n = bs(this._lContainer, e); return n && null != se(this._lContainer[8], e) ? new Ns(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } allocateContainerIfNeeded() { null === this._lContainer[8] && (this._lContainer[8] = []) } }); const s = i[n.index]; if (Oe(s)) r = s, function (t, e) { t[2] = -2 }(r); else { let t; if (4 === n.type) t = Ne(s); else if (t = i[11].createComment(""), Ie(i)) { const e = i[11], r = je(n, i); ks(e, As(e, r), t, function (t, e) { return Le(t) ? t.nextSibling(e) : e.nextSibling }(e, r)) } else Ps(i[1], i, t, n); i[n.index] = r = Jr(s, i, t, n), is(i, r) } return new zs(r, n, i) } function qs(t = !1) { return function (t, e, n) { if (!n && Te(t)) { const n = He(t.index, e); return new Ns(n, n) } return 3 === t.type || 0 === t.type || 4 === t.type || 5 === t.type ? new Ns(e[16], e) : null }(Je(), Ke(), t) } let Ws = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Gs(), t })(); const Gs = qs, Ys = new Bt("Set Injector scope."), Xs = {}, Ks = {}, Qs = []; let Zs = void 0; function Js() { return void 0 === Zs && (Zs = new te), Zs } function to(t, e = null, n = null, i) { return new eo(t, n, e || Js(), i) } class eo { constructor(t, e, n, i = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const r = []; e && ie(e, n => this.processProvider(n, t, e)), ie([t], t => this.processInjectorType(t, [], r)), this.records.set(zt, ro(void 0, this)); const s = this.records.get(Ys); this.scope = null != s ? s.value : null, this.source = i || ("object" == typeof t ? null : xt(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = Ht, n = ct.Default) { this.assertNotDestroyed(); const i = Gt(this); try { if (!(n & ct.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (r = t) || "object" == typeof r && r instanceof Bt) && ft(t); e = n && this.injectableDefInScope(n) ? ro(no(t), Xs) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & ct.Self ? Js() : this.parent).get(t, e = n & ct.Optional && e === Ht ? null : e) } catch (s) { if ("NullInjectorError" === s.name) { if ((s.ngTempTokenPath = s.ngTempTokenPath || []).unshift(xt(t)), i) throw s; return function (t, e, n, i) { const r = t.ngTempTokenPath; throw e.__source && r.unshift(e.__source), t.message = function (t, e, n, i = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let r = xt(e); if (Array.isArray(e)) r = e.map(xt).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n]; t.push(n + ":" + ("string" == typeof i ? JSON.stringify(i) : xt(i))) } r = `{${t.join(", ")}}` } return `${n}${i ? "(" + i + ")" : ""}[${r}]: ${t.replace(Ut, "\n  ")}` }("\n" + t.message, r, n, i), t.ngTokenPath = r, t.ngTempTokenPath = null, t }(s, t, "R3InjectorError", this.source) } throw s } finally { Gt(i) } var r } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(xt(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = Et(t))) return !1; let i = gt(t); const r = null == i && t.ngModule || void 0, s = void 0 === r ? t : r, o = -1 !== n.indexOf(s); if (void 0 !== r && (i = gt(r)), null == i) return !1; if (null != i.imports && !o) { let t; n.push(s); try { ie(i.imports, i => { this.processInjectorType(i, e, n) && (void 0 === t && (t = []), t.push(i)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: i } = t[e]; ie(i, t => this.processProvider(t, n, i || Qs)) } } this.injectorDefTypes.add(s), this.records.set(s, ro(i.factory, Xs)); const a = i.providers; if (null != a && !o) { const e = t; ie(a, t => this.processProvider(t, e, a)) } return void 0 !== r && void 0 !== t.providers } processProvider(t, e, n) { let i = oo(t = Et(t)) ? t : Et(t && t.provide); const r = function (t, e, n) { return so(t) ? ro(void 0, t.useValue) : ro(io(t, e, n), Xs) }(t, e, n); if (oo(t) || !0 !== t.multi) { const t = this.records.get(i); t && void 0 !== t.multi && ir() } else { let e = this.records.get(i); e ? void 0 === e.multi && ir() : (e = ro(void 0, Xs, !0), e.factory = () => Jt(e.multi), this.records.set(i, e)), i = t, e.multi.push(t) } this.records.set(i, r) } hydrate(t, e) { var n; return e.value === Ks ? function (t) { throw new Error(`Cannot instantiate cyclic dependency! ${t}`) }(xt(t)) : e.value === Xs && (e.value = Ks, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { return !!t.providedIn && ("string" == typeof t.providedIn ? "any" === t.providedIn || t.providedIn === this.scope : this.injectorDefTypes.has(t.providedIn)) } } function no(t) { const e = ft(t), n = null !== e ? e.factory : Se(t); if (null !== n) return n; const i = gt(t); if (null !== i) return i.factory; if (t instanceof Bt) throw new Error(`Token ${xt(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = oe(e, "?"); throw new Error(`Can't resolve all parameters for ${xt(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[yt] || t[bt] || t[vt] && t[vt]()); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in v10. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function io(t, e, n) { let i = void 0; if (oo(t)) { const e = Et(t); return Se(e) || no(e) } if (so(t)) i = () => Et(t.useValue); else if ((r = t) && r.useFactory) i = () => t.useFactory(...Jt(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) i = () => Kt(Et(t.useExisting)); else { const r = Et(t && (t.useClass || t.provide)); if (r || function (t, e, n) { let i = ""; throw t && e && (i = ` - only instances of Provider and Type are allowed, got: [${e.map(t => t == n ? "?" + n + "?" : "...").join(", ")}]`), new Error(`Invalid provider for the NgModule '${xt(t)}'` + i) }(e, n, t), !function (t) { return !!t.deps }(t)) return Se(r) || no(r); i = () => new r(...Jt(t.deps)) } var r; return i } function ro(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function so(t) { return null !== t && "object" == typeof t && $t in t } function oo(t) { return "function" == typeof t } const ao = function (t, e, n) { return function (t, e = null, n = null, i) { const r = to(t, e, n, i); return r._resolveInjectorDefTypes(), r }({ name: n }, e, t, n) }; let lo = (() => { class t { static create(t, e) { return Array.isArray(t) ? ao(t, e, "") : ao(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = Ht, t.NULL = new te, t.\u0275prov = dt({ token: t, providedIn: "any", factory: () => Kt(zt) }), t.__NG_ELEMENT_ID__ = -1, t })(); const co = new Bt("AnalyzeForEntryComponents"); let ho = new Map; const uo = new Set; function po(t) { return "string" == typeof t ? t : t.text() } function fo(t, e) { let n = t.styles, i = t.classes, r = 0; for (let s = 0; s < e.length; s++) { const t = e[s]; "number" == typeof t ? r = t : 1 == r ? i = Ct(i, t) : 2 == r && (n = Ct(n, t + ": " + e[++s] + ";")) } null !== n && (t.styles = n), null !== i && (t.classes = i) } let mo = null; function go() { if (!mo) { const t = It.Symbol; if (t && t.iterator) mo = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (mo = n) } } } return mo } function yo(t, e) { return t === e || "number" == typeof t && "number" == typeof e && isNaN(t) && isNaN(e) } class _o { constructor(t) { this.wrapped = t } static wrap(t) { return new _o(t) } static unwrap(t) { return _o.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof _o } } function vo(t) { return !!bo(t) && (Array.isArray(t) || !(t instanceof Map) && go() in t) } function bo(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function wo(t, e, n) { return t[e] = n } function xo(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function Co(t, e, n, i) { const r = xo(t, e, n); return xo(t, e + 1, i) || r } function So(t, e, n, i) { const r = Ke(); return xo(r, ln(), e) && (Qe(), function (t, e, n, i, r, s) { const o = je(t, e), a = e[11]; if (null == i) Le(a) ? a.removeAttribute(o, n, s) : o.removeAttribute(n); else { const e = null == r ? Un(i) : r(i, t.tagName || "", n); Le(a) ? a.setAttribute(o, n, e, s) : s ? o.setAttributeNS(s, n, e) : o.setAttribute(n, e) } }(Sn(), r, t, e, n, i)), So } function ko(t, e, n, i) { return xo(t, ln(), n) ? e + Un(n) + i : mr } function Eo(t, e, n, i, r, s, o, a) { const l = Ke(), c = Qe(), h = t + 19, u = c.firstCreatePass ? function (t, e, n, i, r, s, o, a, l) { const c = e.consts, h = Ar(e, n[6], t, 0, o || null, We(c, a)); zr(e, n, h, We(c, l)), On(e, h); const u = h.tViews = Nr(2, -1, i, r, s, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c), d = Vr(0, null, 2, -1, null, null); return d.injectorIndex = h.injectorIndex, u.node = d, null !== e.queries && (e.queries.template(e, h), u.queries = e.queries.embeddedTView(h)), h }(t, c, l, e, n, i, r, s, o) : c.data[h]; tn(u, !1); const d = l[11].createComment(""); Ps(c, l, d, u), er(d, l), is(l, l[h] = Jr(d, l, d, u)), Pe(u) && Mr(c, l, u), null != o && Lr(l, u, a) } function Oo(t) { return ze(Ye.lFrame.contextLView, t) } function Ao(t, e = ct.Default) { const n = Ke(); return null == n ? Kt(t, e) : ni(Je(), n, Et(t), e) } function To(t) { return function (t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const t = n.length; let i = 0; for (; i < t;) { const r = n[i]; if (Ln(r)) break; if (0 === r) i += 2; else if ("number" == typeof r) for (i++; i < t && "string" == typeof n[i];)i++; else { if (r === e) return n[i + 1]; i += 2 } } } return null }(Je(), t) } function Po() { throw new Error("invalid") } function Do(t, e, n) { const i = Ke(); return xo(i, ln(), e) && Br(Qe(), Sn(), i, t, e, i[11], n, !1), Do } function Io(t, e, n, i, r) { const s = r ? "class" : "style"; ps(t, n, e.inputs[s], s, i) } function Ro(t, e, n, i) { const r = Ke(), s = Qe(), o = 19 + t, a = r[11], l = r[o] = Er(e, a, Ye.lFrame.currentNamespace), c = s.firstCreatePass ? function (t, e, n, i, r, s, o) { const a = e.consts, l = We(a, s), c = Ar(e, n[6], t, 3, r, l); return zr(e, n, c, We(a, o)), null !== c.mergedAttrs && fo(c, c.mergedAttrs), null !== e.queries && e.queries.elementStart(e, c), c }(t, s, r, 0, e, n, i) : s.data[o]; tn(c, !0); const h = c.mergedAttrs; null !== h && Mn(a, l, h); const u = c.classes; null !== u && Fs(a, l, u); const d = c.styles; null !== d && Ls(a, l, d), Ps(s, r, l, c), 0 === Ye.lFrame.elementDepthCount && er(l, r), Ye.lFrame.elementDepthCount++, Pe(c) && (Mr(s, r, c), Rr(s, c, r)), null !== i && Lr(r, c) } function Mo() { let t = Je(); en() ? nn() : (t = t.parent, tn(t, !1)); const e = t; Ye.lFrame.elementDepthCount--; const n = Qe(); n.firstCreatePass && (On(n, t), Ae(t) && n.queries.elementEnd(t)), null !== e.classes && function (t) { return 0 != (16 & t.flags) }(e) && Io(n, e, Ke(), e.classes, !0), null !== e.styles && function (t) { return 0 != (32 & t.flags) }(e) && Io(n, e, Ke(), e.styles, !1) } function Lo(t, e, n, i) { Ro(t, e, n, i), Mo() } function Fo(t, e, n) { const i = Ke(), r = Qe(), s = t + 19, o = r.firstCreatePass ? function (t, e, n, i, r) { const s = e.consts, o = We(s, i), a = Ar(e, n[6], t, 4, "ng-container", o); return null !== o && fo(a, o), zr(e, n, a, We(s, r)), null !== e.queries && e.queries.elementStart(e, a), a }(t, r, i, e, n) : r.data[s]; tn(o, !0); const a = i[s] = i[11].createComment(""); Ps(r, i, a, o), er(a, i), Pe(o) && (Mr(r, i, o), Rr(r, o, i)), null != n && Lr(i, o) } function No() { let t = Je(); const e = Qe(); en() ? nn() : (t = t.parent, tn(t, !1)), e.firstCreatePass && (On(e, t), Ae(t) && e.queries.elementEnd(t)) } function Vo(t, e, n) { Fo(t, e, n), No() } function jo() { return Ke() } function Bo(t) { return !!t && "function" == typeof t.then } function zo(t) { return !!t && "function" == typeof t.subscribe } function Ho(t, e, n = !1, i) { const r = Ke(), s = Qe(), o = Je(); return $o(s, r, r[11], o, t, e, n, i), Ho } function Uo(t, e, n = !1, i) { const r = Je(), s = Ke(), o = Qe(); return $o(o, s, us(dn(o.data), r, s), r, t, e, n, i), Uo } function $o(t, e, n, i, r, s, o = !1, a) { const l = Pe(i), c = t.firstCreatePass && (t.cleanup || (t.cleanup = [])), h = cs(e); let u = !0; if (3 === i.type) { const d = je(i, e), p = a ? a(d) : de, f = p.target || d, m = h.length, g = a ? t => a(Ne(t[i.index])).target : i.index; if (Le(n)) { let o = null; if (!a && l && (o = function (t, e, n, i) { const r = t.cleanup; if (null != r) for (let s = 0; s < r.length - 1; s += 2) { const t = r[s]; if (t === n && r[s + 1] === i) { const t = e[7], n = r[s + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (s += 2) } return null }(t, e, r, i.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = s, o.__ngLastListenerFn__ = s, u = !1; else { s = Wo(i, e, s, !1); const t = n.listen(p.name || f, r, s); h.push(s, t), c && c.push(r, g, m, m + 1) } } else s = Wo(i, e, s, !0), f.addEventListener(r, s, o), h.push(s), c && c.push(r, g, m, o) } const d = i.outputs; let p; if (u && null !== d && (p = d[r])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(s), o = h.length; h.push(s, t), c && c.push(r, i.index, o, -(o + 1)) } } } function qo(t, e, n) { try { return !1 !== e(n) } catch (i) { return ds(t, i), !1 } } function Wo(t, e, n, i) { return function r(s) { if (s === Function) return n; const o = 2 & t.flags ? He(t.index, e) : e; 0 == (32 & e[2]) && rs(o); let a = qo(e, n, s), l = r.__ngNextListenerFn__; for (; l;)a = qo(e, l, s) && a, l = l.__ngNextListenerFn__; return i && !1 === a && (s.preventDefault(), s.returnValue = !1), a } } function Go(t = 1) { return function (t) { return (Ye.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Ye.lFrame.contextLView))[8] }(t) } function Yo(t, e) { let n = null; const i = function (t) { const e = t.attrs; if (null != e) { const t = e.indexOf(5); if (0 == (1 & t)) return e[t + 1] } return null }(t); for (let r = 0; r < e.length; r++) { const s = e[r]; if ("*" !== s) { if (null === i ? ur(t, s, !0) : dr(i, s)) return r } else n = r } return n } function Xo(t) { const e = Ke()[16][6]; if (!e.projection) { const n = e.projection = oe(t ? t.length : 1, null), i = n.slice(); let r = e.child; for (; null !== r;) { const e = t ? Yo(r, t) : 0; null !== e && (i[e] ? i[e].projectionNext = r : n[e] = r, i[e] = r), r = r.next } } } function Ko(t, e = 0, n) { const i = Ke(), r = Qe(), s = Ar(r, i[6], t, 1, null, n || null); null === s.projection && (s.projection = e), nn(), function (t, e, n) { Ms(e[11], 0, e, n, Ss(t, n, e), Ts(n.parent || e[6], e)) }(r, i, s) } const Qo = []; function Zo(t, e, n, i, r) { const s = t[n + 1], o = null === e; let a = i ? br(s) : xr(s), l = !1; for (; 0 !== a && (!1 === l || o);) { const n = t[a + 1]; Jo(t[a], e) && (l = !0, t[a + 1] = i ? Sr(n) : wr(n)), a = i ? br(n) : xr(n) } l && (t[n + 1] = i ? wr(s) : Sr(s)) } function Jo(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && ce(t, e) >= 0 } const ta = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function ea(t) { return t.substring(ta.key, ta.keyEnd) } function na(t, e) { const n = ta.textEnd; return n === e ? -1 : (e = ta.keyEnd = function (t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e }(t, ta.key = e, n), ia(t, e, n)) } function ia(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function ra(t, e, n) { return aa(t, e, n, !1), ra } function sa(t, e) { return aa(t, e, null, !0), sa } function oa(t, e) { for (let n = function (t) { return function (t) { ta.key = 0, ta.keyEnd = 0, ta.value = 0, ta.valueEnd = 0, ta.textEnd = t.length }(t), na(t, ia(t, 0, ta.textEnd)) }(e); n >= 0; n = na(e, n))ae(t, ea(e), !0) } function aa(t, e, n, i) { const r = Ke(), s = Qe(), o = cn(2); if (s.firstUpdatePass && ca(s, t, o, i), e !== mr && xo(r, o, e)) { let a; null == n && (a = function () { const t = Ye.lFrame; return null === t ? null : t.currentSanitizer }()) && (n = a), da(s, s.data[xn() + 19], r, r[11], t, r[o + 1] = function (t, e) { return null == t || ("function" == typeof e ? t = e(t) : "string" == typeof e ? t += e : "object" == typeof t && (t = xt(wi(t)))), t }(e, n), i, o) } } function la(t, e) { return e >= t.expandoStartIndex } function ca(t, e, n, i) { const r = t.data; if (null === r[n + 1]) { const s = r[xn() + 19], o = la(t, n); ma(s, i) && null === e && !o && (e = !1), e = function (t, e, n, i) { const r = dn(t); let s = i ? e.residualClasses : e.residualStyles; if (null === r) 0 === (i ? e.classBindings : e.styleBindings) && (n = ua(n = ha(null, t, e, n, i), e.attrs, i), s = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== r) if (n = ha(r, t, e, n, i), null === s) { let n = function (t, e, n) { const i = n ? e.classBindings : e.styleBindings; if (0 !== xr(i)) return t[br(i)] }(t, e, i); void 0 !== n && Array.isArray(n) && (n = ha(null, t, e, n[1], i), n = ua(n, e.attrs, i), function (t, e, n, i) { t[br(n ? e.classBindings : e.styleBindings)] = i }(t, e, i, n)) } else s = function (t, e, n) { let i = void 0; const r = e.directiveEnd; for (let s = 1 + e.directiveStylingLast; s < r; s++)i = ua(i, t[s].hostAttrs, n); return ua(i, e.attrs, n) }(t, e, i) } return void 0 !== s && (i ? e.residualClasses = s : e.residualStyles = s), n }(r, s, e, i), function (t, e, n, i, r, s) { let o = s ? e.classBindings : e.styleBindings, a = br(o), l = xr(o); t[i] = n; let c, h = !1; if (Array.isArray(n)) { const t = n; c = t[1], (null === c || ce(t, c) > 0) && (h = !0) } else c = n; if (r) if (0 !== l) { const e = br(t[a + 1]); t[i + 1] = vr(e, a), 0 !== e && (t[e + 1] = Cr(t[e + 1], i)), t[a + 1] = 131071 & t[a + 1] | i << 17 } else t[i + 1] = vr(a, 0), 0 !== a && (t[a + 1] = Cr(t[a + 1], i)), a = i; else t[i + 1] = vr(l, 0), 0 === a ? a = i : t[l + 1] = Cr(t[l + 1], i), l = i; h && (t[i + 1] = wr(t[i + 1])), Zo(t, c, i, !0), Zo(t, c, i, !1), function (t, e, n, i, r) { const s = r ? t.residualClasses : t.residualStyles; null != s && "string" == typeof e && ce(s, e) >= 0 && (n[i + 1] = Sr(n[i + 1])) }(e, c, t, i, s), o = vr(a, l), s ? e.classBindings = o : e.styleBindings = o }(r, s, e, n, o, i) } } function ha(t, e, n, i, r) { let s = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (s = e[a], i = ua(i, s.hostAttrs, r), s !== t);)a++; return null !== t && (n.directiveStylingLast = a), i } function ua(t, e, n) { const i = n ? 1 : 2; let r = -1; if (null !== e) for (let s = 0; s < e.length; s++) { const o = e[s]; "number" == typeof o ? r = o : r === i && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), ae(t, o, !!n || e[++s])) } return void 0 === t ? null : t } function da(t, e, n, i, r, s, o, a) { if (3 !== e.type) return; const l = t.data, c = l[a + 1]; fa(1 == (1 & c) ? pa(l, e, n, r, xr(c), o) : void 0) || (fa(s) || function (t) { return 2 == (2 & t) }(c) && (s = pa(l, null, n, r, a, o)), function (t, e, n, i, r) { const s = Le(t); if (e) r ? s ? t.addClass(n, i) : n.classList.add(i) : s ? t.removeClass(n, i) : n.classList.remove(i); else { const e = -1 == i.indexOf("-") ? void 0 : 2; null == r ? s ? t.removeStyle(n, i, e) : n.style.removeProperty(i) : s ? t.setStyle(n, i, r, e) : n.style.setProperty(i, r) } }(i, o, Ve(xn(), n), r, s)) } function pa(t, e, n, i, r, s) { const o = null === e; let a = void 0; for (; r > 0;) { const e = t[r], s = Array.isArray(e), l = s ? e[1] : e, c = null === l; let h = n[r + 1]; h === mr && (h = c ? Qo : void 0); let u = c ? le(h, i) : l === i ? h : void 0; if (s && !fa(u) && (u = le(e, i)), fa(u) && (a = u, o)) return a; const d = t[r + 1]; r = o ? br(d) : xr(d) } if (null !== e) { let t = s ? e.residualClasses : e.residualStyles; null != t && (a = le(t, i)) } return a } function fa(t) { return void 0 !== t } function ma(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function ga(t, e = "") { const n = Ke(), i = Qe(), r = t + 19, s = i.firstCreatePass ? Ar(i, n[6], t, 3, null, null) : i.data[r], o = n[r] = function (t, e) { return Le(e) ? e.createText(t) : e.createTextNode(t) }(e, n[11]); Ps(i, n, o, s), tn(s, !1) } function ya(t) { return _a("", t, ""), ya } function _a(t, e, n) { const i = Ke(), r = ko(i, t, e, n); return r !== mr && fs(i, xn(), r), _a } function va(t, e, n, i, r) { const s = Ke(), o = function (t, e, n, i, r, s) { const o = Co(t, an(), n, r); return cn(2), o ? e + Un(n) + i + Un(r) + s : mr }(s, t, e, n, i, r); return o !== mr && fs(s, xn(), o), va } function ba(t, e, n) { const i = Ke(); return xo(i, ln(), e) && Br(Qe(), Sn(), i, t, e, i[11], n, !0), ba } function wa(t, e, n) { const i = Ke(); if (xo(i, ln(), e)) { const r = Qe(), s = Sn(); Br(r, s, i, t, e, us(dn(r.data), s, i), n, !0) } return wa } function xa(t, e) { const n = Ue(t)[1], i = n.data.length - 1; On(n, { directiveStart: i, directiveEnd: i + 1 }) } function Ca(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor, n = !0; const i = [t]; for (; e;) { let r = void 0; if (De(t)) r = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); r = e.\u0275dir } if (r) { if (n) { i.push(r); const e = t; e.inputs = Sa(t.inputs), e.declaredInputs = Sa(t.declaredInputs), e.outputs = Sa(t.outputs); const n = r.hostBindings; n && Oa(t, n); const s = r.viewQuery, o = r.contentQueries; if (s && ka(t, s), o && Ea(t, o), ut(t.inputs, r.inputs), ut(t.declaredInputs, r.declaredInputs), ut(t.outputs, r.outputs), De(r) && r.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(r.data.animation) } e.afterContentChecked = e.afterContentChecked || r.afterContentChecked, e.afterContentInit = t.afterContentInit || r.afterContentInit, e.afterViewChecked = t.afterViewChecked || r.afterViewChecked, e.afterViewInit = t.afterViewInit || r.afterViewInit, e.doCheck = t.doCheck || r.doCheck, e.onDestroy = t.onDestroy || r.onDestroy, e.onInit = t.onInit || r.onInit } const e = r.features; if (e) for (let i = 0; i < e.length; i++) { const r = e[i]; r && r.ngInherit && r(t), r === Ca && (n = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, n = null; for (let i = t.length - 1; i >= 0; i--) { const r = t[i]; r.hostVars = e += r.hostVars, r.hostAttrs = Nn(r.hostAttrs, n = Nn(n, r.hostAttrs)) } }(i) } function Sa(t) { return t === de ? {} : t === pe ? [] : t } function ka(t, e) { const n = t.viewQuery; t.viewQuery = n ? (t, i) => { e(t, i), n(t, i) } : e } function Ea(t, e) { const n = t.contentQueries; t.contentQueries = n ? (t, i, r) => { e(t, i, r), n(t, i, r) } : e } function Oa(t, e) { const n = t.hostBindings; t.hostBindings = n ? (t, i) => { e(t, i), n(t, i) } : e } class Aa { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function Ta(t) { t.type.prototype.ngOnChanges && (t.setInput = Pa, t.onChanges = function () { const t = Da(this), e = t && t.current; if (e) { const n = t.previous; if (n === de) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } }) } function Pa(t, e, n, i) { const r = Da(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: de, current: null }), s = r.current || (r.current = {}), o = r.previous, a = this.declaredInputs[n], l = o[a]; s[a] = new Aa(l && l.currentValue, e, o === de), t[i] = e } function Da(t) { return t.__ngSimpleChanges__ || null } function Ia(t, e, n, i, r) { if (t = Et(t), Array.isArray(t)) for (let s = 0; s < t.length; s++)Ia(t[s], e, n, i, r); else { const s = Qe(), o = Ke(); let a = oo(t) ? t : Et(t.provide), l = io(t); const c = Je(), h = 65535 & c.providerIndexes, u = c.directiveStart, d = c.providerIndexes >> 16; if (oo(t) || !t.multi) { const i = new Rn(l, r, Ao), p = La(a, e, r ? h : h + d, u); -1 === p ? (ei(Qn(c, o), s, a), Ra(s, t, e.length), e.push(a), c.directiveStart++, c.directiveEnd++, r && (c.providerIndexes += 65536), n.push(i), o.push(i)) : (n[p] = i, o[p] = i) } else { const p = La(a, e, h + d, u), f = La(a, e, h, h + d), m = p >= 0 && n[p], g = f >= 0 && n[f]; if (r && !g || !r && !m) { ei(Qn(c, o), s, a); const h = function (t, e, n, i, r) { const s = new Rn(t, n, Ao); return s.multi = [], s.index = e, s.componentProviders = 0, Ma(s, r, i && !n), s }(r ? Na : Fa, n.length, r, i, l); !r && g && (n[f].providerFactory = h), Ra(s, t, e.length, 0), e.push(a), c.directiveStart++, c.directiveEnd++, r && (c.providerIndexes += 65536), n.push(h), o.push(h) } else Ra(s, t, p > -1 ? p : f, Ma(n[r ? f : p], l, !r && i)); !r && i && g && n[f].componentProviders++ } } } function Ra(t, e, n, i) { const r = oo(e); if (r || e.useClass) { const s = (e.useClass || e).prototype.ngOnDestroy; if (s) { const o = t.destroyHooks || (t.destroyHooks = []); if (!r && e.multi) { const t = o.indexOf(n); -1 === t ? o.push(n, [i, s]) : o[t + 1].push(i, s) } else o.push(n, s) } } } function Ma(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function La(t, e, n, i) { for (let r = n; r < i; r++)if (e[r] === t) return r; return -1 } function Fa(t, e, n, i) { return Va(this.multi, []) } function Na(t, e, n, i) { const r = this.multi; let s; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = oi(n, n[1], this.providerFactory.index, i); s = e.slice(0, t), Va(r, s); for (let n = t; n < e.length; n++)s.push(e[n]) } else s = [], Va(r, s); return s } function Va(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function ja(t, e = []) { return n => { n.providersResolver = (n, i) => function (t, e, n) { const i = Qe(); if (i.firstCreatePass) { const r = De(t); Ia(n, i.data, i.blueprint, r, !0), Ia(e, i.data, i.blueprint, r, !1) } }(n, i ? i(t) : t, e) } } Ta.ngInherit = !0; class Ba { } class za { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${xt(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let Ha = (() => { class t { } return t.NULL = new za, t })(), Ua = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = () => $a(t), t })(); const $a = function (t) { return Hs(t, Je(), Ke()) }; class qa { } const Wa = function () { var t = { Important: 1, DashCase: 2 }; return t[t.Important] = "Important", t[t.DashCase] = "DashCase", t }(); let Ga = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Ya(), t })(); const Ya = function () { const t = Ke(), e = He(Je().index, t); return function (t) { const e = t[11]; if (Le(e)) return e; throw new Error("Cannot inject Renderer2 when the application uses Renderer3!") }(Ee(e) ? e : t) }; let Xa = (() => { class t { } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => null }), t })(); class Ka { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Qa = new Ka("9.1.4"); class Za { constructor() { } supports(t) { return vo(t) } create(t) { return new tl(t) } } const Ja = (t, e) => e; class tl { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || Ja } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, i = 0, r = null; for (; e || n;) { const s = !n || e && e.currentIndex < rl(n, i, r) ? e : n, o = rl(s, i, r), a = s.currentIndex; if (s === n) i--, n = n._nextRemoved; else if (e = e._next, null == s.previousIndex) i++; else { r || (r = []); const t = o - i, e = a - i; if (t != e) { for (let n = 0; n < t; n++) { const i = n < r.length ? r[n] : r[n] = 0, s = i + n; e <= s && s < t && (r[n] = i + 1) } r[s.previousIndex] = e - t } } o !== a && t(s, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !vo(t)) throw new Error(`Error trying to diff '${xt(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, i, r = this._itHead, s = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], i = this._trackByFn(e, n), null !== r && yo(r.trackById, i) ? (s && (r = this._verifyReinsertion(r, n, i, e)), yo(r.item, n) || this._addIdentityChange(r, n)) : (r = this._mismatch(r, n, i, e), s = !0), r = r._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[go()](); let i; for (; !(i = n.next()).done;)e(i.value) } }(t, t => { i = this._trackByFn(e, t), null !== r && yo(r.trackById, i) ? (s && (r = this._verifyReinsertion(r, t, i, e)), yo(r.item, t) || this._addIdentityChange(r, t)) : (r = this._mismatch(r, t, i, e), s = !0), r = r._next, e++ }), this.length = e; return this._truncate(r), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t, e; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = e)t.previousIndex = t.currentIndex, e = t._nextMoved; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, i) { let r; return null === t ? r = this._itTail : (r = t._prev, this._remove(t)), null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, i)) ? (yo(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, r, i)) : null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (yo(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, r, i)) : t = this._addAfter(new el(e, n), r, i), t } _verifyReinsertion(t, e, n, i) { let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== r ? t = this._reinsertAfter(r, t._prev, i) : t.currentIndex != i && (t.currentIndex = i, this._addToMoves(t, i)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const i = t._prevRemoved, r = t._nextRemoved; return null === i ? this._removalsHead = r : i._nextRemoved = r, null === r ? this._removalsTail = i : r._prevRemoved = i, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const i = null === e ? this._itHead : e._next; return t._next = i, t._prev = e, null === i ? this._itTail = t : i._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new il), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new il), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class el { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class nl { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && yo(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class il { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new nl, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function rl(t, e, n) { const i = t.previousIndex; if (null === i) return i; let r = 0; return n && i < n.length && (r = n[i]), i + e + r } class sl { constructor() { } supports(t) { return t instanceof Map || bo(t) } create() { return new ol } } class ol { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || bo(t))) throw new Error(`Error trying to diff '${xt(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const i = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, i) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const i = n._prev, r = n._next; return i && (i._next = r), r && (r._prev = i), n._next = null, n._prev = null, n } const n = new al(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { yo(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class al { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let ll = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend IterableDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new lt, new ot]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new t([new Za]) }), t })(), cl = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new lt, new ot]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new t([new sl]) }), t })(); const hl = [new sl], ul = new ll([new Za]), dl = new cl(hl); let pl = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => fl(t, Ua), t })(); const fl = function (t, e) { return Us(t, e, Je(), Ke()) }; let ml = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => gl(t, Ua), t })(); const gl = function (t, e) { return $s(t, e, Je(), Ke()) }, yl = {}; class _l extends Ha { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = Ce(t); return new wl(e, this.ngModule) } } function vl(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const bl = new Bt("SCHEDULER_TOKEN", { providedIn: "root", factory: () => qn }); class wl extends Ba { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(fr).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return vl(this.componentDef.inputs) } get outputs() { return vl(this.componentDef.outputs) } create(t, e, n, i) { const r = (i = i || this.ngModule) ? function (t, e) { return { get: (n, i, r) => { const s = t.get(n, yl, r); return s !== yl || i === yl ? s : e.get(n, i, r) } } }(t, i.injector) : t, s = r.get(qa, Fe), o = r.get(Xa, null), a = s.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = n ? function (t, e, n) { if (Le(t)) return t.selectRootElement(e, n === ue.ShadowDom); let i = "string" == typeof e ? t.querySelector(e) : e; return i.textContent = "", i }(a, n, this.componentDef.encapsulation) : Er(l, s.createRenderer(null, this.componentDef), function (t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)), h = this.componentDef.onPush ? 576 : 528, u = "string" == typeof n && /^#root-ng-internal-isolated-\d+/.test(n), d = { components: [], scheduler: qn, clean: ls, playerHandler: null, flags: 0 }, p = Nr(0, -1, null, 1, 0, null, null, null, null, null), f = Or(null, p, d, h, null, null, s, a, o, r); let m, g; gn(f, null); try { const t = function (t, e, n, i, r, s) { const o = n[1]; n[19] = t; const a = Ar(o, null, 0, 3, null, null), l = a.mergedAttrs = e.hostAttrs; null !== l && (fo(a, l), null !== t && (Mn(r, t, l), null !== a.classes && Fs(r, t, a.classes), null !== a.styles && Ls(r, t, a.styles))); const c = i.createRenderer(t, e), h = Or(n, Fr(e), null, e.onPush ? 64 : 16, n[19], a, i, c, void 0); return o.firstCreatePass && (ei(Qn(a, n), o, e.type), Wr(o, a), Yr(a, n.length, 1)), is(n, h), n[19] = h }(c, this.componentDef, f, s, a); if (c) if (n) Mn(a, c, ["ng-version", Qa.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let i = 1, r = 2; for (; i < t.length;) { let s = t[i]; if ("string" == typeof s) 2 === r ? "" !== s && e.push(s, t[++i]) : 8 === r && n.push(s); else { if (!cr(r)) break; r = s } i++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && Mn(a, c, t), e && e.length > 0 && Fs(a, c, e.join(" ")) } g = Be(f[1], 0), e && (g.projection = e.map(t => Array.from(t))), m = function (t, e, n, i, r) { const s = n[1], o = function (t, e, n) { const i = Je(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), qr(t, i, 1), Xr(t, e, n)); const r = oi(e, t, e.length - 1, i); er(r, e); const s = je(i, e); return s && er(s, e), r }(s, n, e); i.components.push(o), t[8] = o, r && r.forEach(t => t(o, e)), e.contentQueries && e.contentQueries(1, o, n.length - 1); const a = Je(); if (s.firstCreatePass && (null !== e.hostBindings || null !== e.hostAttrs)) { Cn(a.index - 19); const t = n[1]; Hr(t, e), Ur(t, n, e.hostVars), $r(e, o) } return o }(t, this.componentDef, f, d, [xa]), Tr(p, f, null) } finally { wn() } const y = new xl(this.componentType, m, Hs(Ua, g, f), f, g); return n && !u || (y.hostView._tViewNode.child = g), y } } class xl extends class { }{ constructor(t, e, n, i, r) { super(), this.location = n, this._rootLView = i, this._tNode = r, this.destroyCbs = [], this.instance = e, this.hostView = this.changeDetectorRef = new Vs(i), this.hostView._tViewNode = function (t, e, n, i) { let r = t.node; return null == r && (t.node = r = Vr(0, null, 2, -1, null, null)), i[6] = r }(i[1], 0, 0, i), this.componentType = t } get injector() { return new ci(this._tNode, this._rootLView) } destroy() { this.destroyCbs && (this.destroyCbs.forEach(t => t()), this.destroyCbs = null, !this.hostView.destroyed && this.hostView.destroy()) } onDestroy(t) { this.destroyCbs && this.destroyCbs.push(t) } } const Cl = void 0; var Sl = ["en", [["a", "p"], ["AM", "PM"], Cl], [["AM", "PM"], Cl, Cl], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Cl, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Cl, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Cl, "{1} 'at' {0}", Cl], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let kl = {}; function El(t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = Ol(e); if (n) return n; const i = e.split("-")[0]; if (n = Ol(i), n) return n; if ("en" === i) return Sl; throw new Error(`Missing locale data for the locale "${t}".`) } function Ol(t) { return t in kl || (kl[t] = It.ng && It.ng.common && It.ng.common.locales && It.ng.common.locales[t]), kl[t] } const Al = function () { var t = { LocaleId: 0, DayPeriodsFormat: 1, DayPeriodsStandalone: 2, DaysFormat: 3, DaysStandalone: 4, MonthsFormat: 5, MonthsStandalone: 6, Eras: 7, FirstDayOfWeek: 8, WeekendRange: 9, DateFormat: 10, TimeFormat: 11, DateTimeFormat: 12, NumberSymbols: 13, NumberFormats: 14, CurrencyCode: 15, CurrencySymbol: 16, CurrencyName: 17, Currencies: 18, Directionality: 19, PluralCase: 20, ExtraData: 21 }; return t[t.LocaleId] = "LocaleId", t[t.DayPeriodsFormat] = "DayPeriodsFormat", t[t.DayPeriodsStandalone] = "DayPeriodsStandalone", t[t.DaysFormat] = "DaysFormat", t[t.DaysStandalone] = "DaysStandalone", t[t.MonthsFormat] = "MonthsFormat", t[t.MonthsStandalone] = "MonthsStandalone", t[t.Eras] = "Eras", t[t.FirstDayOfWeek] = "FirstDayOfWeek", t[t.WeekendRange] = "WeekendRange", t[t.DateFormat] = "DateFormat", t[t.TimeFormat] = "TimeFormat", t[t.DateTimeFormat] = "DateTimeFormat", t[t.NumberSymbols] = "NumberSymbols", t[t.NumberFormats] = "NumberFormats", t[t.CurrencyCode] = "CurrencyCode", t[t.CurrencySymbol] = "CurrencySymbol", t[t.CurrencyName] = "CurrencyName", t[t.Currencies] = "Currencies", t[t.Directionality] = "Directionality", t[t.PluralCase] = "PluralCase", t[t.ExtraData] = "ExtraData", t }(); let Tl = "en-US"; function Pl(t) { var e, n; n = "Expected localeId to be defined", null == (e = t) && function (t, e, n, i) { throw new Error(`ASSERTION ERROR: ${t}` + ` [Expected=> null != ${e} <=Actual]`) }(n, e), "string" == typeof t && (Tl = t.toLowerCase().replace(/_/g, "-")) } const Dl = new Map; class Il extends ee { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new _l(this); const n = ke(t), i = t[Nt] || null; i && Pl(i), this._bootstrapComponents = Gn(n.bootstrap), this._r3Injector = to(t, e, [{ provide: ee, useValue: this }, { provide: Ha, useValue: this.componentFactoryResolver }], xt(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = lo.THROW_IF_NOT_FOUND, n = ct.Default) { return t === lo || t === ee || t === zt ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Rl extends ne { constructor(t) { super(), this.moduleType = t, null !== ke(t) && function t(e) { if (null !== e.\u0275mod.id) { const t = e.\u0275mod.id; (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${xt(e)} vs ${xt(e.name)}`) })(t, Dl.get(t), e), Dl.set(t, e) } let n = e.\u0275mod.imports; n instanceof Function && (n = n()), n && n.forEach(e => t(e)) }(t) } create(t) { return new Il(this.moduleType, t) } } function Ml(t, e, n) { const i = on() + t, r = Ke(); return r[i] === mr ? wo(r, i, n ? e.call(n) : e()) : function (t, e) { return t[e] }(r, i) } function Ll(t, e, n, i) { return Vl(Ke(), on(), t, e, n, i) } function Fl(t, e, n, i, r) { return jl(Ke(), on(), t, e, n, i, r) } function Nl(t, e) { const n = t[e]; return n === mr ? void 0 : n } function Vl(t, e, n, i, r, s) { const o = e + n; return xo(t, o, r) ? wo(t, o + 1, s ? i.call(s, r) : i(r)) : Nl(t, o + 1) } function jl(t, e, n, i, r, s, o) { const a = e + n; return Co(t, a, r, s) ? wo(t, a + 2, o ? i.call(o, r, s) : i(r, s)) : Nl(t, a + 2) } function Bl(t, e) { const n = Qe(); let i; const r = t + 19; n.firstCreatePass ? (i = function (t, e) { if (e) for (let n = e.length - 1; n >= 0; n--) { const i = e[n]; if (t === i.name) return i } throw new Error(`The pipe '${t}' could not be found!`) }(e, n.pipeRegistry), n.data[r] = i, i.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(r, i.onDestroy)) : i = n.data[r]; const s = i.factory || (i.factory = Se(i.type)), o = Yt(Ao), a = Xn(!1), l = s(); return Xn(a), Yt(o), function (t, e, n, i) { const r = n + 19; r >= t.data.length && (t.data[r] = null, t.blueprint[r] = null), e[r] = i }(n, Ke(), t, l), l } function zl(t, e, n) { const i = Ke(), r = ze(i, t); return $l(i, Ul(i, t) ? Vl(i, on(), e, r.transform, n, r) : r.transform(n)) } function Hl(t, e, n, i) { const r = Ke(), s = ze(r, t); return $l(r, Ul(r, t) ? jl(r, on(), e, s.transform, n, i, s) : s.transform(n, i)) } function Ul(t, e) { return t[1].data[e + 19].pure } function $l(t, e) { return _o.isWrapped(e) && (e = _o.unwrap(e), t[an()] = mr), e } class ql extends k { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { let i, r = t => null, s = () => null; t && "object" == typeof t ? (i = this.__isAsync ? e => { setTimeout(() => t.next(e)) } : e => { t.next(e) }, t.error && (r = this.__isAsync ? e => { setTimeout(() => t.error(e)) } : e => { t.error(e) }), t.complete && (s = this.__isAsync ? () => { setTimeout(() => t.complete()) } : () => { t.complete() })) : (i = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }, e && (r = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }), n && (s = this.__isAsync ? () => { setTimeout(() => n()) } : () => { n() })); const o = super.subscribe(i, r, s); return t instanceof u && t.add(o), o } } function Wl() { return this._results[go()]() } class Gl { constructor() { this.dirty = !0, this._results = [], this.changes = new ql, this.length = 0; const t = go(), e = Gl.prototype; e[t] || (e[t] = Wl) } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t) { this._results = function t(e, n) { void 0 === n && (n = e); for (let i = 0; i < e.length; i++) { let r = e[i]; Array.isArray(r) ? (n === e && (n = e.slice(0, i)), t(r, n)) : n !== e && n.push(r) } return n }(t), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class Yl { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Yl(this.queryList) } setDirty() { this.queryList.setDirty() } } class Xl { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, i = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); i.push(this.queries[n.indexInDeclarationView].clone()) } return new Xl(i) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== dc(t, e).matches && this.queries[e].setDirty() } } class Kl { constructor(t, e, n, i = null) { this.predicate = t, this.descendants = e, this.isStatic = n, this.read = i } } class Ql { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const i = null !== e ? e.length : 0, r = this.getByIndex(n).embeddedTView(t, i); r && (r.indexInDeclarationView = n, null !== e ? e.push(r) : e = [r]) } return null !== e ? new Ql(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Zl { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Zl(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && !1 === this.metadata.descendants) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 4 === n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { if (Array.isArray(this.metadata.predicate)) { const n = this.metadata.predicate; for (let i = 0; i < n.length; i++)this.matchTNodeWithReadOption(t, e, Jl(e, n[i])) } else { const n = this.metadata.predicate; n === pl ? 0 === e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, si(e, t, n, !1, !1)) } } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const i = this.metadata.read; if (null !== i) if (i === Ua || i === ml || i === pl && 0 === e.type) this.addMatch(e.index, -2); else { const n = si(e, t, i, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function Jl(t, e) { const n = t.localNames; if (null !== n) for (let i = 0; i < n.length; i += 2)if (n[i] === e) return n[i + 1]; return null } function tc(t, e, n, i) { return -1 === n ? function (t, e) { return 3 === t.type || 4 === t.type ? Hs(Ua, t, e) : 0 === t.type ? Us(pl, Ua, t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === Ua ? Hs(Ua, e, t) : n === pl ? Us(pl, Ua, e, t) : n === ml ? $s(ml, Ua, e, t) : void 0 }(t, e, i) : oi(t, t[1], n, e) } function ec(t, e, n, i) { const r = e[5].queries[i]; if (null === r.matches) { const i = t.data, s = n.matches, o = []; for (let t = 0; t < s.length; t += 2) { const r = s[t]; o.push(r < 0 ? null : tc(e, i[r], s[t + 1], n.metadata.read)) } r.matches = o } return r.matches } function nc(t) { const e = Ke(), n = Qe(), i = pn(); fn(i + 1); const r = dc(n, i); if (t.dirty && $e(e) === r.metadata.isStatic) { if (null === r.matches) t.reset([]); else { const s = r.crossesNgTemplate ? function t(e, n, i, r) { const s = e.queries.getByIndex(i), o = s.matches; if (null !== o) { const a = ec(e, n, s, i); for (let e = 0; e < o.length; e += 2) { const i = o[e]; if (i > 0) r.push(a[e / 2]); else { const s = o[e + 1], a = n[-i]; for (let e = 9; e < a.length; e++) { const n = a[e]; n[17] === n[3] && t(n[1], n, s, r) } if (null !== a[5]) { const e = a[5]; for (let n = 0; n < e.length; n++) { const i = e[n]; t(i[1], i, s, r) } } } } } return r }(n, e, i, []) : ec(n, e, r, i); t.reset(s), t.notifyOnChanges() } return !0 } return !1 } function ic(t, e, n) { sc(Qe(), Ke(), t, e, n, !0) } function rc(t, e, n) { sc(Qe(), Ke(), t, e, n, !1) } function sc(t, e, n, i, r, s) { t.firstCreatePass && (uc(t, new Kl(n, i, s, r), -1), s && (t.staticViewQueries = !0)), hc(t, e) } function oc(t, e, n, i) { lc(Qe(), Ke(), e, n, i, !1, Je(), t) } function ac(t, e, n, i) { lc(Qe(), Ke(), e, n, i, !0, Je(), t) } function lc(t, e, n, i, r, s, o, a) { t.firstCreatePass && (uc(t, new Kl(n, i, s, r), o.index), function (t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (t.contentQueries.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(t, a), s && (t.staticContentQueries = !0)), hc(t, e) } function cc() { return t = Ke(), e = pn(), t[5].queries[e].queryList; var t, e } function hc(t, e) { const n = new Gl; !function (t, e, n, i) { const r = cs(e); r.push(n), t.firstCreatePass && hs(t).push(i, r.length - 1) }(t, e, n, n.destroy), null === e[5] && (e[5] = new Xl), e[5].queries.push(new Yl(n)) } function uc(t, e, n) { null === t.queries && (t.queries = new Ql), t.queries.track(new Zl(e, n)) } function dc(t, e) { return t.queries.getByIndex(e) } const pc = new Bt("Application Initializer"); let fc = (() => { class t { constructor(t) { this.appInits = t, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); Bo(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Kt(pc, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const mc = new Bt("AppId"), gc = { provide: mc, useFactory: function () { return `${yc()}${yc()}${yc()}` }, deps: [] }; function yc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const _c = new Bt("Platform Initializer"), vc = new Bt("Platform ID"), bc = new Bt("appBootstrapListener"); let wc = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const xc = new Bt("LocaleId"), Cc = new Bt("DefaultCurrencyCode"); class Sc { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const kc = function (t) { return new Rl(t) }, Ec = kc, Oc = function (t) { return Promise.resolve(kc(t)) }, Ac = function (t) { const e = kc(t), n = Gn(ke(t).declarations).reduce((t, e) => { const n = Ce(e); return n && t.push(new wl(n)), t }, []); return new Sc(e, n) }, Tc = Ac, Pc = function (t) { return Promise.resolve(Ac(t)) }; let Dc = (() => { class t { constructor() { this.compileModuleSync = Ec, this.compileModuleAsync = Oc, this.compileModuleAndAllComponentsSync = Tc, this.compileModuleAndAllComponentsAsync = Pc } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Ic = new Bt("compilerOptions"), Rc = (() => Promise.resolve(0))(); function Mc(t) { "undefined" == typeof Zone ? Rc.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Lc { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ql(!1), this.onMicrotaskEmpty = new ql(!1), this.onStable = new ql(!1), this.onError = new ql(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), this.shouldCoalesceEventChangeDetection = e, this.lastRequestAnimationFrameId = -1, this.nativeRequestAnimationFrame = function () { let t = It.requestAnimationFrame, e = It.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const i = e[Zone.__symbol__("OriginalDelegate")]; i && (e = i) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = !!t.shouldCoalesceEventChangeDetection && t.nativeRequestAnimationFrame && (() => { !function (t) { -1 === t.lastRequestAnimationFrameId && (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(It, () => { t.lastRequestAnimationFrameId = -1, jc(t), Vc(t) }), jc(t)) }(t) }); t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0, maybeDelayChangeDetection: e }, onInvokeTask: (n, i, r, s, o, a) => { try { return Bc(t), n.invokeTask(r, s, o, a) } finally { e && "eventTask" === s.type && e(), zc(t) } }, onInvoke: (e, n, i, r, s, o, a) => { try { return Bc(t), e.invoke(i, r, s, o, a) } finally { zc(t) } }, onHasTask: (e, n, i, r) => { e.hasTask(i, r), n === i && ("microTask" == r.change ? (t._hasPendingMicrotasks = r.microTask, jc(t), Vc(t)) : "macroTask" == r.change && (t.hasPendingMacrotasks = r.macroTask)) }, onHandleError: (e, n, i, r) => (e.handleError(i, r), t.runOutsideAngular(() => t.onError.emit(r)), !1) }) }(this) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Lc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Lc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, i) { const r = this._inner, s = r.scheduleEventTask("NgZoneEvent: " + i, t, Nc, Fc, Fc); try { return r.runTask(s, e, n) } finally { r.cancelTask(s) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } function Fc() { } const Nc = {}; function Vc(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function jc(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || t.shouldCoalesceEventChangeDetection && -1 !== t.lastRequestAnimationFrameId) } function Bc(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function zc(t) { t._nesting--, Vc(t) } class Hc { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ql, this.onMicrotaskEmpty = new ql, this.onStable = new ql, this.onError = new ql } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, i) { return t.apply(e, n) } } let Uc = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Lc.assertNotInAngularZone(), Mc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Mc(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let i = -1; e && e > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== i), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: i, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Lc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), $c = (() => { class t { constructor() { this._applications = new Map, Gc.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return Gc.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class qc { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } let Wc, Gc = new qc, Yc = function (t, e, n) { const i = t.get(Ic, []).concat(e), r = new Rl(n); if (0 === ho.size) return Promise.resolve(r); const s = function (t) { const e = []; return t.forEach(t => t && e.push(...t)), e }(i.map(t => t.providers)); if (0 === s.length) return Promise.resolve(r); const o = function () { const t = It.ng; if (!t || !t.\u0275compilerFacade) throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping."); return t.\u0275compilerFacade }(), a = lo.create({ providers: s }).get(o.ResourceLoader); return function (t) { const e = [], n = new Map; function i(t) { let e = n.get(t); if (!e) { const i = (t => Promise.resolve(a.get(t)))(t); n.set(t, e = i.then(po)) } return e } return ho.forEach((t, n) => { const r = []; t.templateUrl && r.push(i(t.templateUrl).then(e => { t.template = e })); const s = t.styleUrls, o = t.styles || (t.styles = []), a = t.styles.length; s && s.forEach((e, n) => { o.push(""), r.push(i(e).then(i => { o[a + n] = i, s.splice(s.indexOf(e), 1), 0 == s.length && (t.styleUrls = void 0) })) }); const l = Promise.all(r).then(() => function (t) { uo.delete(t) }(n)); e.push(l) }), ho = new Map, Promise.all(e).then(() => { }) }().then(() => r) }; const Xc = new Bt("AllowMultipleToken"); class Kc { constructor(t, e) { this.name = t, this.token = e } } function Qc(t, e, n = []) { const i = `Platform: ${e}`, r = new Bt(i); return (e = []) => { let s = Zc(); if (!s || s.injector.get(Xc, !1)) if (t) t(n.concat(e).concat({ provide: r, useValue: !0 })); else { const t = n.concat(e).concat({ provide: r, useValue: !0 }, { provide: Ys, useValue: "platform" }); !function (t) { if (Wc && !Wc.destroyed && !Wc.injector.get(Xc, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Wc = t.get(Jc); const e = t.get(_c, null); e && e.forEach(t => t()) }(lo.create({ providers: t, name: i })) } return function (t) { const e = Zc(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(r) } } function Zc() { return Wc && !Wc.destroyed ? Wc : null } let Jc = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new Hc : ("zone.js" === t ? void 0 : t) || new Lc({ enableLongStackTrace: Ei(), shouldCoalesceEventChangeDetection: e }), n }(e ? e.ngZone : void 0, e && e.ngZoneEventCoalescing || !1), i = [{ provide: Lc, useValue: n }]; return n.run(() => { const e = lo.create({ providers: i, parent: this.injector, name: t.moduleType.name }), r = t.create(e), s = r.injector.get(fi, null); if (!s) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return r.onDestroy(() => nh(this._modules, r)), n.runOutsideAngular(() => n.onError.subscribe({ next: t => { s.handleError(t) } })), function (t, e, n) { try { const i = n(); return Bo(i) ? i.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : i } catch (i) { throw e.runOutsideAngular(() => t.handleError(i)), i } }(s, n, () => { const t = r.injector.get(fc); return t.runInitializers(), t.donePromise.then(() => (Pl(r.injector.get(xc, "en-US") || "en-US"), this._moduleDoBootstrap(r), r)) }) }) } bootstrapModule(t, e = []) { const n = th({}, e); return Yc(this.injector, n, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(eh); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${xt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + "Please define one of these."); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(Kt(lo)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function th(t, e) { return Array.isArray(e) ? e.reduce(th, t) : Object.assign(Object.assign({}, t), e) } let eh = (() => { class t { constructor(t, e, n, i, r, s) { this._zone = t, this._console = e, this._injector = n, this._exceptionHandler = i, this._componentFactoryResolver = r, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = Ei(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new b(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), a = new b(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Lc.assertNotInAngularZone(), Mc(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Lc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = G(o, a.pipe(t => Y()(tt(nt)(t)))) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof Ba ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const i = n.isBoundToModule ? void 0 : this._injector.get(ee), r = n.create(lo.NULL, [], e || n.selector, i); r.onDestroy(() => { this._unloadComponent(r) }); const s = r.injector.get(Uc, null); return s && r.injector.get($c).registerApplication(r.location.nativeElement, s), this._loadComponent(r), Ei() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), r } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges(); if (this._enforceNoNewChanges) for (let t of this._views) t.checkNoChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; nh(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(bc, []).concat(this._bootstrapListeners).forEach(e => e(t)) } _unloadComponent(t) { this.detachView(t.hostView), nh(this.components, t) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()) } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Lc), Kt(wc), Kt(lo), Kt(fi), Kt(Ha), Kt(fc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function nh(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class ih { } class rh { } const sh = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let oh = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || sh } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, i] = t.split("#"); return void 0 === i && (i = "default"), n("zn8P")(e).then(t => t[i]).then(t => ah(t, e, i)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, i] = t.split("#"), r = "NgFactory"; return void 0 === i && (i = "default", r = ""), n("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[i + r]).then(t => ah(t, e, i)) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Dc), Kt(rh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function ah(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const lh = Qc(null, "core", [{ provide: vc, useValue: "unknown" }, { provide: Jc, deps: [lo] }, { provide: $c, deps: [] }, { provide: wc, deps: [] }]), ch = [{ provide: eh, useClass: eh, deps: [Lc, wc, lo, fi, Ha, fc] }, { provide: bl, deps: [Lc], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: fc, useClass: fc, deps: [[new ot, pc]] }, { provide: Dc, useClass: Dc, deps: [] }, gc, { provide: ll, useFactory: function () { return ul }, deps: [] }, { provide: cl, useFactory: function () { return dl }, deps: [] }, { provide: xc, useFactory: function (t) { return Pl(t = t || "undefined" != typeof $localize && $localize.locale || "en-US"), t }, deps: [[new st(xc), new ot, new lt]] }, { provide: Cc, useValue: "USD" }]; let hh = (() => { class t { constructor(t) { } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t)(Kt(eh)) }, providers: ch }), t })(), uh = null; function dh() { return uh } const ph = new Bt("DocumentToken"); let fh = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: mh, token: t, providedIn: "platform" }), t })(); function mh() { return Kt(yh) } const gh = new Bt("Location Initialized"); let yh = (() => { class t extends fh { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = dh().getLocation(), this._history = dh().getHistory() } getBaseHrefFromDOM() { return dh().getBaseHref(this._doc) } onPopState(t) { dh().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { dh().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { _h() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { _h() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ factory: vh, token: t, providedIn: "platform" }), t })(); function _h() { return !!window.history.pushState } function vh() { return new yh(Kt(ph)) } function bh(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function wh(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function xh(t) { return t && "?" !== t[0] ? "?" + t : t } let Ch = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: Sh, token: t, providedIn: "root" }), t })(); function Sh(t) { const e = Kt(ph).location; return new Eh(Kt(fh), e && e.origin || "") } const kh = new Bt("appBaseHref"); let Eh = (() => { class t extends Ch { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return bh(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + xh(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, i) { const r = this.prepareExternalUrl(n + xh(i)); this._platformLocation.pushState(t, e, r) } replaceState(t, e, n, i) { const r = this.prepareExternalUrl(n + xh(i)); this._platformLocation.replaceState(t, e, r) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(Kt(fh), Kt(kh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Oh = (() => { class t extends Ch { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = bh(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, i) { let r = this.prepareExternalUrl(n + xh(i)); 0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.pushState(t, e, r) } replaceState(t, e, n, i) { let r = this.prepareExternalUrl(n + xh(i)); 0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, r) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(Kt(fh), Kt(kh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Ah = (() => { class t { constructor(t, e) { this._subject = new ql, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = wh(Ph(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + xh(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, Ph(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + xh(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + xh(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) }) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Ch), Kt(fh)) }, t.normalizeQueryParams = xh, t.joinWithSlash = bh, t.stripTrailingSlash = wh, t.\u0275prov = dt({ factory: Th, token: t, providedIn: "root" }), t })(); function Th() { return new Ah(Kt(Ch), Kt(fh)) } function Ph(t) { return t.replace(/\/index.html$/, "") } const Dh = function () { var t = { Decimal: 0, Percent: 1, Currency: 2, Scientific: 3 }; return t[t.Decimal] = "Decimal", t[t.Percent] = "Percent", t[t.Currency] = "Currency", t[t.Scientific] = "Scientific", t }(), Ih = function () { var t = { Zero: 0, One: 1, Two: 2, Few: 3, Many: 4, Other: 5 }; return t[t.Zero] = "Zero", t[t.One] = "One", t[t.Two] = "Two", t[t.Few] = "Few", t[t.Many] = "Many", t[t.Other] = "Other", t }(), Rh = function () { var t = { Decimal: 0, Group: 1, List: 2, PercentSign: 3, PlusSign: 4, MinusSign: 5, Exponential: 6, SuperscriptingExponent: 7, PerMille: 8, Infinity: 9, NaN: 10, TimeSeparator: 11, CurrencyDecimal: 12, CurrencyGroup: 13 }; return t[t.Decimal] = "Decimal", t[t.Group] = "Group", t[t.List] = "List", t[t.PercentSign] = "PercentSign", t[t.PlusSign] = "PlusSign", t[t.MinusSign] = "MinusSign", t[t.Exponential] = "Exponential", t[t.SuperscriptingExponent] = "SuperscriptingExponent", t[t.PerMille] = "PerMille", t[t.Infinity] = "Infinity", t[t.NaN] = "NaN", t[t.TimeSeparator] = "TimeSeparator", t[t.CurrencyDecimal] = "CurrencyDecimal", t[t.CurrencyGroup] = "CurrencyGroup", t }(); function Mh(t, e) { const n = El(t), i = n[Al.NumberSymbols][e]; if (void 0 === i) { if (e === Rh.CurrencyDecimal) return n[Al.NumberSymbols][Rh.Decimal]; if (e === Rh.CurrencyGroup) return n[Al.NumberSymbols][Rh.Group] } return i } const Lh = /^(\d+)?\.((\d+)(-(\d+))?)?$/; function Fh(t) { const e = parseInt(t); if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + t); return e } class Nh { } let Vh = (() => { class t extends Nh { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function (t) { return El(t)[Al.PluralCase] }(e || this.locale)(t)) { case Ih.Zero: return "zero"; case Ih.One: return "one"; case Ih.Two: return "two"; case Ih.Few: return "few"; case Ih.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(xc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function jh(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [i, r] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (i.trim() === e) return decodeURIComponent(r) } return null } let Bh = (() => { class t { constructor(t, e, n, i) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = n, this._renderer = i, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (vo(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass); t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass); t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${xt(t.item)}`); this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) { (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ll), Ao(cl), Ao(Ua), Ao(Ga)) }, t.\u0275dir = we({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(); class zh { constructor(t, e, n, i) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = i } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Hh = (() => { class t { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { Ei() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}. ` + "See https://angular.io/api/common/NgForOf#change-propagation for more information."), this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${t = n, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, i) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new zh(null, this._ngForOf, -1, -1), null === i ? void 0 : i), r = new Uh(t, n); e.push(r) } else if (null == i) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const r = this._viewContainer.get(n); this._viewContainer.move(r, i); const s = new Uh(t, r); e.push(s) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, i = this._viewContainer.length; n < i; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = i, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(pl), Ao(ll)) }, t.\u0275dir = we({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class Uh { constructor(t, e) { this.record = t, this.view = e } } let $h = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new qh, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { Wh("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { Wh("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(pl)) }, t.\u0275dir = we({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class qh { constructor() { this.$implicit = null, this.ngIf = null } } function Wh(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${xt(e)}'.`) } class Gh { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let Yh = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(t) { this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(t) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t) } _matchCase(t) { const e = t == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e } _updateDefaultCases(t) { if (this._defaultViews && t !== this._defaultUsed) { this._defaultUsed = t; for (let e = 0; e < this._defaultViews.length; e++)this._defaultViews[e].enforceState(t) } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), t })(), Xh = (() => { class t { constructor(t, e, n) { this.ngSwitch = n, n._addCase(), this._view = new Gh(t, e) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(pl), Ao(Yh, 1)) }, t.\u0275dir = we({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(), Kh = (() => { class t { constructor(t, e, n) { n._addDefault(new Gh(t, e)) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(pl), Ao(Yh, 1)) }, t.\u0275dir = we({ type: t, selectors: [["", "ngSwitchDefault", ""]] }), t })(), Qh = (() => { class t { constructor(t, e, n) { this._ngEl = t, this._differs = e, this._renderer = n, this._ngStyle = null, this._differ = null } set ngStyle(t) { this._ngStyle = t, !this._differ && t && (this._differ = this._differs.find(t).create()) } ngDoCheck() { if (this._differ) { const t = this._differ.diff(this._ngStyle); t && this._applyChanges(t) } } _setStyle(t, e) { const [n, i] = t.split("."); null != (e = null != e && i ? `${e}${i}` : e) ? this._renderer.setStyle(this._ngEl.nativeElement, n, e) : this._renderer.removeStyle(this._ngEl.nativeElement, n) } _applyChanges(t) { t.forEachRemovedItem(t => this._setStyle(t.key, null)), t.forEachAddedItem(t => this._setStyle(t.key, t.currentValue)), t.forEachChangedItem(t => this._setStyle(t.key, t.currentValue)) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(cl), Ao(Ga)) }, t.\u0275dir = we({ type: t, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" } }), t })(); function Zh(t, e) { return Error(`InvalidPipeArgument: '${e}' for pipe '${xt(t)}'`) } class Jh { createSubscription(t, e) { return t.subscribe({ next: e, error: t => { throw t } }) } dispose(t) { t.unsubscribe() } onDestroy(t) { t.unsubscribe() } } class tu { createSubscription(t, e) { return t.then(e, t => { throw t }) } dispose(t) { } onDestroy(t) { } } const eu = new tu, nu = new Jh; let iu = (() => { class t { constructor(t) { this._ref = t, this._latestValue = null, this._latestReturnedValue = null, this._subscription = null, this._obj = null, this._strategy = null } ngOnDestroy() { this._subscription && this._dispose() } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : yo(this._latestValue, this._latestReturnedValue) ? this._latestReturnedValue : (this._latestReturnedValue = this._latestValue, _o.wrap(this._latestValue)) : (t && this._subscribe(t), this._latestReturnedValue = this._latestValue, this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, e => this._updateLatestValue(t, e)) } _selectStrategy(e) { if (Bo(e)) return eu; if (zo(e)) return nu; throw Zh(t, e) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._latestReturnedValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, e) { t === this._obj && (this._latestValue = e, this._ref.markForCheck()) } } return t.\u0275fac = function (e) { return new (e || t)(function (t = ct.Default) { const e = qs(!0); if (null != e || t & ct.Optional) return e; throw new Error("No provider for ChangeDetectorRef!") }()) }, t.\u0275pipe = xe({ name: "async", type: t, pure: !1 }), t })(), ru = (() => { class t { constructor(t) { this.differs = t, this.keyValues = [] } transform(t, e = su) { if (!t || !(t instanceof Map) && "object" != typeof t) return null; this.differ || (this.differ = this.differs.find(t).create()); const n = this.differ.diff(t); return n && (this.keyValues = [], n.forEachItem(t => { this.keyValues.push({ key: t.key, value: t.currentValue }) }), this.keyValues.sort(e)), this.keyValues } } return t.\u0275fac = function (e) { return new (e || t)(Ao(cl)) }, t.\u0275pipe = xe({ name: "keyvalue", type: t, pure: !1 }), t })(); function su(t, e) { const n = t.key, i = e.key; if (n === i) return 0; if (void 0 === n) return 1; if (void 0 === i) return -1; if (null === n) return 1; if (null === i) return -1; if ("string" == typeof n && "string" == typeof i) return n < i ? -1 : 1; if ("number" == typeof n && "number" == typeof i) return n - i; if ("boolean" == typeof n && "boolean" == typeof i) return n < i ? -1 : 1; const r = String(n), s = String(i); return r == s ? 0 : r < s ? -1 : 1 } let ou = (() => { class t { constructor(t) { this._locale = t } transform(e, n, i) { if (function (t) { return null == t || "" === t || t != t }(e)) return null; i = i || this._locale; try { return function (t, e, n) { return function (t, e, n, i, r, s, o = !1) { let a = "", l = !1; if (isFinite(t)) { let c = function (t) { let e, n, i, r, s, o = Math.abs(t) + "", a = 0; for ((n = o.indexOf(".")) > -1 && (o = o.replace(".", "")), (i = o.search(/e/i)) > 0 ? (n < 0 && (n = i), n += +o.slice(i + 1), o = o.substring(0, i)) : n < 0 && (n = o.length), i = 0; "0" === o.charAt(i); i++); if (i === (s = o.length)) e = [0], n = 1; else { for (s--; "0" === o.charAt(s);)s--; for (n -= i, e = [], r = 0; i <= s; i++, r++)e[r] = Number(o.charAt(i)) } return n > 22 && (e = e.splice(0, 21), a = n - 1, n = 1), { digits: e, exponent: a, integerLen: n } }(t); o && (c = function (t) { if (0 === t.digits[0]) return t; const e = t.digits.length - t.integerLen; return t.exponent ? t.exponent += 2 : (0 === e ? t.digits.push(0, 0) : 1 === e && t.digits.push(0), t.integerLen += 2), t }(c)); let h = e.minInt, u = e.minFrac, d = e.maxFrac; if (s) { const t = s.match(Lh); if (null === t) throw new Error(`${s} is not a valid digit info`); const e = t[1], n = t[3], i = t[5]; null != e && (h = Fh(e)), null != n && (u = Fh(n)), null != i ? d = Fh(i) : null != n && u > d && (d = u) } !function (t, e, n) { if (e > n) throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`); let i = t.digits, r = i.length - t.integerLen; const s = Math.min(Math.max(e, r), n); let o = s + t.integerLen, a = i[o]; if (o > 0) { i.splice(Math.max(t.integerLen, o)); for (let t = o; t < i.length; t++)i[t] = 0 } else { r = Math.max(0, r), t.integerLen = 1, i.length = Math.max(1, o = s + 1), i[0] = 0; for (let t = 1; t < o; t++)i[t] = 0 } if (a >= 5) if (o - 1 < 0) { for (let e = 0; e > o; e--)i.unshift(0), t.integerLen++; i.unshift(1), t.integerLen++ } else i[o - 1]++; for (; r < Math.max(0, s); r++)i.push(0); let l = 0 !== s; const c = e + t.integerLen, h = i.reduceRight((function (t, e, n, i) { return i[n] = (e += t) < 10 ? e : e - 10, l && (0 === i[n] && n >= c ? i.pop() : l = !1), e >= 10 ? 1 : 0 }), 0); h && (i.unshift(h), t.integerLen++) }(c, u, d); let p = c.digits, f = c.integerLen; const m = c.exponent; let g = []; for (l = p.every(t => !t); f < h; f++)p.unshift(0); for (; f < 0; f++)p.unshift(0); f > 0 ? g = p.splice(f, p.length) : (g = p, p = [0]); const y = []; for (p.length >= e.lgSize && y.unshift(p.splice(-e.lgSize, p.length).join("")); p.length > e.gSize;)y.unshift(p.splice(-e.gSize, p.length).join("")); p.length && y.unshift(p.join("")), a = y.join(Mh(n, i)), g.length && (a += Mh(n, r) + g.join("")), m && (a += Mh(n, Rh.Exponential) + "+" + m) } else a = Mh(n, Rh.Infinity); return a = t < 0 && !l ? e.negPre + a + e.negSuf : e.posPre + a + e.posSuf, a }(t, function (t, e = "-") { const n = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, i = t.split(";"), r = i[0], s = i[1], o = -1 !== r.indexOf(".") ? r.split(".") : [r.substring(0, r.lastIndexOf("0") + 1), r.substring(r.lastIndexOf("0") + 1)], a = o[0], l = o[1] || ""; n.posPre = a.substr(0, a.indexOf("#")); for (let h = 0; h < l.length; h++) { const t = l.charAt(h); "0" === t ? n.minFrac = n.maxFrac = h + 1 : "#" === t ? n.maxFrac = h + 1 : n.posSuf += t } const c = a.split(","); if (n.gSize = c[1] ? c[1].length : 0, n.lgSize = c[2] || c[1] ? (c[2] || c[1]).length : 0, s) { const t = r.length - n.posPre.length - n.posSuf.length, e = s.indexOf("#"); n.negPre = s.substr(0, e).replace(/'/g, ""), n.negSuf = s.substr(e + t).replace(/'/g, "") } else n.negPre = e + n.posPre, n.negSuf = n.posSuf; return n }(function (t, e) { return El(t)[Al.NumberFormats][e] }(e, Dh.Decimal), Mh(e, Rh.MinusSign)), e, Rh.Group, Rh.Decimal, n) }(function (t) { if ("string" == typeof t && !isNaN(Number(t) - parseFloat(t))) return Number(t); if ("number" != typeof t) throw new Error(`${t} is not a number`); return t }(e), i, n) } catch (r) { throw Zh(t, r.message) } } } return t.\u0275fac = function (e) { return new (e || t)(Ao(xc)) }, t.\u0275pipe = xe({ name: "number", type: t, pure: !0 }), t })(), au = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [{ provide: Nh, useClass: Vh }] }), t })(); function lu(t) { return "browser" === t } function cu(t) { return "server" === t } let hu = (() => { class t { } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new uu(Kt(ph), window, Kt(fi)) }), t })(); class uu { constructor(t, e, n) { this.document = t, this.window = e, this.errorHandler = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportScrollRestoration() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(t) { this.supportScrollRestoration() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (this.supportScrollRestoration()) { t = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(t) : t.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1"); try { const e = this.document.querySelector(`#${t}`); if (e) return void this.scrollToElement(e); const n = this.document.querySelector(`[name='${t}']`); if (n) return void this.scrollToElement(n) } catch (e) { this.errorHandler.handleError(e) } } } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, i = e.top + this.window.pageYOffset, r = this.offset(); this.window.scrollTo(n - r[0], i - r[1]) } supportScrollRestoration() { try { return !!this.window && !!this.window.scrollTo } catch (t) { return !1 } } } class du extends class extends class { }{ constructor() { super() } supportsDOMEvents() { return !0 } }{ static makeCurrent() { var t; t = new du, uh || (uh = t) } getProperty(t, e) { return t[e] } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } getValue(t) { return t.value } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = fu || (fu = document.querySelector("base"), fu) ? fu.getAttribute("href") : null; return null == e ? null : (n = e, pu || (pu = document.createElement("a")), pu.setAttribute("href", n), "/" === pu.pathname.charAt(0) ? pu.pathname : "/" + pu.pathname); var n } resetBaseElement() { fu = null } getUserAgent() { return window.navigator.userAgent } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return jh(document.cookie, t) } } let pu, fu = null; const mu = new Bt("TRANSITION_ID"), gu = [{ provide: pc, useFactory: function (t, e, n) { return () => { n.get(fc).donePromise.then(() => { const n = dh(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [mu, ph, lo], multi: !0 }]; class yu { static init() { var t; t = new yu, Gc = t } addToWindow(t) { It.getAngularTestability = (e, n = !0) => { const i = t.findTestabilityInTree(e, n); if (null == i) throw new Error("Could not find testability for element."); return i }, It.getAllAngularTestabilities = () => t.getAllTestabilities(), It.getAllAngularRootElements = () => t.getAllRootElements(), It.frameworkStabilizers || (It.frameworkStabilizers = []), It.frameworkStabilizers.push(t => { const e = It.getAllAngularTestabilities(); let n = e.length, i = !1; const r = function (e) { i = i || e, n--, 0 == n && t(i) }; e.forEach((function (t) { t.whenStable(r) })) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const i = t.getTestability(e); return null != i ? i : n ? dh().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } const _u = new Bt("EventManagerPlugins"); let vu = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let i = 0; i < n.length; i++) { const e = n[i]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(_u), Kt(Lc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class bu { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const i = dh().getGlobalEventTarget(this._doc, t); if (!i) throw new Error(`Unsupported event target ${i} for event ${e}`); return this.addEventListener(i, e, n) } } let wu = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), xu = (() => { class t extends wu { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, this._styleNodes.add(e.appendChild(n)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => dh().remove(t)) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Cu = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Su = /%COMP%/g; function ku(t, e, n) { for (let i = 0; i < e.length; i++) { let r = e[i]; Array.isArray(r) ? ku(t, r, n) : (r = r.replace(Su, t), n.push(r)) } return n } function Eu(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Ou = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Au(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case ue.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new Tu(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case ue.Native: case ue.ShadowDom: return new Pu(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = ku(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(Kt(vu), Kt(xu), Kt(mc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Au { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(Cu[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, i) { if (i) { e = i + ":" + e; const r = Cu[i]; r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const i = Cu[n]; i ? t.removeAttributeNS(i, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, i) { i & Wa.DashCase ? t.style.setProperty(e, n, i & Wa.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & Wa.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, Eu(n)) : this.eventManager.addEventListener(t, e, Eu(n)) } } class Tu extends Au { constructor(t, e, n, i) { super(t), this.component = n; const r = ku(i + "-" + n.id, n.styles, []); e.addStyles(r), this.contentAttr = "_ngcontent-%COMP%".replace(Su, i + "-" + n.id), this.hostAttr = function (t) { return "_nghost-%COMP%".replace(Su, t) }(i + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class Pu extends Au { constructor(t, e, n, i) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.component = i, this.shadowRoot = i.encapsulation === ue.ShadowDom ? n.attachShadow({ mode: "open" }) : n.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const r = ku(i.id, i.styles, []); for (let s = 0; s < r.length; s++) { const t = document.createElement("style"); t.textContent = r[s], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let Du = (() => { class t extends bu { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Iu = ["alt", "control", "meta", "shift"], Ru = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Mu = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, Lu = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let Fu = (() => { class t extends bu { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, i) { const r = t.parseEventName(n), s = t.eventCallback(r.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => dh().onAndCancel(e, r.domEventName, s)) } static parseEventName(e) { const n = e.toLowerCase().split("."), i = n.shift(); if (0 === n.length || "keydown" !== i && "keyup" !== i) return null; const r = t._normalizeKey(n.pop()); let s = ""; if (Iu.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), s += t + ".") }), s += r, 0 != n.length || 0 === r.length) return null; const o = {}; return o.domEventName = i, o.fullKey = s, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && Mu.hasOwnProperty(e) && (e = Mu[e])) } return Ru[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), Iu.forEach(i => { i != n && (0, Lu[i])(t) && (e += i + ".") }), e += n, e } static eventCallback(e, n, i) { return r => { t.getEventFullKey(r) === e && i.runGuarded(() => n(r)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Nu = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return Kt(Vu) }, token: t, providedIn: "root" }), t })(), Vu = (() => { class t extends Nu { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) { case Xi.NONE: return e; case Xi.HTML: return xi(e, "HTML") ? wi(e) : Gi(this._doc, String(e)); case Xi.STYLE: return xi(e, "Style") ? wi(e) : function (t) { if (!(t = String(t).trim())) return ""; const e = t.match(Qi); return e && Pi(e[1]) === e[1] || t.match(Ki) && function (t) { let e = !0, n = !0; for (let i = 0; i < t.length; i++) { const r = t.charAt(i); "'" === r && n ? e = !e : '"' === r && e && (n = !n) } return e && n }(t) ? t : (Ei() && console.warn(`WARNING: sanitizing unsafe style value ${t} (see http://g.co/ng/security#xss).`), "unsafe") }(e); case Xi.SCRIPT: if (xi(e, "Script")) return wi(e); throw new Error("unsafe value used in a script context"); case Xi.URL: return Ci(e), xi(e, "URL") ? wi(e) : Pi(String(e)); case Xi.RESOURCE_URL: if (xi(e, "ResourceURL")) return wi(e); throw new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${t} (see http://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(t) { return new gi(t) } bypassSecurityTrustStyle(t) { return new yi(t) } bypassSecurityTrustScript(t) { return new _i(t) } bypassSecurityTrustUrl(t) { return new vi(t) } bypassSecurityTrustResourceUrl(t) { return new bi(t) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return t = Kt(zt), new Vu(t.get(ph)); var t }, token: t, providedIn: "root" }), t })(); const ju = Qc(lh, "browser", [{ provide: vc, useValue: "browser" }, { provide: _c, useValue: function () { du.makeCurrent(), yu.init() }, multi: !0 }, { provide: ph, useFactory: function () { return function (t) { Re = t }(document), document }, deps: [] }]), Bu = [[], { provide: Ys, useValue: "root" }, { provide: fi, useFactory: function () { return new fi }, deps: [] }, { provide: _u, useClass: Du, multi: !0, deps: [ph, Lc, vc] }, { provide: _u, useClass: Fu, multi: !0, deps: [ph] }, [], { provide: Ou, useClass: Ou, deps: [vu, xu, mc] }, { provide: qa, useExisting: Ou }, { provide: wu, useExisting: xu }, { provide: xu, useClass: xu, deps: [ph] }, { provide: Uc, useClass: Uc, deps: [Lc] }, { provide: vu, useClass: vu, deps: [_u, Lc] }, []]; let zu = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: mc, useValue: e.appId }, { provide: mu, useExisting: mc }, gu] } } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t)(Kt(t, 12)) }, providers: Bu, imports: [au, hh] }), t })(); function Hu() { return new Uu(Kt(ph)) } let Uu = (() => { class t { constructor(t) { this._doc = t } getTitle() { return this._doc.title } setTitle(t) { this._doc.title = t || "" } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ factory: Hu, token: t, providedIn: "root" }), t })(); "undefined" != typeof window && window; class $u { } function qu(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function Wu(t, e = null) { return { type: 4, styles: e, timings: t } } function Gu(t, e = null) { return { type: 3, steps: t, options: e } } function Yu(t, e = null) { return { type: 2, steps: t, options: e } } function Xu(t) { return { type: 6, styles: t, offset: null } } function Ku(t, e, n) { return { type: 0, name: t, styles: e, options: n } } function Qu(t) { return { type: 5, steps: t } } function Zu(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function Ju(t = null) { return { type: 9, options: t } } function td(t, e, n = null) { return { type: 11, selector: t, animation: e, options: n } } function ed(t) { Promise.resolve(null).then(t) } class nd { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { ed(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { } setPosition(t) { } getPosition() { return 0 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class id { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, i = 0; const r = this.players.length; 0 == r ? ed(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == r && this._onFinish() }), t.onDestroy(() => { ++n == r && this._onDestroy() }), t.onStart(() => { ++i == r && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { let t = 0; return this.players.forEach(e => { const n = e.getPosition(); t = Math.min(n, t) }), t } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function rd() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function sd(t) { switch (t.length) { case 0: return new nd; case 1: return t[0]; default: return new id(t) } } function od(t, e, n, i, r = {}, s = {}) { const o = [], a = []; let l = -1, c = null; if (i.forEach(t => { const n = t.offset, i = n == l, h = i && c || {}; Object.keys(t).forEach(n => { let i = n, a = t[n]; if ("offset" !== n) switch (i = e.normalizePropertyName(i, o), a) { case "!": a = r[n]; break; case "*": a = s[n]; break; default: a = e.normalizeStyleValue(n, i, a, o) }h[i] = a }), i || a.push(h), c = h, l = n }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return a } function ad(t, e, n, i) { switch (e) { case "start": t.onStart(() => i(n && ld(n, "start", t))); break; case "done": t.onDone(() => i(n && ld(n, "done", t))); break; case "destroy": t.onDestroy(() => i(n && ld(n, "destroy", t))) } } function ld(t, e, n) { const i = n.totalTime, r = cd(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == i ? t.totalTime : i, !!n.disabled), s = t._data; return null != s && (r._data = s), r } function cd(t, e, n, i, r = "", s = 0, o) { return { element: t, triggerName: e, fromState: n, toState: i, phaseName: r, totalTime: s, disabled: !!o } } function hd(t, e, n) { let i; return t instanceof Map ? (i = t.get(e), i || t.set(e, i = n)) : (i = t[e], i || (i = t[e] = n)), i } function ud(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let dd = (t, e) => !1, pd = (t, e) => !1, fd = (t, e, n) => []; const md = rd(); (md || "undefined" != typeof Element) && (dd = (t, e) => t.contains(e), pd = (() => { if (md || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : pd } })(), fd = (t, e, n) => { let i = []; if (n) i.push(...t.querySelectorAll(e)); else { const n = t.querySelector(e); n && i.push(n) } return i }); let gd = null, yd = !1; function _d(t) { gd || (gd = ("undefined" != typeof document ? document.body : null) || {}, yd = !!gd.style && "WebkitAppearance" in gd.style); let e = !0; return gd.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in gd.style, !e && yd) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in gd.style), e } const vd = pd, bd = dd, wd = fd; function xd(t) { const e = {}; return Object.keys(t).forEach(n => { const i = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[i] = t[n] }), e } let Cd = (() => { class t { validateStyleProperty(t) { return _d(t) } matchesElement(t, e) { return vd(t, e) } containsElement(t, e) { return bd(t, e) } query(t, e, n) { return wd(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, i, r, s = [], o) { return new nd(n, i) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Sd = (() => { class t { } return t.NOOP = new Cd, t })(); function kd(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Ed(parseFloat(e[1]), e[2]) } function Ed(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function Od(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let i, r = 0, s = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; i = Ed(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (r = Ed(parseFloat(o), n[4])); const a = n[5]; a && (s = a) } else i = t; if (!n) { let n = !1, s = e.length; i < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), r < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(s, 0, `The provided timing value "${t}" is invalid.`) } return { duration: i, delay: r, easing: s } }(t, e, n) } function Ad(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function Td(t, e, n = {}) { if (e) for (let i in t) n[i] = t[i]; else Ad(t, n); return n } function Pd(t, e, n) { return n ? e + ":" + n + ";" : "" } function Dd(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const i = t.style.item(n); e += Pd(0, i, t.style.getPropertyValue(i)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += Pd(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function Id(t, e, n) { t.style && (Object.keys(e).forEach(i => { const r = Bd(i); n && !n.hasOwnProperty(i) && (n[i] = t.style[r]), t.style[r] = e[i] }), rd() && Dd(t)) } function Rd(t, e) { t.style && (Object.keys(e).forEach(e => { const n = Bd(e); t.style[n] = "" }), rd() && Dd(t)) } function Md(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : Yu(t) : t } const Ld = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Fd(t) { let e = []; if ("string" == typeof t) { let n; for (; n = Ld.exec(t);)e.push(n[1]); Ld.lastIndex = 0 } return e } function Nd(t, e, n) { const i = t.toString(), r = i.replace(Ld, (t, i) => { let r = e[i]; return e.hasOwnProperty(i) || (n.push(`Please provide a value for the animation param ${i}`), r = ""), r.toString() }); return r == i ? t : r } function Vd(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const jd = /-+([a-z0-9])/g; function Bd(t) { return t.replace(jd, (...t) => t[1].toUpperCase()) } function zd(t, e) { return 0 === t || 0 === e } function Hd(t, e, n) { const i = Object.keys(n); if (i.length && e.length) { let s = e[0], o = []; if (i.forEach(t => { s.hasOwnProperty(t) || o.push(t), s[t] = n[t] }), o.length) for (var r = 1; r < e.length; r++) { let n = e[r]; o.forEach((function (e) { n[e] = $d(t, e) })) } } return e } function Ud(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function $d(t, e) { return window.getComputedStyle(t)[e] } function qd(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const i = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof i) return void e.push(i); t = i } const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const r = i[1], s = i[2], o = i[3]; e.push(Yd(r, o)), "<" != s[0] || "*" == r && "*" == o || e.push(Yd(o, r)) }(t, n, e)) : n.push(t), n } const Wd = new Set(["true", "1"]), Gd = new Set(["false", "0"]); function Yd(t, e) { const n = Wd.has(t) || Gd.has(t), i = Wd.has(e) || Gd.has(e); return (r, s) => { let o = "*" == t || t == r, a = "*" == e || e == s; return !o && n && "boolean" == typeof r && (o = r ? Wd.has(t) : Gd.has(t)), !a && i && "boolean" == typeof s && (a = s ? Wd.has(e) : Gd.has(e)), o && a } } const Xd = new RegExp("s*:selfs*,?", "g"); function Kd(t, e, n) { return new Qd(t).build(e, n) } class Qd { constructor(t) { this._driver = t } build(t, e) { const n = new Zd(e); return this._resetContextStyleTimingState(n), Ud(this, Md(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, i = e.depCount = 0; const r = [], s = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, i = n.name; i.toString().split(/\s*,\s*/).forEach(t => { n.name = t, r.push(this.visitState(n, e)) }), n.name = i } else if (1 == t.type) { const r = this.visitTransition(t, e); n += r.queryCount, i += r.depCount, s.push(r) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: r, transitions: s, queryCount: n, depCount: i, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), i = t.options && t.options.params || null; if (n.containsDynamicStyles) { const r = new Set, s = i || {}; if (n.styles.forEach(t => { if (Jd(t)) { const e = t; Object.keys(e).forEach(t => { Fd(e[t]).forEach(t => { s.hasOwnProperty(t) || r.add(t) }) }) } }), r.size) { const n = Vd(r.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: i ? { params: i } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = Ud(this, Md(t.animation), e); return { type: 1, matchers: qd(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: tp(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => Ud(this, t, e)), options: tp(t.options) } } visitGroup(t, e) { const n = e.currentTime; let i = 0; const r = t.steps.map(t => { e.currentTime = n; const r = Ud(this, t, e); return i = Math.max(i, e.currentTime), r }); return e.currentTime = i, { type: 3, steps: r, options: tp(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return ep(Od(t, e).duration, 0, ""); const i = t; if (i.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = ep(0, 0, ""); return t.dynamic = !0, t.strValue = i, t } return n = n || Od(i, e), ep(n.duration, n.delay, n.easing) }(t.timings, e.errors); let i; e.currentAnimateTimings = n; let r = t.styles ? t.styles : Xu({}); if (5 == r.type) i = this.visitKeyframes(r, e); else { let r = t.styles, s = !1; if (!r) { s = !0; const t = {}; n.easing && (t.easing = n.easing), r = Xu(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(r, e); o.isEmptyStep = s, i = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: i, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? "*" == t ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let i = !1, r = null; return n.forEach(t => { if (Jd(t)) { const e = t, n = e.easing; if (n && (r = n, delete e.easing), !i) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { i = !0; break } } }), { type: 6, styles: n, easing: r, offset: t.offset, containsDynamicStyles: i, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let i = e.currentTime, r = e.currentTime; n && r > 0 && (r -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const s = e.collectedStyles[e.currentQuerySelector], o = s[n]; let a = !0; o && (r != i && r >= o.startTime && i <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${i}ms"`), a = !1), r = o.startTime), a && (s[n] = { startTime: r, endTime: i }), e.options && function (t, e, n) { const i = e.params || {}, r = Fd(t); r.length && r.forEach(t => { i.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let i = 0; const r = []; let s = !1, o = !1, a = 0; const l = t.steps.map(t => { const n = this._makeStyleAst(t, e); let l = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (Jd(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (Jd(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != l && (i++, c = n.offset = l), o = o || c < 0 || c > 1, s = s || c < a, a = c, r.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), s && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let h = 0; i > 0 && i < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == i && (h = 1 / (c - 1)); const u = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, i) => { const s = h > 0 ? i == u ? 1 : h * i : r[i], o = s * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = s, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: Ud(this, Md(t.animation), e), options: tp(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: tp(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: tp(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, i = t.options || {}; e.queryCount++, e.currentQuery = t; const [r, s] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(Xd, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + r : r, hd(e.collectedStyles, e.currentQuerySelector, {}); const o = Ud(this, Md(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: r, limit: i.limit || 0, optional: !!i.optional, includeSelf: s, animation: o, originalSelector: t.selector, options: tp(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : Od(t.timings, e.errors, !0); return { type: 12, animation: Ud(this, Md(t.animation), e), timings: n, options: null } } } class Zd { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Jd(t) { return !Array.isArray(t) && "object" == typeof t } function tp(t) { var e; return t ? (t = Ad(t)).params && (t.params = (e = t.params) ? Ad(e) : null) : t = {}, t } function ep(t, e, n) { return { duration: t, delay: e, easing: n } } function np(t, e, n, i, r, s, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: i, duration: r, delay: s, totalTime: r + s, easing: o, subTimeline: a } } class ip { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const rp = new RegExp(":enter", "g"), sp = new RegExp(":leave", "g"); function op(t, e, n, i, r, s = {}, o = {}, a, l, c = []) { return (new ap).buildKeyframes(t, e, n, i, r, s, o, a, l, c) } class ap { buildKeyframes(t, e, n, i, r, s, o, a, l, c = []) { l = l || new ip; const h = new cp(t, e, l, i, r, c, []); h.options = a, h.currentTimeline.setStyles([s], null, h.errors, a), Ud(this, n, h); const u = h.timelines.filter(t => t.containsAnimation()); if (u.length && Object.keys(o).length) { const t = u[u.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, h.errors, a) } return u.length ? u.map(t => t.buildKeyframes()) : [np(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const i = e.createSubContext(t.options), r = e.currentTimeline.currentTime, s = this._visitSubInstructions(n, i, i.options); r != s && e.transformIntoNewTimeline(s) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let i = e.currentTimeline.currentTime; const r = null != n.duration ? kd(n.duration) : null, s = null != n.delay ? kd(n.delay) : null; return 0 !== r && t.forEach(t => { const n = e.appendInstructionToTimeline(t, r, s); i = Math.max(i, n.duration + n.delay) }), i } visitReference(t, e) { e.updateOptions(t.options, !0), Ud(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let i = e; const r = t.options; if (r && (r.params || r.delay) && (i = e.createSubContext(r), i.transformIntoNewTimeline(), null != r.delay)) { 6 == i.previousNode.type && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = lp); const t = kd(r.delay); i.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => Ud(this, t, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > n && i.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let i = e.currentTimeline.currentTime; const r = t.options && t.options.delay ? kd(t.options.delay) : 0; t.steps.forEach(s => { const o = e.createSubContext(t.options); r && o.delayNextStep(r), Ud(this, s, o), i = Math.max(i, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(i), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return Od(e.params ? Nd(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), i = e.currentTimeline; n.delay && (e.incrementTime(n.delay), i.snapshotCurrentStyles()); const r = t.style; 5 == r.type ? this.visitKeyframes(r, e) : (e.incrementTime(n.duration), this.visitStyle(r, e), i.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, i = e.currentAnimateTimings; !i && n.getCurrentStyleProperties().length && n.forwardFrame(); const r = i && i.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(r) : n.setStyles(t.styles, r, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, i = e.currentTimeline.duration, r = n.duration, s = e.createSubContext().currentTimeline; s.easing = n.easing, t.styles.forEach(t => { s.forwardTime((t.offset || 0) * r), s.setStyles(t.styles, t.easing, e.errors, e.options), s.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(s), e.transformIntoNewTimeline(i + r), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, i = t.options || {}, r = i.delay ? kd(i.delay) : 0; r && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = lp); let s = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!i.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, i) => { e.currentQueryIndex = i; const o = e.createSubContext(t.options, n); r && o.delayNextStep(r), n === e.element && (a = o.currentTimeline), Ud(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, i = e.currentTimeline, r = t.timings, s = Math.abs(r.duration), o = s * (e.currentQueryTotal - 1); let a = s * e.currentQueryIndex; switch (r.duration < 0 ? "reverse" : r.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; Ud(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = i.currentTime - c + (i.startTime - n.currentTimeline.startTime) } } const lp = {}; class cp { constructor(t, e, n, i, r, s, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = i, this._leaveClassName = r, this.errors = s, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = lp, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new hp(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let i = this.options; null != n.duration && (i.duration = kd(n.duration)), null != n.delay && (i.delay = kd(n.delay)); const r = n.params; if (r) { let t = i.params; t || (t = this.options.params = {}), Object.keys(r).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = Nd(r[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const i = e || this.element, r = new cp(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, n || 0)); return r.previousNode = this.previousNode, r.currentAnimateTimings = this.currentAnimateTimings, r.options = this._copyOptions(), r.updateOptions(t), r.currentQueryIndex = this.currentQueryIndex, r.currentQueryTotal = this.currentQueryTotal, r.parentContext = this, this.subContextCount++, r } transformIntoNewTimeline(t) { return this.previousNode = lp, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const i = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, r = new up(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, i, t.stretchStartingKeyframe); return this.timelines.push(r), i } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, i, r, s) { let o = []; if (i && o.push(this.element), t.length > 0) { t = (t = t.replace(rp, "." + this._enterClassName)).replace(sp, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return r || 0 != o.length || s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class hp { constructor(t, e, n, i) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = i, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new hp(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || "*", this._currentKeyframe[t] = "*" }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, i) { e && (this._previousKeyframe.easing = e); const r = i && i.params || {}, s = function (t, e) { const n = {}; let i; return t.forEach(t => { "*" === t ? (i = i || Object.keys(e), i.forEach(t => { n[t] = "*" })) : Td(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(s).forEach(t => { const e = Nd(s[t], r, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : "*"), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], i = t._styleSummary[e]; (!n || i.time > n.time) && this._updateStyle(e, i.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let i = []; this._keyframes.forEach((r, s) => { const o = Td(r, !0); Object.keys(o).forEach(n => { const i = o[n]; "!" == i ? t.add(n) : "*" == i && e.add(n) }), n || (o.offset = s / this.duration), i.push(o) }); const r = t.size ? Vd(t.values()) : [], s = e.size ? Vd(e.values()) : []; if (n) { const t = i[0], e = Ad(t); t.offset = 0, e.offset = 1, i = [t, e] } return np(this.element, i, r, s, this.duration, this.startTime, this.easing, !1) } } class up extends hp { constructor(t, e, n, i, r, s, o = !1) { super(t, e, s.delay), this.element = e, this.keyframes = n, this.preStyleProps = i, this.postStyleProps = r, this._stretchStartingKeyframe = o, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: i } = this.timings; if (this._stretchStartingKeyframe && e) { const r = [], s = n + e, o = e / s, a = Td(t[0], !1); a.offset = 0, r.push(a); const l = Td(t[0], !1); l.offset = dp(o), r.push(l); const c = t.length - 1; for (let i = 1; i <= c; i++) { let o = Td(t[i], !1); o.offset = dp((e + o.offset * n) / s), r.push(o) } n = s, e = 0, i = "", t = r } return np(this.element, t, this.preStyleProps, this.postStyleProps, n, e, i, !0) } } function dp(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class pp { } class fp extends pp { normalizePropertyName(t, e) { return Bd(t) } normalizeStyleValue(t, e, n, i) { let r = ""; const s = n.toString().trim(); if (mp[e] && 0 !== n && "0" !== n) if ("number" == typeof n) r = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && i.push(`Please provide a CSS unit value for ${t}:${n}`) } return s + r } } const mp = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function gp(t, e, n, i, r, s, o, a, l, c, h, u, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: r, fromState: n, fromStyles: s, toState: i, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: h, totalTime: u, errors: d } } const yp = {}; class _p { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, i) { return function (t, e, n, i, r) { return t.some(t => t(e, n, i, r)) }(this.ast.matchers, t, e, n, i) } buildStyles(t, e, n) { const i = this._stateStyles["*"], r = this._stateStyles[t], s = i ? i.buildStyles(e, n) : {}; return r ? r.buildStyles(e, n) : s } build(t, e, n, i, r, s, o, a, l, c) { const h = [], u = this.ast.options && this.ast.options.params || yp, d = this.buildStyles(n, o && o.params || yp, h), p = a && a.params || yp, f = this.buildStyles(i, p, h), m = new Set, g = new Map, y = new Map, _ = "void" === i, v = { params: Object.assign(Object.assign({}, u), p) }, b = c ? [] : op(t, e, this.ast.animation, r, s, d, f, v, l, h); let w = 0; if (b.forEach(t => { w = Math.max(t.duration + t.delay, w) }), h.length) return gp(e, this._triggerName, n, i, _, d, f, [], [], g, y, w, h); b.forEach(t => { const n = t.element, i = hd(g, n, {}); t.preStyleProps.forEach(t => i[t] = !0); const r = hd(y, n, {}); t.postStyleProps.forEach(t => r[t] = !0), n !== e && m.add(n) }); const x = Vd(m.values()); return gp(e, this._triggerName, n, i, _, d, f, b, x, g, y, w) } } class vp { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, i = Ad(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (i[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const r = t; Object.keys(r).forEach(t => { let s = r[t]; s.length > 1 && (s = Nd(s, i, e)), n[t] = s }) } }), n } } class bp { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new vp(t.style, t.options && t.options.params || {}) }), wp(this.states, "true", "1"), wp(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new _p(t, e, this.states)) }), this.fallbackTransition = new _p(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, i) { return this.transitionFactories.find(r => r.match(t, e, n, i)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function wp(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const xp = new ip; class Cp { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], i = Kd(this._driver, e, n); if (n.length) throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`); this._animations[t] = i } _buildPlayer(t, e, n) { const i = t.element, r = od(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(i, r, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const i = [], r = this._animations[t]; let s; const o = new Map; if (r ? (s = op(this._driver, e, r, "ng-enter", "ng-leave", {}, {}, n, xp, i), s.forEach(t => { const e = hd(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (i.push("The requested animation doesn't exist or has already been destroyed"), s = []), i.length) throw new Error(`Unable to create the animation due to the following errors: ${i.join("\n")}`); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, "*") }) }); const a = sd(s.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, n, i) { const r = cd(e, "", "", ""); return ad(this._getPlayer(t), n, r, i), () => { } } command(t, e, n, i) { if ("register" == n) return void this.register(t, i[0]); if ("create" == n) return void this.create(t, e, i[0] || {}); const r = this._getPlayer(t); switch (n) { case "play": r.play(); break; case "pause": r.pause(); break; case "reset": r.reset(); break; case "restart": r.restart(); break; case "finish": r.finish(); break; case "init": r.init(); break; case "setPosition": r.setPosition(parseFloat(i[0])); break; case "destroy": this.destroy(t) } } } const Sp = [], kp = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, Ep = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class Op { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (i = n ? t.value : t) ? i : null, n) { const e = Ad(t); delete e.value, this.options = e } else this.options = {}; var i; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const Ap = new Op("void"); class Tp { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Fp(e, this._hostClassName) } listen(t, e, n, i) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (r = n) && "done" != r) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var r; const s = hd(this._elementListeners, t, []), o = { name: e, phase: n, callback: i }; s.push(o); const a = hd(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (Fp(t, "ng-trigger"), Fp(t, "ng-trigger-" + e), a[e] = Ap), () => { this._engine.afterFlush(() => { const t = s.indexOf(o); t >= 0 && s.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, i = !0) { const r = this._getTrigger(e), s = new Dp(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (Fp(t, "ng-trigger"), Fp(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new Op(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = Ap), "void" !== l.value && a.value === l.value) { if (!function (t, e) { const n = Object.keys(t), i = Object.keys(e); if (n.length != i.length) return !1; for (let r = 0; r < n.length; r++) { const i = n[r]; if (!e.hasOwnProperty(i) || t[i] !== e[i]) return !1 } return !0 }(a.params, l.params)) { const e = [], n = r.matchStyles(a.value, a.params, e), i = r.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { Rd(t, n), Id(t, i) }) } return } const c = hd(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let h = r.matchTransition(a.value, l.value, t, l.params), u = !1; if (!h) { if (!i) return; h = r.fallbackTransition, u = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: h, fromState: a, toState: l, player: s, isFallbackTransition: u }), u || (Fp(t, "ng-animate-queued"), s.onStart(() => { Np(t, "ng-animate-queued") })), s.onDone(() => { let e = this.players.indexOf(s); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(s); t >= 0 && n.splice(t, 1) } }), this.players.push(s), c.push(s), s } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const n = this._engine.driver.query(t, ".ng-trigger", !0); n.forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => n.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, n, i) { const r = this._engine.statesByElement.get(t); if (r) { const s = []; if (Object.keys(r).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, "void", i); n && s.push(n) } }), s.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && sd(s).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t); if (e) { const n = new Set; e.forEach(e => { const i = e.name; if (n.has(i)) return; n.add(i); const r = this._triggers[i].fallbackTransition, s = this._engine.statesByElement.get(t)[i] || Ap, o = new Op("void"), a = new Dp(this.id, i, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: i, transition: r, fromState: s, toState: o, player: a, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let i = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) i = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { i = !0; break } } } if (this.prepareLeaveAnimationListeners(t), i) n.markElementAsRemoved(this.id, t, !1, e); else { const i = t.__ng_removed; i && i !== kp || (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } } insertNode(t, e) { Fp(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const i = n.player; if (i.destroyed) return; const r = n.element, s = this._elementListeners.get(r); s && s.forEach(e => { if (e.name == n.triggerName) { const i = cd(r, n.triggerName, n.fromState.value, n.toState.value); i._data = t, ad(n.player, e.phase, i, e.callback) } }), i.markedForDestroy ? this._engine.afterFlush(() => { i.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, i = e.transition.ast.depCount; return 0 == n || 0 == i ? n - i : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class Pp { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new Tp(t, e, this); return e.parentNode ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let i = !1; for (let r = n; r >= 0; r--)if (this.driver.containsElement(this._namespaceList[r].hostElement, e)) { this._namespaceList.splice(r + 1, 0, t), i = !0; break } i || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let i = this._namespaceLookup[t]; i && i.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let i = 0; i < t.length; i++) { const r = n[t[i]].namespaceId; if (r) { const t = this._fetchNamespace(r); t && e.add(t) } } } return e } trigger(t, e, n, i) { if (Ip(e)) { const r = this._fetchNamespace(t); if (r) return r.trigger(e, n, i), !0 } return !1 } insertNode(t, e, n, i) { if (!Ip(e)) return; const r = e.__ng_removed; if (r && r.setForRemoval) { r.setForRemoval = !1, r.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const i = this._fetchNamespace(t); i && i.insertNode(e, n) } i && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Fp(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Np(t, "ng-animate-disabled")) } removeNode(t, e, n, i) { if (Ip(e)) { const r = t ? this._fetchNamespace(t) : null; if (r ? r.removeNode(e, i) : this.markElementAsRemoved(t, e, !1, i), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, i) } } else this._onRemovalComplete(e, i) } markElementAsRemoved(t, e, n, i) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: i, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, i, r) { return Ip(e) ? this._fetchNamespace(t).listen(e, n, i, r) : () => { } } _buildInstruction(t, e, n, i, r) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, i, t.fromState.options, t.toState.options, e, r) } destroyInnerAnimations(t) { let e = this.driver.query(t, ".ng-trigger", !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return sd(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = kp, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)Fp(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? sd(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const n = new ip, i = [], r = new Map, s = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const h = this.bodyNode, u = Array.from(this.statesByElement.keys()), d = Lp(u, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = "ng-enter" + f++; p.set(e, n), t.forEach(t => Fp(t, n)) }); const m = [], g = new Set, y = new Set; for (let P = 0; P < this.collectedLeaveElements.length; P++) { const t = this.collectedLeaveElements[P], e = t.__ng_removed; e && e.setForRemoval && (m.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : y.add(t)) } const _ = new Map, v = Lp(u, Array.from(g)); v.forEach((t, e) => { const n = "ng-leave" + f++; _.set(e, n), t.forEach(t => Fp(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => Np(t, n)) }), v.forEach((t, e) => { const n = _.get(e); t.forEach(t => Np(t, n)) }), m.forEach(t => { this.processLeaveNode(t) }) }); const b = [], w = []; for (let P = this._namespaceList.length - 1; P >= 0; P--)this._namespaceList[P].drainQueuedTransitions(e).forEach(t => { const e = t.player, r = t.element; if (b.push(e), this.collectedEnterElements.length) { const t = r.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !h || !this.driver.containsElement(h, r), u = _.get(r), d = p.get(r), f = this._buildInstruction(t, n, d, u, c); if (!f.errors || !f.errors.length) return c || t.isFallbackTransition ? (e.onStart(() => Rd(r, f.fromStyles)), e.onDestroy(() => Id(r, f.toStyles)), void i.push(e)) : (f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(r, f.timelines), s.push({ instruction: f, player: e, element: r }), f.queriedElements.forEach(t => hd(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = a.get(e); t || a.set(e, t = new Set), n.forEach(e => t.add(e)) } }), void f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let i = l.get(e); i || l.set(e, i = new Set), n.forEach(t => i.add(t)) })); w.push(f) }); if (w.length) { const t = []; w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), b.forEach(t => t.destroy()), this.reportError(t) } const x = new Map, C = new Map; s.forEach(t => { const e = t.element; n.has(e) && (C.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, x)) }), i.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { hd(x, e, []).push(t), t.destroy() }) }); const S = m.filter(t => jp(t, a, l)), k = new Map; Mp(k, this.driver, y, l, "*").forEach(t => { jp(t, a, l) && S.push(t) }); const E = new Map; d.forEach((t, e) => { Mp(E, this.driver, new Set(t), a, "!") }), S.forEach(t => { const e = k.get(t), n = E.get(t); k.set(t, Object.assign(Object.assign({}, e), n)) }); const O = [], A = [], T = {}; s.forEach(t => { const { element: e, player: s, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return s.onDestroy(() => Id(e, o.toStyles)), s.disabled = !0, s.overrideTotalTime(o.totalTime), void i.push(s); let t = T; if (C.size > 1) { let n = e; const i = []; for (; n = n.parentNode;) { const e = C.get(n); if (e) { t = e; break } i.push(n) } i.forEach(e => C.set(e, t)) } const n = this._buildAnimation(s.namespaceId, o, x, r, E, k); if (s.setRealPlayer(n), t === T) O.push(s); else { const e = this.playersByElement.get(t); e && e.length && (s.parentPlayer = sd(e)), i.push(s) } } else Rd(e, o.fromStyles), s.onDestroy(() => Id(e, o.toStyles)), A.push(s), c.has(e) && i.push(s) }), A.forEach(t => { const e = r.get(t.element); if (e && e.length) { const n = sd(e); t.setRealPlayer(n) } }), i.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let P = 0; P < m.length; P++) { const t = m[P], e = t.__ng_removed; if (Np(t, "ng-leave"), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let i = this.driver.query(t, ".ng-animating", !0); for (let t = 0; t < i.length; t++) { let e = o.get(i[t]); e && e.length && n.push(...e) } } const i = n.filter(t => !t.destroyed); i.length ? Vp(this, t, i) : this.processLeaveNode(t) } return m.length = 0, O.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), O } elementContainsData(t, e) { let n = !1; const i = e.__ng_removed; return i && i.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, i, r) { let s = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (s = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !r || "void" == r; e.forEach(e => { e.queued || (t || e.triggerName == i) && s.push(e) }) } } return (n || i) && (s = s.filter(t => !(n && n != t.namespaceId || i && i != t.triggerName))), s } _beforeAnimationBuild(t, e, n) { const i = e.element, r = e.isRemovalTransition ? void 0 : t, s = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== i, l = hd(n, t, []); this._getPreviousPlayers(t, a, r, s, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } Rd(i, e.fromStyles) } _buildAnimation(t, e, n, i, r, s) { const o = e.triggerName, a = e.element, l = [], c = new Set, h = new Set, u = e.timelines.map(e => { const u = e.element; c.add(u); const d = u.__ng_removed; if (d && d.removedBeforeQueried) return new nd(e.duration, e.delay); const p = u !== a, f = function (t) { const e = []; return function t(e, n) { for (let i = 0; i < e.length; i++) { const r = e[i]; r instanceof id ? t(r.players, n) : n.push(r) } }(t, e), e }((n.get(u) || Sp).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === u), m = r.get(u), g = s.get(u), y = od(0, this._normalizer, 0, e.keyframes, m, g), _ = this._buildPlayer(e, y, f); if (e.subTimeline && i && h.add(u), p) { const e = new Dp(t, o, u); e.setRealPlayer(_), l.push(e) } return _ }); l.forEach(t => { hd(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let i; if (t instanceof Map) { if (i = t.get(e), i) { if (i.length) { const t = i.indexOf(n); i.splice(t, 1) } 0 == i.length && t.delete(e) } } else if (i = t[e], i) { if (i.length) { const t = i.indexOf(n); i.splice(t, 1) } 0 == i.length && delete t[e] } return i }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => Fp(t, "ng-animating")); const d = sd(u); return d.onDestroy(() => { c.forEach(t => Np(t, "ng-animating")), Id(a, e.toStyles) }), h.forEach(t => { hd(i, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new nd(t.duration, t.delay) } } class Dp { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new nd, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => ad(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { hd(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Ip(t) { return t && 1 === t.nodeType } function Rp(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function Mp(t, e, n, i, r) { const s = []; n.forEach(t => s.push(Rp(t))); const o = []; i.forEach((n, i) => { const s = {}; n.forEach(t => { const n = s[t] = e.computeStyle(i, t, r); n && 0 != n.length || (i.__ng_removed = Ep, o.push(i)) }), t.set(i, s) }); let a = 0; return n.forEach(t => Rp(t, s[a++])), o } function Lp(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const i = new Set(e), r = new Map; return e.forEach(t => { const e = function t(e) { if (!e) return 1; let s = r.get(e); if (s) return s; const o = e.parentNode; return s = n.has(o) ? o : i.has(o) ? 1 : t(o), r.set(e, s), s }(t); 1 !== e && n.get(e).push(t) }), n } function Fp(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function Np(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function Vp(t, e, n) { sd(n).onDone(() => t.processLeaveNode(e)) } function jp(t, e, n) { const i = n.get(t); if (!i) return !1; let r = e.get(t); return r ? i.forEach(t => r.add(t)) : e.set(t, i), n.delete(t), !0 } class Bp { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new Pp(t, e, n), this._timelineEngine = new Cp(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, i, r) { const s = t + "-" + i; let o = this._triggerCache[s]; if (!o) { const t = [], e = Kd(this._driver, r, t); if (t.length) throw new Error(`The animation trigger "${i}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new bp(t, e) }(i, e), this._triggerCache[s] = o } this._transitionEngine.registerTrigger(e, i, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, i) { this._transitionEngine.insertNode(t, e, n, i) } onRemove(t, e, n, i) { this._transitionEngine.removeNode(t, e, i || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, i) { if ("@" == n.charAt(0)) { const [t, r] = ud(n); this._timelineEngine.command(t, e, r, i) } else this._transitionEngine.trigger(t, e, n, i) } listen(t, e, n, i, r) { if ("@" == n.charAt(0)) { const [t, i] = ud(n); return this._timelineEngine.listen(t, e, i, r) } return this._transitionEngine.listen(t, e, n, i, r) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function zp(t, e) { let n = null, i = null; return Array.isArray(e) && e.length ? (n = Up(e[0]), e.length > 1 && (i = Up(e[e.length - 1]))) : e && (n = Up(e)), n || i ? new Hp(t, n, i) : null } let Hp = (() => { class t { constructor(e, n, i) { this._element = e, this._startStyles = n, this._endStyles = i, this._state = 0; let r = t.initialStylesByElement.get(e); r || t.initialStylesByElement.set(e, r = {}), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && Id(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Id(this._element, this._initialStyles), this._endStyles && (Id(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Rd(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Rd(this._element, this._endStyles), this._endStyles = null), Id(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function Up(t) { let e = null; const n = Object.keys(t); for (let i = 0; i < n.length; i++) { const r = n[i]; $p(r) && (e = e || {}, e[r] = t[r]) } return e } function $p(t) { return "display" === t || "position" === t } class qp { constructor(t, e, n, i, r, s, o) { this._element = t, this._name = e, this._duration = n, this._delay = i, this._easing = r, this._fillMode = s, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = Qp(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let i = 0; i < t.length; i++)"," === t.charAt(i) && n++ }(n), e = `${n}, ${e}`), Kp(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Xp(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Wp(this._element, this._name, "paused") } resume() { Wp(this._element, this._name, "running") } setPosition(t) { const e = Gp(this._element, this._name); this._position = t * this._duration, Kp(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), Xp(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = Qp(t, "").split(","), i = Yp(n, e); i >= 0 && (n.splice(i, 1), Kp(t, "", n.join(","))) }(this._element, this._name)) } } function Wp(t, e, n) { Kp(t, "PlayState", n, Gp(t, e)) } function Gp(t, e) { const n = Qp(t, ""); return n.indexOf(",") > 0 ? Yp(n.split(","), e) : Yp([n], e) } function Yp(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function Xp(t, e, n) { n ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e) } function Kp(t, e, n, i) { const r = "animation" + e; if (null != i) { const e = t.style[r]; if (e.length) { const t = e.split(","); t[i] = n, n = t.join(",") } } t.style[r] = n } function Qp(t, e) { return t.style["animation" + e] } class Zp { constructor(t, e, n, i, r, s, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = i, this._delay = r, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = s || "linear", this.totalTime = i + r, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new qp(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : $d(this.element, n)) }) } this.currentSnapshot = t } } class Jp extends nd { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = xd(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class tf { constructor() { this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1 } validateStyleProperty(t) { return _d(t) } matchesElement(t, e) { return vd(t, e) } containsElement(t, e) { return bd(t, e) } query(t, e, n) { return wd(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => xd(t)); let i = `@keyframes ${e} {\n`, r = ""; n.forEach(t => { r = " "; const e = parseFloat(t.offset); i += `${r}${100 * e}% {\n`, r += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (i += `${r}animation-timing-function: ${n};\n`)); default: return void (i += `${r}${e}: ${n};\n`) } }), i += `${r}}\n` }), i += "}\n"; const s = document.createElement("style"); return s.innerHTML = i, s } animate(t, e, n, i, r, s = [], o) { o && this._notifyFaultyScrubber(); const a = s.filter(t => t instanceof Zp), l = {}; zd(n, i) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = Hd(t, e, l)); if (0 == n) return new Jp(t, c); const h = `gen_css_kf_${this._count++}`, u = this.buildKeyframeElement(t, h, e); document.querySelector("head").appendChild(u); const d = zp(t, e), p = new Zp(t, e, h, n, i, r, c, d); return p.onDestroy(() => { var t; (t = u).parentNode.removeChild(t) }), p } _notifyFaultyScrubber() { this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), this._warningIssued = !0) } } class ef { constructor(t, e, n, i) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : $d(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class nf { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(rf().toString()), this._cssKeyframesDriver = new tf } validateStyleProperty(t) { return _d(t) } matchesElement(t, e) { return vd(t, e) } containsElement(t, e) { return bd(t, e) } query(t, e, n) { return wd(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, i, r, s = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, i, r, s); const a = { duration: n, delay: i, fill: 0 == i ? "both" : "forwards" }; r && (a.easing = r); const l = {}, c = s.filter(t => t instanceof ef); zd(n, i) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const h = zp(t, e = Hd(t, e = e.map(t => Td(t, !1)), l)); return new ef(t, e, a, h) } } function rf() { return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {} } let sf = (() => { class t extends $u { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: ue.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? Yu(t) : t; return lf(this._renderer, null, e, "register", [n]), new of(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(qa), Kt(ph)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class of extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new af(this._id, t, e || {}, this._renderer) } } class af { constructor(t, e, n, i) { this.id = t, this.element = e, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return lf(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset") } setPosition(t) { this._command("setPosition", t) } getPosition() { return 0 } } function lf(t, e, n, i, r) { return t.setProperty(e, `@@${n}:${i}`, r) } let cf = (() => { class t { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new hf("", n, this.engine), this._rendererCache.set(n, t)), t } const i = e.id, r = e.id + "-" + this._currentId; this._currentId++, this.engine.register(r, t); const s = e => { Array.isArray(e) ? e.forEach(s) : this.engine.registerTrigger(i, r, t, e.name, e) }; return e.data.animation.forEach(s), new uf(this, r, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(Kt(qa), Kt(Bp), Kt(Lc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class hf { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, !0) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, i) { this.delegate.setAttribute(t, e, n, i) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, i) { this.delegate.setStyle(t, e, n, i) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class uf extends hf { constructor(t, e, n, i) { super(e, n, i), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("@" == e.charAt(0)) { const i = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let r = e.substr(1), s = ""; return "@" != r.charAt(0) && ([r, s] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(r)), this.engine.listen(this.namespaceId, i, r, s, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let df = (() => { class t extends Bp { constructor(t, e, n) { super(t.body, e, n) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph), Kt(Sd), Kt(pp)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const pf = new Bt("AnimationModuleType"), ff = [{ provide: Sd, useFactory: function () { return "function" == typeof rf() ? new nf : new tf } }, { provide: pf, useValue: "BrowserAnimations" }, { provide: $u, useClass: sf }, { provide: pp, useFactory: function () { return new fp } }, { provide: Bp, useClass: df }, { provide: qa, useFactory: function (t, e, n) { return new cf(t, e, n) }, deps: [Ou, Bp, Lc] }]; let mf = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: ff, imports: [zu] }), t })(); function gf(...t) { let e = t[t.length - 1]; return O(e) ? (t.pop(), B(t, e)) : W(t) } class yf extends k { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new x; return this._value } next(t) { super.next(this._value = t) } } const _f = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(), vf = {}; function bf(...t) { let e = null, n = null; return O(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), W(t, n).lift(new wf(e)) } class wf { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new xf(t, this.resultSelector)) } } class xf extends F { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(vf), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++) { const e = t[n]; this.add(L(this, e, e, n)) } } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n, i, r) { const s = this.values, o = this.toRespond ? s[n] === vf ? --this.toRespond : this.toRespond : 0; s[n] = e, 0 === o && (this.resultSelector ? this._tryResultSelector(s) : this.destination.next(s.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const Cf = new b(t => t.complete()); function Sf(t) { return t ? function (t) { return new b(e => t.schedule(() => e.complete())) }(t) : Cf } function kf(t) { return new b(e => { let n; try { n = t() } catch (i) { return void e.error(i) } return (n ? z(n) : Sf()).subscribe(e) }) } function Ef() { return q(1) } function Of(t, e) { return function (n) { return n.lift(new Af(t, e)) } } class Af { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new Tf(t, this.predicate, this.thisArg)) } } class Tf extends f { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } const Pf = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })(); function Df(t) { return function (e) { return 0 === t ? Sf() : e.lift(new If(t)) } } class If { constructor(t) { if (this.total = t, this.total < 0) throw new Pf } call(t, e) { return e.subscribe(new Rf(t, this.total)) } } class Rf extends f { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, i = this.count++; e.length < n ? e.push(t) : e[i % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, i = this.ring; for (let r = 0; r < n; r++) { const r = e++ % n; t.next(i[r]) } } t.complete() } } function Mf(t = Nf) { return e => e.lift(new Lf(t)) } class Lf { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new Ff(t, this.errorFactory)) } } class Ff extends f { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function Nf() { return new _f } function Vf(t = null) { return e => e.lift(new jf(t)) } class jf { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new Bf(t, this.defaultValue)) } } class Bf extends f { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function zf(t, e) { const n = arguments.length >= 2; return i => i.pipe(t ? Of((e, n) => t(e, n, i)) : y, Df(1), n ? Vf(e) : Mf(() => new _f)) } function Hf(t) { return function (e) { const n = new Uf(t), i = e.lift(n); return n.caught = i } } class Uf { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new $f(t, this.selector, this.caught)) } } class $f extends F { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const i = new A(this, void 0, void 0); this.add(i); const r = L(this, n, void 0, void 0, i); r !== i && this.add(r) } } } function qf(t) { return e => 0 === t ? Sf() : e.lift(new Wf(t)) } class Wf { constructor(t) { if (this.total = t, this.total < 0) throw new Pf } call(t, e) { return e.subscribe(new Gf(t, this.total)) } } class Gf extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function Yf(t, e) { const n = arguments.length >= 2; return i => i.pipe(t ? Of((e, n) => t(e, n, i)) : y, qf(1), n ? Vf(e) : Mf(() => new _f)) } class Xf { constructor(t, e, n) { this.predicate = t, this.thisArg = e, this.source = n } call(t, e) { return e.subscribe(new Kf(t, this.predicate, this.thisArg, this.source)) } } class Kf extends f { constructor(t, e, n, i) { super(t), this.predicate = e, this.thisArg = n, this.source = i, this.index = 0, this.thisArg = n || this } notifyComplete(t) { this.destination.next(t), this.destination.complete() } _next(t) { let e = !1; try { e = this.predicate.call(this.thisArg, t, this.index++, this.source) } catch (n) { return void this.destination.error(n) } e || this.notifyComplete(!1) } _complete() { this.notifyComplete(!0) } } function Qf(t, e) { return "function" == typeof e ? n => n.pipe(Qf((n, i) => z(t(n, i)).pipe(N((t, r) => e(n, t, i, r))))) : e => e.lift(new Zf(t)) } class Zf { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new Jf(t, this.project)) } } class Jf extends F { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (i) { return void this.destination.error(i) } this._innerSub(e, t, n) } _innerSub(t, e, n) { const i = this.innerSubscription; i && i.unsubscribe(); const r = new A(this, e, n), s = this.destination; s.add(r), this.innerSubscription = L(this, t, void 0, void 0, r), this.innerSubscription !== r && s.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = null } notifyComplete(t) { this.destination.remove(t), this.innerSubscription = null, this.isStopped && super._complete() } notifyNext(t, e, n, i, r) { this.destination.next(e) } } function tm(...t) { return Ef()(gf(...t)) } function em(...t) { const e = t[t.length - 1]; return O(e) ? (t.pop(), n => tm(t, n, e)) : e => tm(t, e) } function nm(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (i) { return i.lift(new im(t, e, n)) } } class im { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new rm(t, this.accumulator, this.seed, this.hasSeed)) } } class rm extends f { constructor(t, e, n, i) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = i, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (i) { this.destination.error(i) } this.seed = n, this.destination.next(n) } } function sm(t, e) { return H(t, e, 1) } function om() { } function am(t, e, n) { return function (i) { return i.lift(new lm(t, e, n)) } } class lm { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new cm(t, this.nextOrObserver, this.error, this.complete)) } } class cm extends f { constructor(t, e, n, r) { super(t), this._tapNext = om, this._tapError = om, this._tapComplete = om, this._tapError = n || om, this._tapComplete = r || om, i(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || om, this._tapError = e.error || om, this._tapComplete = e.complete || om) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } class hm { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new um(t, this.callback)) } } class um extends f { constructor(t, e) { super(t), this.add(new u(e)) } } class dm { constructor(t, e) { this.id = t, this.url = e } } class pm extends dm { constructor(t, e, n = "imperative", i = null) { super(t, e), this.navigationTrigger = n, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class fm extends dm { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class mm extends dm { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class gm extends dm { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class ym extends dm { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class _m extends dm { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class vm extends dm { constructor(t, e, n, i, r) { super(t, e), this.urlAfterRedirects = n, this.state = i, this.shouldActivate = r } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class bm extends dm { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class wm extends dm { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class xm { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Cm { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Sm { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class km { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Em { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Om { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Am { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } let Tm = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = me({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Lo(0, "router-outlet") }, directives: function () { return [Ry] }, encapsulation: 2 }), t })(); class Pm { constructor(t) { this.params = t || {} } has(t) { return this.params.hasOwnProperty(t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Dm(t) { return new Pm(t) } function Im(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function Rm(t, e, n) { const i = n.path.split("/"); if (i.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || i.length < t.length)) return null; const r = {}; for (let s = 0; s < i.length; s++) { const e = i[s], n = t[s]; if (e.startsWith(":")) r[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, i.length), posParams: r } } class Mm { constructor(t, e) { this.routes = t, this.module = e } } function Lm(t, e = "") { for (let n = 0; n < t.length; n++) { const i = t[n]; Fm(i, Nm(e, i)) } } function Fm(t, e) { if (!t) throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `); if (Array.isArray(t)) throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`); if (!t.component && !t.children && !t.loadChildren && t.outlet && "primary" !== t.outlet) throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`); if (t.redirectTo && t.children) throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`); if (t.redirectTo && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`); if (t.children && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`); if (t.redirectTo && t.component) throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`); if (t.path && t.matcher) throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`); if (void 0 === t.redirectTo && !t.component && !t.children && !t.loadChildren) throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`); if (void 0 === t.path && void 0 === t.matcher) throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`); if ("string" == typeof t.path && "/" === t.path.charAt(0)) throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`); if ("" === t.path && void 0 !== t.redirectTo && void 0 === t.pathMatch) throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`); if (void 0 !== t.pathMatch && "full" !== t.pathMatch && "prefix" !== t.pathMatch) throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`); t.children && Lm(t.children, e) } function Nm(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Vm(t) { const e = t.children && t.children.map(Vm), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && "primary" !== n.outlet && (n.component = Tm), n } function jm(t, e) { const n = Object.keys(t), i = Object.keys(e); if (!n || !i || n.length != i.length) return !1; let r; for (let s = 0; s < n.length; s++)if (r = n[s], !Bm(t[r], e[r])) return !1; return !0 } function Bm(t, e) { return Array.isArray(t) && Array.isArray(e) ? t.length == e.length && t.every(t => e.indexOf(t) > -1) : t === e } function zm(t) { return Array.prototype.concat.apply([], t) } function Hm(t) { return t.length > 0 ? t[t.length - 1] : null } function Um(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function $m(t) { return zo(t) ? t : Bo(t) ? z(Promise.resolve(t)) : gf(t) } function qm(t, e, n) { return n ? function (t, e) { return jm(t, e) }(t.queryParams, e.queryParams) && function t(e, n) { if (!Xm(e.segments, n.segments)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const i in n.children) { if (!e.children[i]) return !1; if (!t(e.children[i], n.children[i])) return !1 } return !0 }(t.root, e.root) : function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => Bm(t[n], e[n])) }(t.queryParams, e.queryParams) && function t(e, n) { return function e(n, i, r) { if (n.segments.length > r.length) return !!Xm(n.segments.slice(0, r.length), r) && !i.hasChildren(); if (n.segments.length === r.length) { if (!Xm(n.segments, r)) return !1; for (const e in i.children) { if (!n.children[e]) return !1; if (!t(n.children[e], i.children[e])) return !1 } return !0 } { const t = r.slice(0, n.segments.length), s = r.slice(n.segments.length); return !!Xm(n.segments, t) && !!n.children.primary && e(n.children.primary, i, s) } }(e, n, n.segments) }(t.root, e.root) } class Wm { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Dm(this.queryParams)), this._queryParamMap } toString() { return Jm.serialize(this) } } class Gm { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, Um(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return tg(this) } } class Ym { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Dm(this.parameters)), this._parameterMap } toString() { return og(this) } } function Xm(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } function Km(t, e) { let n = []; return Um(t.children, (t, i) => { "primary" === i && (n = n.concat(e(t, i))) }), Um(t.children, (t, i) => { "primary" !== i && (n = n.concat(e(t, i))) }), n } class Qm { } class Zm { parse(t) { const e = new ug(t); return new Wm(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `${`/${function t(e, n) { if (!e.hasChildren()) return tg(e); if (n) { const n = e.children.primary ? t(e.children.primary, !1) : "", i = []; return Um(e.children, (e, n) => { "primary" !== n && i.push(`${n}:${t(e, !1)}`) }), i.length > 0 ? `${n}(${i.join("//")})` : n } { const n = Km(e, (n, i) => "primary" === i ? [t(e.children.primary, !1)] : [`${i}:${t(n, !1)}`]); return `${tg(e)}/(${n.join("//")})` } }(t.root, !0)}`}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${ng(e)}=${ng(t)}`).join("&") : `${ng(e)}=${ng(n)}` }); return e.length ? `?${e.join("&")}` : "" }(t.queryParams)}${"string" == typeof t.fragment ? `#${e = t.fragment, encodeURI(e)}` : ""}` } } const Jm = new Zm; function tg(t) { return t.segments.map(t => og(t)).join("/") } function eg(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function ng(t) { return eg(t).replace(/%3B/gi, ";") } function ig(t) { return eg(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function rg(t) { return decodeURIComponent(t) } function sg(t) { return rg(t.replace(/\+/g, "%20")) } function og(t) { return `${ig(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${ig(t)}=${ig(e[t])}`).join("")}`; var e } const ag = /^[^\/()?;=#]+/; function lg(t) { const e = t.match(ag); return e ? e[0] : "" } const cg = /^[^=?&#]+/, hg = /^[^?&#]+/; class ug { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Gm([], {}) : new Gm([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new Gm(t, e)), n } parseSegment() { const t = lg(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new Ym(rg(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = lg(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = lg(this.remaining); t && (n = t, this.capture(n)) } t[rg(e)] = rg(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(cg); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(hg); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const i = sg(e), r = sg(n); if (t.hasOwnProperty(i)) { let e = t[i]; Array.isArray(e) || (e = [e], t[i] = e), e.push(r) } else t[i] = r } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = lg(this.remaining), i = this.remaining[n.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new Error(`Cannot parse url '${this.url}'`); let r = void 0; n.indexOf(":") > -1 ? (r = n.substr(0, n.indexOf(":")), this.capture(r), this.capture(":")) : t && (r = "primary"); const s = this.parseChildren(); e[r] = 1 === Object.keys(s).length ? s.primary : new Gm([], s), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class dg { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = pg(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = pg(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = fg(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return fg(t, this._root).map(t => t.value) } } function pg(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = pg(t, n); if (e) return e } return null } function fg(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const i = fg(t, n); if (i.length) return i.unshift(e), i } return [] } class mg { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function gg(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class yg extends dg { constructor(t, e) { super(t), this.snapshot = e, Cg(this, t) } toString() { return this.snapshot.toString() } } function _g(t, e) { const n = function (t, e) { const n = new wg([], {}, {}, "", {}, "primary", e, null, t.root, -1, {}); return new xg("", new mg(n, [])) }(t, e), i = new yf([new Ym("", {})]), r = new yf({}), s = new yf({}), o = new yf({}), a = new yf(""), l = new vg(i, r, o, a, s, "primary", e, n.root); return l.snapshot = n.root, new yg(new mg(l, []), n) } class vg { constructor(t, e, n, i, r, s, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = i, this.data = r, this.outlet = s, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(N(t => Dm(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(N(t => Dm(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function bg(t, e = "emptyOnly") { const n = t.pathFromRoot; let i = 0; if ("always" !== e) for (i = n.length - 1; i >= 1;) { const t = n[i], e = n[i - 1]; if (t.routeConfig && "" === t.routeConfig.path) i--; else { if (e.component) break; i-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(i)) } class wg { constructor(t, e, n, i, r, s, o, a, l, c, h) { this.url = t, this.params = e, this.queryParams = n, this.fragment = i, this.data = r, this.outlet = s, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = h } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Dm(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Dm(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class xg extends dg { constructor(t, e) { super(e), this.url = t, Cg(this, e) } toString() { return Sg(this._root) } } function Cg(t, e) { e.value._routerState = t, e.children.forEach(e => Cg(t, e)) } function Sg(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Sg).join(", ")} } ` : ""; return `${t.value}${e}` } function kg(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, jm(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), jm(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!jm(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), jm(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function Eg(t, e) { var n, i; return jm(t.params, e.params) && Xm(n = t.url, i = e.url) && n.every((t, e) => jm(t.parameters, i[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Eg(t.parent, e.parent)) } function Og(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Ag(t, e, n, i, r) { let s = {}; return i && Um(i, (t, e) => { s[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new Wm(n.root === t ? e : function t(e, n, i) { const r = {}; return Um(e.children, (e, s) => { r[s] = e === n ? i : t(e, n, i) }), new Gm(e.segments, r) }(n.root, t, e), s, r) } class Tg { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && Og(n[0])) throw new Error("Root segment cannot have matrix parameters"); const i = n.find(t => "object" == typeof t && null != t && t.outlets); if (i && i !== Hm(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Pg { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function Dg(t) { return "object" == typeof t && null != t && t.outlets ? t.outlets.primary : `${t}` } function Ig(t, e, n) { if (t || (t = new Gm([], {})), 0 === t.segments.length && t.hasChildren()) return Rg(t, e, n); const i = function (t, e, n) { let i = 0, r = e; const s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; r < t.segments.length;) { if (i >= n.length) return s; const e = t.segments[r], o = Dg(n[i]), a = i < n.length - 1 ? n[i + 1] : null; if (r > 0 && void 0 === o) break; if (o && a && "object" == typeof a && void 0 === a.outlets) { if (!Ng(o, a, e)) return s; i += 2 } else { if (!Ng(o, {}, e)) return s; i++ } r++ } return { match: !0, pathIndex: r, commandIndex: i } }(t, e, n), r = n.slice(i.commandIndex); if (i.match && i.pathIndex < t.segments.length) { const e = new Gm(t.segments.slice(0, i.pathIndex), {}); return e.children.primary = new Gm(t.segments.slice(i.pathIndex), t.children), Rg(e, 0, r) } return i.match && 0 === r.length ? new Gm(t.segments, {}) : i.match && !t.hasChildren() ? Mg(t, e, n) : i.match ? Rg(t, 0, r) : Mg(t, e, n) } function Rg(t, e, n) { if (0 === n.length) return new Gm(t.segments, {}); { const i = function (t) { return "object" != typeof t[0] || void 0 === t[0].outlets ? { primary: t } : t[0].outlets }(n), r = {}; return Um(i, (n, i) => { null !== n && (r[i] = Ig(t.children[i], e, n)) }), Um(t.children, (t, e) => { void 0 === i[e] && (r[e] = t) }), new Gm(t.segments, r) } } function Mg(t, e, n) { const i = t.segments.slice(0, e); let r = 0; for (; r < n.length;) { if ("object" == typeof n[r] && void 0 !== n[r].outlets) { const t = Lg(n[r].outlets); return new Gm(i, t) } if (0 === r && Og(n[0])) { i.push(new Ym(t.segments[e].path, n[0])), r++; continue } const s = Dg(n[r]), o = r < n.length - 1 ? n[r + 1] : null; s && o && Og(o) ? (i.push(new Ym(s, Fg(o))), r += 2) : (i.push(new Ym(s, {})), r++) } return new Gm(i, {}) } function Lg(t) { const e = {}; return Um(t, (t, n) => { null !== t && (e[n] = Mg(new Gm([], {}), 0, t)) }), e } function Fg(t) { const e = {}; return Um(t, (t, n) => e[n] = `${t}`), e } function Ng(t, e, n) { return t == n.path && jm(e, n.parameters) } class Vg { constructor(t, e, n, i) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = i } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), kg(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const i = gg(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, i[e], n), delete i[e] }), Um(i, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const i = t.value, r = e ? e.value : null; if (i === r) if (i.component) { const r = n.getContext(i.outlet); r && this.deactivateChildRoutes(t, e, r.children) } else this.deactivateChildRoutes(t, e, n); else r && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), i = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: i }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet); if (n) { const i = gg(t), r = t.value.component ? n.children : e; Um(i, (t, e) => this.deactivateRouteAndItsChildren(t, r)), n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()) } } activateChildRoutes(t, e, n) { const i = gg(e); t.children.forEach(t => { this.activateRoutes(t, i[t.value.outlet], n), this.forwardEvent(new Om(t.value.snapshot)) }), t.children.length && this.forwardEvent(new km(t.value.snapshot)) } activateRoutes(t, e, n) { const i = t.value, r = e ? e.value : null; if (kg(i), i === r) if (i.component) { const r = n.getOrCreateContext(i.outlet); this.activateChildRoutes(t, e, r.children) } else this.activateChildRoutes(t, e, n); else if (i.component) { const e = n.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const t = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), jg(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(i.snapshot), r = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = i, e.resolver = r, e.outlet && e.outlet.activateWith(i, r), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function jg(t) { kg(t.value), t.children.forEach(jg) } function Bg(t) { return "function" == typeof t } function zg(t) { return t instanceof Wm } class Hg { constructor(t) { this.segmentGroup = t || null } } class Ug { constructor(t) { this.urlTree = t } } function $g(t) { return new b(e => e.error(new Hg(t))) } function qg(t) { return new b(e => e.error(new Ug(t))) } function Wg(t) { return new b(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class Gg { constructor(t, e, n, i, r) { this.configLoader = e, this.urlSerializer = n, this.urlTree = i, this.config = r, this.allowRedirects = !0, this.ngModule = t.get(ee) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, "primary").pipe(N(t => this.createUrlTree(t, this.urlTree.queryParams, this.urlTree.fragment))).pipe(Hf(t => { if (t instanceof Ug) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof Hg) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, "primary").pipe(N(e => this.createUrlTree(e, t.queryParams, t.fragment))).pipe(Hf(t => { if (t instanceof Hg) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const i = t.segments.length > 0 ? new Gm([], { primary: t }) : t; return new Wm(i, e, n) } expandSegmentGroup(t, e, n, i) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(N(t => new Gm([], t))) : this.expandSegment(t, n, e, n.segments, i, !0) } expandChildren(t, e, n) { return function (t, e) { if (0 === Object.keys(t).length) return gf({}); const n = [], i = [], r = {}; return Um(t, (t, s) => { const o = e(s, t).pipe(N(t => r[s] = t)); "primary" === s ? n.push(o) : i.push(o) }), gf.apply(null, n.concat(i)).pipe(Ef(), zf(), N(() => r)) }(n.children, (n, i) => this.expandSegmentGroup(t, e, i, n)) } expandSegment(t, e, n, i, r, s) { return gf(...n).pipe(N(o => this.expandSegmentAgainstRoute(t, e, n, o, i, r, s).pipe(Hf(t => { if (t instanceof Hg) return gf(null); throw t }))), Ef(), Yf(t => !!t), Hf((t, n) => { if (t instanceof _f || "EmptyError" === t.name) { if (this.noLeftoversInUrl(e, i, r)) return gf(new Gm([], {})); throw new Hg(e) } throw t })) } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } expandSegmentAgainstRoute(t, e, n, i, r, s, o) { return Qg(i) !== s ? $g(e) : void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(t, e, i, r) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) : $g(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, i, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, i) { const r = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? qg(r) : this.lineralizeSegments(n, r).pipe(H(n => { const r = new Gm(n, {}); return this.expandSegment(t, r, e, n, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = Yg(e, i, r); if (!o) return $g(e); const h = this.applyRedirectCommands(a, i.redirectTo, c); return i.redirectTo.startsWith("/") ? qg(h) : this.lineralizeSegments(i, h).pipe(H(i => this.expandSegment(t, e, n, i.concat(r.slice(l)), s, !1))) } matchSegmentAgainstRoute(t, e, n, i) { if ("**" === n.path) return n.loadChildren ? this.configLoader.load(t.injector, n).pipe(N(t => (n._loadedConfig = t, new Gm(i, {})))) : gf(new Gm(i, {})); const { matched: r, consumedSegments: s, lastChild: o } = Yg(e, n, i); if (!r) return $g(e); const a = i.slice(o); return this.getChildConfig(t, n, i).pipe(H(t => { const n = t.module, i = t.routes, { segmentGroup: r, slicedSegments: o } = function (t, e, n, i) { return n.length > 0 && function (t, e, n) { return n.some(n => Kg(t, e, n) && "primary" !== Qg(n)) }(t, n, i) ? { segmentGroup: Xg(new Gm(e, function (t, e) { const n = {}; n.primary = e; for (const i of t) "" === i.path && "primary" !== Qg(i) && (n[Qg(i)] = new Gm([], {})); return n }(i, new Gm(n, t.children)))), slicedSegments: [] } : 0 === n.length && function (t, e, n) { return n.some(n => Kg(t, e, n)) }(t, n, i) ? { segmentGroup: Xg(new Gm(t.segments, function (t, e, n, i) { const r = {}; for (const s of n) Kg(t, e, s) && !i[Qg(s)] && (r[Qg(s)] = new Gm([], {})); return Object.assign(Object.assign({}, i), r) }(t, n, i, t.children))), slicedSegments: n } : { segmentGroup: t, slicedSegments: n } }(e, s, a, i); return 0 === o.length && r.hasChildren() ? this.expandChildren(n, i, r).pipe(N(t => new Gm(s, t))) : 0 === i.length && 0 === o.length ? gf(new Gm(s, {})) : this.expandSegment(n, r, i, o, "primary", !0).pipe(N(t => new Gm(s.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? gf(new Mm(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? gf(e._loadedConfig) : function (t, e, n) { const i = e.canLoad; return i && 0 !== i.length ? z(i).pipe(N(i => { const r = t.get(i); let s; if (function (t) { return t && Bg(t.canLoad) }(r)) s = r.canLoad(e, n); else { if (!Bg(r)) throw new Error("Invalid CanLoad guard"); s = r(e, n) } return $m(s) })).pipe(Ef(), (r = t => !0 === t, t => t.lift(new Xf(r, void 0, t)))) : gf(!0); var r }(t.injector, e, n).pipe(H(n => n ? this.configLoader.load(t.injector, e).pipe(N(t => (e._loadedConfig = t, t))) : function (t) { return new b(e => e.error(Im(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : gf(new Mm([], t)) } lineralizeSegments(t, e) { let n = [], i = e.root; for (; ;) { if (n = n.concat(i.segments), 0 === i.numberOfChildren) return gf(n); if (i.numberOfChildren > 1 || !i.children.primary) return Wg(t.redirectTo); i = i.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, i) { const r = this.createSegmentGroup(t, e.root, n, i); return new Wm(r, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return Um(t, (t, i) => { if ("string" == typeof t && t.startsWith(":")) { const r = t.substring(1); n[i] = e[r] } else n[i] = t }), n } createSegmentGroup(t, e, n, i) { const r = this.createSegments(t, e.segments, n, i); let s = {}; return Um(e.children, (e, r) => { s[r] = this.createSegmentGroup(t, e, n, i) }), new Gm(r, s) } createSegments(t, e, n, i) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, i) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const i = n[e.path.substring(1)]; if (!i) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return i } findOrReturn(t, e) { let n = 0; for (const i of e) { if (i.path === t.path) return e.splice(n), i; n++ } return t } } function Yg(t, e, n) { if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const i = (e.matcher || Rm)(n, t, e); return i ? { matched: !0, consumedSegments: i.consumed, lastChild: i.consumed.length, positionalParamSegments: i.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } } function Xg(t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new Gm(t.segments.concat(e.segments), e.children) } return t } function Kg(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 !== n.redirectTo } function Qg(t) { return t.outlet || "primary" } class Zg { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Jg { constructor(t, e) { this.component = t, this.route = e } } function ty(t, e, n) { const i = t._root; return function t(e, n, i, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = gg(n); return e.children.forEach(e => { !function (e, n, i, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, a = n ? n.value : null, l = i ? i.getContext(e.value.outlet) : null; if (a && o.routeConfig === a.routeConfig) { const c = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !Xm(t.url, e.url); case "pathParamsOrQueryParamsChange": return !Xm(t.url, e.url) || !jm(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Eg(t, e) || !jm(t.queryParams, e.queryParams); case "paramsChange": default: return !Eg(t, e) } }(a, o, o.routeConfig.runGuardsAndResolvers); c ? s.canActivateChecks.push(new Zg(r)) : (o.data = a.data, o._resolvedData = a._resolvedData), t(e, n, o.component ? l ? l.children : null : i, r, s), c && s.canDeactivateChecks.push(new Jg(l && l.outlet && l.outlet.component || null, a)) } else a && ny(n, l, s), s.canActivateChecks.push(new Zg(r)), t(e, null, o.component ? l ? l.children : null : i, r, s) }(e, o[e.value.outlet], i, r.concat([e.value]), s), delete o[e.value.outlet] }), Um(o, (t, e) => ny(t, i.getContext(e), s)), s }(i, e ? e._root : null, n, [i.value]) } function ey(t, e, n) { const i = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (i ? i.module.injector : n).get(t) } function ny(t, e, n) { const i = gg(t), r = t.value; Um(i, (t, i) => { ny(t, r.component ? e ? e.children.getContext(i) : null : e, n) }), n.canDeactivateChecks.push(new Jg(r.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, r)) } const iy = Symbol("INITIAL_VALUE"); function ry() { return Qf(t => bf(...t.map(t => t.pipe(qf(1), em(iy)))).pipe(nm((t, e) => { let n = !1; return e.reduce((t, i, r) => { if (t !== iy) return t; if (i === iy && (n = !0), !n) { if (!1 === i) return i; if (r === e.length - 1 || zg(i)) return i } return t }, t) }, iy), Of(t => t !== iy), N(t => zg(t) ? t : !0 === t), qf(1))) } function sy(t, e) { return null !== t && e && e(new Em(t)), gf(!0) } function oy(t, e) { return null !== t && e && e(new Sm(t)), gf(!0) } function ay(t, e, n) { const i = e.routeConfig ? e.routeConfig.canActivate : null; return i && 0 !== i.length ? gf(i.map(i => kf(() => { const r = ey(i, e, n); let s; if (function (t) { return t && Bg(t.canActivate) }(r)) s = $m(r.canActivate(e, t)); else { if (!Bg(r)) throw new Error("Invalid CanActivate guard"); s = $m(r(e, t)) } return s.pipe(Yf()) }))).pipe(ry()) : gf(!0) } function ly(t, e, n) { const i = e[e.length - 1], r = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => kf(() => gf(e.guards.map(r => { const s = ey(r, e.node, n); let o; if (function (t) { return t && Bg(t.canActivateChild) }(s)) o = $m(s.canActivateChild(i, t)); else { if (!Bg(s)) throw new Error("Invalid CanActivateChild guard"); o = $m(s(i, t)) } return o.pipe(Yf()) })).pipe(ry()))); return gf(r).pipe(ry()) } class cy { } class hy { constructor(t, e, n, i, r, s) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = i, this.paramsInheritanceStrategy = r, this.relativeLinkResolution = s } recognize() { try { const t = py(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, "primary"), n = new wg([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}), i = new mg(n, e), r = new xg(this.url, i); return this.inheritParamsAndData(r._root), gf(r) } catch (t) { return new b(e => e.error(t)) } } inheritParamsAndData(t) { const e = t.value, n = bg(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = Km(e, (e, n) => this.processSegmentGroup(t, e, n)); return function (t) { const e = {}; t.forEach(t => { const n = e[t.value.outlet]; if (n) { const e = n.url.map(t => t.toString()).join("/"), i = t.value.url.map(t => t.toString()).join("/"); throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${i}'.`) } e[t.value.outlet] = t.value }) }(n), n.sort((t, e) => "primary" === t.value.outlet ? -1 : "primary" === e.value.outlet ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n } processSegment(t, e, n, i) { for (const s of t) try { return this.processSegmentAgainstRoute(s, e, n, i) } catch (r) { if (!(r instanceof cy)) throw r } if (this.noLeftoversInUrl(e, n, i)) return []; throw new cy } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } processSegmentAgainstRoute(t, e, n, i) { if (t.redirectTo) throw new cy; if ((t.outlet || "primary") !== i) throw new cy; let r, s = [], o = []; if ("**" === t.path) { const s = n.length > 0 ? Hm(n).parameters : {}; r = new wg(n, s, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, gy(t), i, t.component, t, uy(e), dy(e) + n.length, yy(t)) } else { const a = function (t, e, n) { if ("" === e.path) { if ("full" === e.pathMatch && (t.hasChildren() || n.length > 0)) throw new cy; return { consumedSegments: [], lastChild: 0, parameters: {} } } const i = (e.matcher || Rm)(n, t, e); if (!i) throw new cy; const r = {}; Um(i.posParams, (t, e) => { r[e] = t.path }); const s = i.consumed.length > 0 ? Object.assign(Object.assign({}, r), i.consumed[i.consumed.length - 1].parameters) : r; return { consumedSegments: i.consumed, lastChild: i.consumed.length, parameters: s } }(e, t, n); s = a.consumedSegments, o = n.slice(a.lastChild), r = new wg(s, a.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, gy(t), i, t.component, t, uy(e), dy(e) + s.length, yy(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = py(e, s, o, a, this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return [new mg(r, t)] } if (0 === a.length && 0 === c.length) return [new mg(r, [])]; const h = this.processSegment(a, l, c, "primary"); return [new mg(r, h)] } } function uy(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function dy(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function py(t, e, n, i, r) { if (n.length > 0 && function (t, e, n) { return n.some(n => fy(t, e, n) && "primary" !== my(n)) }(t, n, i)) { const r = new Gm(e, function (t, e, n, i) { const r = {}; r.primary = i, i._sourceSegment = t, i._segmentIndexShift = e.length; for (const s of n) if ("" === s.path && "primary" !== my(s)) { const n = new Gm([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, r[my(s)] = n } return r }(t, e, i, new Gm(n, t.children))); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => fy(t, e, n)) }(t, n, i)) { const s = new Gm(t.segments, function (t, e, n, i, r, s) { const o = {}; for (const a of i) if (fy(t, n, a) && !r[my(a)]) { const n = new Gm([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === s ? t.segments.length : e.length, o[my(a)] = n } return Object.assign(Object.assign({}, r), o) }(t, e, n, i, t.children, r)); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } const s = new Gm(t.segments, t.children); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } function fy(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 === n.redirectTo } function my(t) { return t.outlet || "primary" } function gy(t) { return t.data || {} } function yy(t) { return t.resolve || {} } function _y(t, e, n, i) { const r = ey(t, e, i); return $m(r.resolve ? r.resolve(e, n) : r(e, n)) } function vy(t) { return function (e) { return e.pipe(Qf(e => { const n = t(e); return n ? z(n).pipe(N(() => e)) : z([e]) })) } } class by { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } } const wy = new Bt("ROUTES"); class xy { constructor(t, e, n, i) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = i } load(t, e) { return this.onLoadStartListener && this.onLoadStartListener(e), this.loadModuleFactory(e.loadChildren).pipe(N(n => { this.onLoadEndListener && this.onLoadEndListener(e); const i = n.create(t); return new Mm(zm(i.injector.get(wy)).map(Vm), i) })) } loadModuleFactory(t) { return "string" == typeof t ? z(this.loader.load(t)) : $m(t()).pipe(H(t => t instanceof ne ? gf(t) : z(this.compiler.compileModuleAsync(t)))) } } class Cy { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Sy(t) { throw t } function ky(t, e, n) { return e.parse("/") } function Ey(t, e) { return gf(null) } let Oy = (() => { class t { constructor(t, e, n, i, r, s, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = i, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new k, this.errorHandler = Sy, this.malformedUriErrorHandler = ky, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Ey, afterPreactivation: Ey }, this.urlHandlingStrategy = new Cy, this.routeReuseStrategy = new by, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = r.get(ee), this.console = r.get(wc); const l = r.get(Lc); this.isNgZoneEnabled = l instanceof Lc, this.resetConfig(a), this.currentUrlTree = new Wm(new Gm([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new xy(s, o, t => this.triggerEvent(new xm(t)), t => this.triggerEvent(new Cm(t))), this.routerState = _g(this.currentUrlTree, this.rootComponentType), this.transitions = new yf({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Of(t => 0 !== t.id), N(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), Qf(t => { let n = !1, i = !1; return gf(t).pipe(am(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Qf(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return gf(t).pipe(Qf(t => { const n = this.transitions.getValue(); return e.next(new pm(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? Cf : [t] }), Qf(t => Promise.resolve(t)), (i = this.ngModule.injector, r = this.configLoader, s = this.urlSerializer, o = this.config, function (t) { return t.pipe(Qf(t => function (t, e, n, i, r) { return new Gg(t, e, n, i, r).apply() }(i, r, s, t.extractedUrl, o).pipe(N(e => Object.assign(Object.assign({}, t), { urlAfterRedirects: e }))))) }), am(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, i, r) { return function (s) { return s.pipe(H(s => function (t, e, n, i, r = "emptyOnly", s = "legacy") { return new hy(t, e, n, i, r, s).recognize() }(t, e, s.urlAfterRedirects, n(s.urlAfterRedirects), i, r).pipe(N(t => Object.assign(Object.assign({}, s), { targetSnapshot: t }))))) } }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), am(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), am(t => { const n = new ym(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var i, r, s, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: i, source: r, restoredState: s, extras: o } = t, a = new pm(n, this.serializeUrl(i), r, s); e.next(a); const l = _g(i, this.rootComponentType).snapshot; return gf(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: i, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), Cf }), vy(t => { const { targetSnapshot: e, id: n, extractedUrl: i, rawUrl: r, extras: { skipLocationChange: s, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: i, rawUrlTree: r, skipLocationChange: !!s, replaceUrl: !!o }) }), am(t => { const e = new _m(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), N(t => Object.assign(Object.assign({}, t), { guards: ty(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return function (n) { return n.pipe(H(n => { const { targetSnapshot: i, currentSnapshot: r, guards: { canActivateChecks: s, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === s.length ? gf(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, i) { return z(t).pipe(H(t => function (t, e, n, i, r) { const s = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return s && 0 !== s.length ? gf(s.map(s => { const o = ey(s, e, r); let a; if (function (t) { return t && Bg(t.canDeactivate) }(o)) a = $m(o.canDeactivate(t, e, n, i)); else { if (!Bg(o)) throw new Error("Invalid CanDeactivate guard"); a = $m(o(t, e, n, i)) } return a.pipe(Yf()) })).pipe(ry()) : gf(!0) }(t.component, t.route, n, e, i)), Yf(t => !0 !== t, !0)) }(o, i, r, t).pipe(H(n => n && "boolean" == typeof n ? function (t, e, n, i) { return z(e).pipe(sm(e => z([oy(e.route.parent, i), sy(e.route, i), ly(t, e.path, n), ay(t, e.route, n)]).pipe(Ef(), Yf(t => !0 !== t, !0))), Yf(t => !0 !== t, !0)) }(i, s, t, e) : gf(n)), N(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) })) } }(this.ngModule.injector, t => this.triggerEvent(t)), am(t => { if (zg(t.guardsResult)) { const e = Im(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } }), am(t => { const e = new vm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), Of(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new mm(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), vy(t => { if (t.guards.canActivateChecks.length) return gf(t).pipe(am(t => { const e = new bm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), (e = this.paramsInheritanceStrategy, n = this.ngModule.injector, function (t) { return t.pipe(H(t => { const { targetSnapshot: i, guards: { canActivateChecks: r } } = t; return r.length ? z(r).pipe(sm(t => function (t, e, n, i) { return function (t, e, n, i) { const r = Object.keys(t); if (0 === r.length) return gf({}); if (1 === r.length) { const s = r[0]; return _y(t[s], e, n, i).pipe(N(t => ({ [s]: t }))) } const s = {}; return z(r).pipe(H(r => _y(t[r], e, n, i).pipe(N(t => (s[r] = t, t))))).pipe(zf(), N(() => s)) }(t._resolve, t, e, i).pipe(N(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), bg(t, n).resolve), null))) }(t.route, i, e, n)), function (t, e) { return arguments.length >= 2 ? function (n) { return _(nm(t, e), Df(1), Vf(e))(n) } : function (e) { return _(nm((e, n, i) => t(e, n, i + 1)), Df(1))(e) } }((t, e) => t), N(e => t)) : gf(t) })) }), am(t => { const e = new wm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })); var e, n }), vy(t => { const { targetSnapshot: e, id: n, extractedUrl: i, rawUrl: r, extras: { skipLocationChange: s, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: i, rawUrlTree: r, skipLocationChange: !!s, replaceUrl: !!o }) }), N(t => { const e = function (t, e, n) { const i = function t(e, n, i) { if (i && e.shouldReuseRoute(n.value, i.value.snapshot)) { const r = i.value; r._futureSnapshot = n.value; const s = function (e, n, i) { return n.children.map(n => { for (const r of i.children) if (e.shouldReuseRoute(r.value.snapshot, n.value)) return t(e, n, r); return t(e, n) }) }(e, n, i); return new mg(r, s) } { const i = e.retrieve(n.value); if (i) { const t = i.route; return function t(e, n) { if (e.value.routeConfig !== n.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== n.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); n.value._futureSnapshot = e.value; for (let i = 0; i < e.children.length; ++i)t(e.children[i], n.children[i]) }(n, t), t } { const i = new vg(new yf((r = n.value).url), new yf(r.params), new yf(r.queryParams), new yf(r.fragment), new yf(r.data), r.outlet, r.component, r), s = n.children.map(n => t(e, n)); return new mg(i, s) } } var r }(t, e._root, n ? n._root : void 0); return new yg(i, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), am(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (s = this.rootContexts, o = this.routeReuseStrategy, a = t => this.triggerEvent(t), N(t => (new Vg(o, t.targetRouterState, t.currentRouterState, a).activate(s), t))), am({ next() { n = !0 }, complete() { n = !0 } }), (r = () => { if (!n && !i) { this.resetUrlToCurrentUrlTree(); const n = new mm(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`); e.next(n), t.resolve(!1) } this.currentNavigation = null }, t => t.lift(new hm(r))), Hf(n => { if (i = !0, (r = n) && r.ngNavigationCancelingError) { const i = zg(n.url); i || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const r = new mm(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(r), i ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); return this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const i = new gm(t.id, this.serializeUrl(t.extractedUrl), n); e.next(i); try { t.resolve(this.errorHandler(n)) } catch (s) { t.reject(s) } } var r; return Cf })); var r, s, o, a })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { let e = this.parseUrl(t.url); const n = "popstate" === t.type ? "popstate" : "hashchange", i = t.state && t.state.navigationId ? t.state : null; setTimeout(() => { this.scheduleNavigation(e, n, i, { replaceUrl: !0 }) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Lm(t), this.config = t.map(Vm), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = null) } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: i, fragment: r, preserveQueryParams: s, queryParamsHandling: o, preserveFragment: a } = e; Ei() && s && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const l = n || this.routerState.root, c = a ? this.currentUrlTree.fragment : r; let h = null; if (o) switch (o) { case "merge": h = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), i); break; case "preserve": h = this.currentUrlTree.queryParams; break; default: h = i || null } else h = s ? this.currentUrlTree.queryParams : i || null; return null !== h && (h = this.removeEmptyProps(h)), function (t, e, n, i, r) { if (0 === n.length) return Ag(e.root, e.root, e, i, r); const s = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new Tg(!0, 0, t); let e = 0, n = !1; const i = t.reduce((t, i, r) => { if ("object" == typeof i && null != i) { if (i.outlets) { const e = {}; return Um(i.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (i.segmentPath) return [...t, i.segmentPath] } return "string" != typeof i ? [...t, i] : 0 === r ? (i.split("/").forEach((i, r) => { 0 == r && "." === i || (0 == r && "" === i ? n = !0 : ".." === i ? e++ : "" != i && t.push(i)) }), t) : [...t, i] }, []); return new Tg(n, e, i) }(n); if (s.toRoot()) return Ag(e.root, new Gm([], {}), e, i, r); const o = function (t, e, n) { if (t.isAbsolute) return new Pg(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) return new Pg(n.snapshot._urlSegment, !0, 0); const i = Og(t.commands[0]) ? 0 : 1; return function (t, e, n) { let i = t, r = e, s = n; for (; s > r;) { if (s -= r, i = i.parent, !i) throw new Error("Invalid number of '../'"); r = i.segments.length } return new Pg(i, !1, r - s) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + i, t.numberOfDoubleDots) }(s, e, t), a = o.processChildren ? Rg(o.segmentGroup, o.index, s.commands) : Ig(o.segmentGroup, o.index, s.commands); return Ag(o.segmentGroup, a, e, i, r) }(l, this.currentUrlTree, t, h, c) } navigateByUrl(t, e = { skipLocationChange: !1 }) { Ei() && this.isNgZoneEnabled && !Lc.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const n = zg(t) ? t : this.parseUrl(t), i = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(i, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { if (zg(t)) return qm(this.currentUrlTree, t, e); const n = this.parseUrl(t); return qm(this.currentUrlTree, n, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const i = t[n]; return null != i && (e[n] = i), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new fm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, i, r) { const s = this.getTransition(); if (s && "imperative" !== e && "imperative" === s.source && s.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (s && "hashchange" == e && "popstate" === s.source && s.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (s && "popstate" == e && "hashchange" === s.source && s.rawUrl.toString() === t.toString()) return Promise.resolve(!0); let o, a, l; r ? (o = r.resolve, a = r.reject, l = r.promise) : l = new Promise((t, e) => { o = t, a = e }); const c = ++this.navigationId; return this.setTransition({ id: c, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: i, resolve: o, reject: a, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, i) { const r = this.urlSerializer.serialize(t); i = i || {}, this.location.isCurrentPathEqualTo(r) || e ? this.location.replaceState(r, "", Object.assign(Object.assign({}, i), { navigationId: n })) : this.location.go(r, "", Object.assign(Object.assign({}, i), { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } return t.\u0275fac = function (t) { Po() }, t.\u0275dir = we({ type: t }), t })(), Ay = (() => { class t { constructor(t, e, n, i, r) { this.router = t, this.route = e, this.commands = [], null == n && i.setAttribute(r.nativeElement, "tabindex", "0") } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { Ei() && console && console.warn && console.warn("preserveQueryParams is deprecated!, use queryParamsHandling instead."), this.preserve = t } onClick() { const t = { skipLocationChange: Py(this.skipLocationChange), replaceUrl: Py(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, t), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Py(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Py(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Oy), Ao(vg), To("tabindex"), Ao(Ga), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (t, e) { 1 & t && Ho("click", (function () { return e.onClick() })) }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" } }), t })(), Ty = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.subscription = t.events.subscribe(t => { t instanceof fm && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { Ei() && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."), this.preserve = t } ngOnChanges(t) { this.updateTargetUrlAndHref() } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, i) { if (0 !== t || e || n || i) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const r = { skipLocationChange: Py(this.skipLocationChange), replaceUrl: Py(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, r), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Py(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Py(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Oy), Ao(vg), Ao(Ch)) }, t.\u0275dir = we({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Ho("click", (function (t) { return e.onClick(t.button, t.ctrlKey, t.metaKey, t.shiftKey) })), 2 & t && (ba("href", e.href, Ji), So("target", e.target)) }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" }, features: [Ta] }), t })(); function Py(t) { return "" === t || !!t } class Dy { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Iy, this.attachRef = null } } class Iy { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Dy, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } let Ry = (() => { class t { constructor(t, e, n, i, r) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = r, this.activated = null, this._activatedRoute = null, this.activateEvents = new ql, this.deactivateEvents = new ql, this.name = i || "primary", t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), i = this.parentContexts.getOrCreateContext(this.name).children, r = new My(t, i, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, r), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Iy), Ao(ml), Ao(Ha), To("name"), Ao(Ws)) }, t.\u0275dir = we({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class My { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === vg ? this.route : t === Iy ? this.childContexts : this.parent.get(t, e) } } class Ly { } class Fy { preload(t, e) { return gf(null) } } let Ny = (() => { class t { constructor(t, e, n, i, r) { this.router = t, this.injector = i, this.preloadingStrategy = r, this.loader = new xy(e, n, e => t.triggerEvent(new xm(e)), e => t.triggerEvent(new Cm(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Of(t => t instanceof fm), sm(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(ee); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const i of e) if (i.loadChildren && !i.canLoad && i._loadedConfig) { const t = i._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else i.loadChildren && !i.canLoad ? n.push(this.preloadConfig(t, i)) : i.children && n.push(this.processRoutes(t, i.children)); return z(n).pipe(q(), N(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => this.loader.load(t.injector, e).pipe(H(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Oy), Kt(ih), Kt(Dc), Kt(lo), Kt(Ly)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Vy = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof pm ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof fm && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof Am && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new Am(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (t) { Po() }, t.\u0275dir = we({ type: t }), t })(); const jy = new Bt("ROUTER_CONFIGURATION"), By = new Bt("ROUTER_FORROOT_GUARD"), zy = [Ah, { provide: Qm, useClass: Zm }, { provide: Oy, useFactory: function (t, e, n, i, r, s, o, a = {}, l, c) { const h = new Oy(null, t, e, n, i, r, s, zm(o)); if (l && (h.urlHandlingStrategy = l), c && (h.routeReuseStrategy = c), a.errorHandler && (h.errorHandler = a.errorHandler), a.malformedUriErrorHandler && (h.malformedUriErrorHandler = a.malformedUriErrorHandler), a.enableTracing) { const t = dh(); h.events.subscribe(e => { t.logGroup(`Router Event: ${e.constructor.name}`), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return a.onSameUrlNavigation && (h.onSameUrlNavigation = a.onSameUrlNavigation), a.paramsInheritanceStrategy && (h.paramsInheritanceStrategy = a.paramsInheritanceStrategy), a.urlUpdateStrategy && (h.urlUpdateStrategy = a.urlUpdateStrategy), a.relativeLinkResolution && (h.relativeLinkResolution = a.relativeLinkResolution), h }, deps: [Qm, Iy, Ah, lo, ih, Dc, wy, jy, [class { }, new ot], [class { }, new ot]] }, Iy, { provide: vg, useFactory: function (t) { return t.routerState.root }, deps: [Oy] }, { provide: ih, useClass: oh }, Ny, Fy, class { preload(t, e) { return e().pipe(Hf(() => gf(null))) } }, { provide: jy, useValue: { enableTracing: !1 } }]; function Hy() { return new Kc("Router", Oy) } let Uy = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [zy, Gy(e), { provide: By, useFactory: Wy, deps: [[Oy, new ot, new lt]] }, { provide: jy, useValue: n || {} }, { provide: Ch, useFactory: qy, deps: [fh, [new st(kh), new ot], jy] }, { provide: Vy, useFactory: $y, deps: [Oy, hu, jy] }, { provide: Ly, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Fy }, { provide: Kc, multi: !0, useFactory: Hy }, [Yy, { provide: pc, multi: !0, useFactory: Xy, deps: [Yy] }, { provide: Qy, useFactory: Ky, deps: [Yy] }, { provide: bc, multi: !0, useExisting: Qy }]] } } static forChild(e) { return { ngModule: t, providers: [Gy(e)] } } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t)(Kt(By, 8), Kt(Oy, 8)) } }), t })(); function $y(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new Vy(t, e, n) } function qy(t, e, n = {}) { return n.useHash ? new Oh(t, e) : new Eh(t, e) } function Wy(t) { if (t) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function Gy(t) { return [{ provide: co, multi: !0, useValue: t }, { provide: wy, multi: !0, useValue: t }] } let Yy = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new k } appInitializer() { return this.injector.get(gh, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(Oy), i = this.injector.get(jy); if (this.isLegacyDisabled(i) || this.isLegacyEnabled(i)) t(!0); else if ("disabled" === i.initialNavigation) n.setUpLocationChangeListener(), t(!0); else { if ("enabled" !== i.initialNavigation) throw new Error(`Invalid initialNavigation options: '${i.initialNavigation}'`); n.hooks.afterPreactivation = () => this.initNavigation ? gf(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation() } return e }) } bootstrapListener(t) { const e = this.injector.get(jy), n = this.injector.get(Ny), i = this.injector.get(Vy), r = this.injector.get(Oy), s = this.injector.get(eh); t === s.components[0] && (this.isLegacyEnabled(e) ? r.initialNavigation() : this.isLegacyDisabled(e) && r.setUpLocationChangeListener(), n.setUpPreloading(), i.init(), r.resetRootComponentType(s.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(t) { return "legacy_enabled" === t.initialNavigation || !0 === t.initialNavigation || void 0 === t.initialNavigation } isLegacyDisabled(t) { return "legacy_disabled" === t.initialNavigation || !1 === t.initialNavigation } } return t.\u0275fac = function (e) { return new (e || t)(Kt(lo)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function Xy(t) { return t.appInitializer.bind(t) } function Ky(t) { return t.bootstrapListener.bind(t) } const Qy = new Bt("Router Initializer"); class Zy { } class Jy { } class t_ { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), i = n.toLowerCase(), r = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, i), this.headers.has(i) ? this.headers.get(i).push(r) : this.headers.set(i, [r]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const i = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(i, n), this.maybeSetNormalizedName(e, i)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof t_ ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new t_; return e.lazyInit = this.lazyInit && this.lazyInit instanceof t_ ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const i = ("a" === t.op ? this.headers.get(e) : void 0) || []; i.push(...n), this.headers.set(e, i); break; case "d": const r = t.value; if (r) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === r.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class e_ { encodeKey(t) { return n_(t) } encodeValue(t) { return n_(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function n_(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class i_ { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new e_, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.split("&").forEach(t => { const i = t.indexOf("="), [r, s] = -1 == i ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, i)), e.decodeValue(t.slice(i + 1))], o = n.get(r) || []; o.push(s), n.set(r, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new i_({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat([t]), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(t.value), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(t.value); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } function r_(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function s_(t) { return "undefined" != typeof Blob && t instanceof Blob } function o_(t) { return "undefined" != typeof FormData && t instanceof FormData } class a_ { constructor(t, e, n, i) { let r; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || i ? (this.body = void 0 !== n ? n : null, r = i) : r = n, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.params && (this.params = r.params)), this.headers || (this.headers = new t_), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new i_, this.urlWithParams = e } serializeBody() { return null === this.body ? null : r_(this.body) || s_(this.body) || o_(this.body) || "string" == typeof this.body ? this.body : this.body instanceof i_ ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || o_(this.body) ? null : s_(this.body) ? this.body.type || null : r_(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof i_ ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(t = {}) { const e = t.method || this.method, n = t.url || this.url, i = t.responseType || this.responseType, r = void 0 !== t.body ? t.body : this.body, s = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, o = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let a = t.headers || this.headers, l = t.params || this.params; return void 0 !== t.setHeaders && (a = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), a)), t.setParams && (l = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), l)), new a_(e, n, r, { params: l, headers: a, reportProgress: o, responseType: i, withCredentials: s }) } } const l_ = function () { var t = { Sent: 0, UploadProgress: 1, ResponseHeader: 2, DownloadProgress: 3, Response: 4, User: 5 }; return t[t.Sent] = "Sent", t[t.UploadProgress] = "UploadProgress", t[t.ResponseHeader] = "ResponseHeader", t[t.DownloadProgress] = "DownloadProgress", t[t.Response] = "Response", t[t.User] = "User", t }(); class c_ { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new t_, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class h_ extends c_ { constructor(t = {}) { super(t), this.type = l_.ResponseHeader } clone(t = {}) { return new h_({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class u_ extends c_ { constructor(t = {}) { super(t), this.type = l_.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new u_({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class d_ extends c_ { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function p_(t, e) { return { body: e, headers: t.headers, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let f_ = (() => { class t { constructor(t) { this.handler = t } request(t, e, n = {}) { let i; if (t instanceof a_) i = t; else { let r = void 0; r = n.headers instanceof t_ ? n.headers : new t_(n.headers); let s = void 0; n.params && (s = n.params instanceof i_ ? n.params : new i_({ fromObject: n.params })), i = new a_(t, e, void 0 !== n.body ? n.body : null, { headers: r, params: s, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const r = gf(i).pipe(sm(t => this.handler.handle(t))); if (t instanceof a_ || "events" === n.observe) return r; const s = r.pipe(Of(t => t instanceof u_)); switch (n.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return s.pipe(N(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return s.pipe(N(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return s.pipe(N(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return s.pipe(N(t => t.body)) }case "response": return s; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new i_).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, p_(n, e)) } post(t, e, n = {}) { return this.request("POST", t, p_(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, p_(n, e)) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Zy)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class m_ { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const g_ = new Bt("HTTP_INTERCEPTORS"); let y_ = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const __ = /^\)\]\}',?\n/; class v_ { } let b_ = (() => { class t { constructor() { } build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), w_ = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed."); return new b(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const i = t.serializeBody(); let r = null; const s = () => { if (null !== r) return r; const e = 1223 === n.status ? 204 : n.status, i = n.statusText || "OK", s = new t_(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return r = new h_({ headers: s, status: e, statusText: i, url: o }), r }, o = () => { let { headers: i, status: r, statusText: o, url: a } = s(), l = null; 204 !== r && (l = void 0 === n.response ? n.responseText : n.response), 0 === r && (r = l ? 200 : 0); let c = r >= 200 && r < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(__, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (h) { l = t, c && (c = !1, l = { error: h, text: l }) } } c ? (e.next(new u_({ body: l, headers: i, status: r, statusText: o, url: a || void 0 })), e.complete()) : e.error(new d_({ error: l, headers: i, status: r, statusText: o, url: a || void 0 })) }, a = t => { const { url: i } = s(), r = new d_({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: i || void 0 }); e.error(r) }; let l = !1; const c = i => { l || (e.next(s()), l = !0); let r = { type: l_.DownloadProgress, loaded: i.loaded }; i.lengthComputable && (r.total = i.total), "text" === t.responseType && n.responseText && (r.partialText = n.responseText), e.next(r) }, h = t => { let n = { type: l_.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), t.reportProgress && (n.addEventListener("progress", c), null !== i && n.upload && n.upload.addEventListener("progress", h)), n.send(i), e.next({ type: l_.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("load", o), t.reportProgress && (n.removeEventListener("progress", c), null !== i && n.upload && n.upload.removeEventListener("progress", h)), n.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(v_)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const x_ = new Bt("XSRF_COOKIE_NAME"), C_ = new Bt("XSRF_HEADER_NAME"); class S_ { } let k_ = (() => { class t { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = jh(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph), Kt(vc), Kt(x_)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), E_ = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const i = this.tokenService.getToken(); return null === i || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, i) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(S_), Kt(C_)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), O_ = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(g_, []); this.chain = t.reduceRight((t, e) => new m_(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Jy), Kt(lo)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), A_ = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: E_, useClass: y_ }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: x_, useValue: e.cookieName } : [], e.headerName ? { provide: C_, useValue: e.headerName } : []] } } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [E_, { provide: g_, useExisting: E_, multi: !0 }, { provide: S_, useClass: k_ }, { provide: x_, useValue: "XSRF-TOKEN" }, { provide: C_, useValue: "X-XSRF-TOKEN" }] }), t })(), T_ = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [f_, { provide: Zy, useClass: O_ }, w_, { provide: Jy, useExisting: w_ }, b_, { provide: v_, useExisting: b_ }], imports: [[A_.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(); function P_(t, e) { return new b(n => { const i = t.length; if (0 === i) return void n.complete(); const r = new Array(i); let s = 0, o = 0; for (let a = 0; a < i; a++) { const l = z(t[a]); let c = !1; n.add(l.subscribe({ next: t => { c || (c = !0, o++), r[a] = t }, error: t => n.error(t), complete: () => { s++, s !== i && c || (o === i && n.next(e ? e.reduce((t, e, n) => (t[e] = r[n], t), {}) : r), n.complete()) } })) } }) } const D_ = new Bt("NgValueAccessor"), I_ = { provide: D_, useExisting: kt(() => R_), multi: !0 }; let R_ = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "checked", t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Ho("change", (function (t) { return e.onChange(t.target.checked) }))("blur", (function () { return e.onTouched() })) }, features: [ja([I_])] }), t })(); const M_ = { provide: D_, useExisting: kt(() => F_), multi: !0 }, L_ = new Bt("CompositionEventMode"); let F_ = (() => { class t { constructor(t, e, n) { this._renderer = t, this._elementRef = e, this._compositionMode = n, this.onChange = t => { }, this.onTouched = () => { }, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = dh() ? dh().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua), Ao(L_, 8)) }, t.\u0275dir = we({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && Ho("input", (function (t) { return e._handleInput(t.target.value) }))("blur", (function () { return e.onTouched() }))("compositionstart", (function () { return e._compositionStart() }))("compositionend", (function (t) { return e._compositionEnd(t.target.value) })) }, features: [ja([M_])] }), t })(), N_ = (() => { class t { get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t }), t })(), V_ = (() => { class t extends N_ { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function (e) { return j_(e || t) }, t.\u0275dir = we({ type: t, features: [Ca] }), t })(); const j_ = hi(V_); function B_() { throw new Error("unimplemented") } class z_ extends N_ { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null, this._rawValidators = [], this._rawAsyncValidators = [] } get validator() { return B_() } get asyncValidator() { return B_() } } class H_ { constructor(t) { this._cd = t } get ngClassUntouched() { return !!this._cd.control && this._cd.control.untouched } get ngClassTouched() { return !!this._cd.control && this._cd.control.touched } get ngClassPristine() { return !!this._cd.control && this._cd.control.pristine } get ngClassDirty() { return !!this._cd.control && this._cd.control.dirty } get ngClassValid() { return !!this._cd.control && this._cd.control.valid } get ngClassInvalid() { return !!this._cd.control && this._cd.control.invalid } get ngClassPending() { return !!this._cd.control && this._cd.control.pending } } let U_ = (() => { class t extends H_ { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(z_, 2)) }, t.\u0275dir = we({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && sa("ng-untouched", e.ngClassUntouched)("ng-touched", e.ngClassTouched)("ng-pristine", e.ngClassPristine)("ng-dirty", e.ngClassDirty)("ng-valid", e.ngClassValid)("ng-invalid", e.ngClassInvalid)("ng-pending", e.ngClassPending) }, features: [Ca] }), t })(), $_ = (() => { class t extends H_ { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(V_, 2)) }, t.\u0275dir = we({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && sa("ng-untouched", e.ngClassUntouched)("ng-touched", e.ngClassTouched)("ng-pristine", e.ngClassPristine)("ng-dirty", e.ngClassDirty)("ng-valid", e.ngClassValid)("ng-invalid", e.ngClassInvalid)("ng-pending", e.ngClassPending) }, features: [Ca] }), t })(); function q_(t) { return null == t || 0 === t.length } const W_ = new Bt("NgValidators"), G_ = new Bt("NgAsyncValidators"), Y_ = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class X_ { static min(t) { return e => { if (q_(e.value) || q_(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } } static max(t) { return e => { if (q_(e.value) || q_(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } } static required(t) { return q_(t.value) ? { required: !0 } : null } static requiredTrue(t) { return !0 === t.value ? null : { required: !0 } } static email(t) { return q_(t.value) || Y_.test(t.value) ? null : { email: !0 } } static minLength(t) { return e => { if (q_(e.value)) return null; const n = e.value ? e.value.length : 0; return n < t ? { minlength: { requiredLength: t, actualLength: n } } : null } } static maxLength(t) { return e => { const n = e.value ? e.value.length : 0; return n > t ? { maxlength: { requiredLength: t, actualLength: n } } : null } } static pattern(t) { if (!t) return X_.nullValidator; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), t => { if (q_(t.value)) return null; const i = t.value; return e.test(i) ? null : { pattern: { requiredPattern: n, actualValue: i } } } } static nullValidator(t) { return null } static compose(t) { if (!t) return null; const e = t.filter(K_); return 0 == e.length ? null : function (t) { return Z_(function (t, e) { return e.map(e => e(t)) }(t, e)) } } static composeAsync(t) { if (!t) return null; const e = t.filter(K_); return 0 == e.length ? null : function (t) { return function (...t) { if (1 === t.length) { const e = t[0]; if (l(e)) return P_(e, null); if (c(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return P_(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return P_(t = 1 === t.length && l(t[0]) ? t[0] : t, null).pipe(N(t => e(...t))) } return P_(t, null) }(function (t, e) { return e.map(e => e(t)) }(t, e).map(Q_)).pipe(N(Z_)) } } } function K_(t) { return null != t } function Q_(t) { const e = Bo(t) ? z(t) : t; if (!zo(e)) throw new Error("Expected validator to return Promise or Observable."); return e } function Z_(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function J_(t) { return t.validate ? e => t.validate(e) : t } function tv(t) { return t.validate ? e => t.validate(e) : t } const ev = { provide: D_, useExisting: kt(() => nv), multi: !0 }; let nv = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Ho("change", (function (t) { return e.onChange(t.target.value) }))("input", (function (t) { return e.onChange(t.target.value) }))("blur", (function () { return e.onTouched() })) }, features: [ja([ev])] }), t })(); const iv = { provide: D_, useExisting: kt(() => sv), multi: !0 }; let rv = (() => { class t { constructor() { this._accessors = [] } add(t, e) { this._accessors.push([t, e]) } remove(t) { for (let e = this._accessors.length - 1; e >= 0; --e)if (this._accessors[e][1] === t) return void this._accessors.splice(e, 1) } select(t) { this._accessors.forEach(e => { this._isSameGroup(e, t) && e[1] !== t && e[1].fireUncheck(t.value) }) } _isSameGroup(t, e) { return !!t[0].control && t[0]._parent === e._control._parent && t[1].name === e.name } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), sv = (() => { class t { constructor(t, e, n, i) { this._renderer = t, this._elementRef = e, this._registry = n, this._injector = i, this.onChange = () => { }, this.onTouched = () => { } } ngOnInit() { this._control = this._injector.get(z_), this._checkName(), this._registry.add(this._control, this) } ngOnDestroy() { this._registry.remove(this) } writeValue(t) { this._state = t === this.value, this._renderer.setProperty(this._elementRef.nativeElement, "checked", this._state) } registerOnChange(t) { this._fn = t, this.onChange = () => { t(this.value), this._registry.select(this) } } fireUncheck(t) { this.writeValue(t) } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _checkName() { this.name && this.formControlName && this.name !== this.formControlName && this._throwNameError(), !this.name && this.formControlName && (this.name = this.formControlName) } _throwNameError() { throw new Error('\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    ') } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua), Ao(rv), Ao(lo)) }, t.\u0275dir = we({ type: t, selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Ho("change", (function () { return e.onChange() }))("blur", (function () { return e.onTouched() })) }, inputs: { name: "name", formControlName: "formControlName", value: "value" }, features: [ja([iv])] }), t })(); const ov = { provide: D_, useExisting: kt(() => av), multi: !0 }; let av = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", parseFloat(t)) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Ho("change", (function (t) { return e.onChange(t.target.value) }))("input", (function (t) { return e.onChange(t.target.value) }))("blur", (function () { return e.onTouched() })) }, features: [ja([ov])] }), t })(); const lv = '\n    <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });', cv = '\n    <div [formGroup]="myGroup">\n       <div formGroupName="person">\n          <input formControlName="firstName">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });'; class hv { static controlParentException() { throw new Error(`formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${lv}`) } static ngModelGroupException() { throw new Error(`formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a "form" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        ${cv}\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        \n    <form>\n       <div ngModelGroup="person">\n          <input [(ngModel)]="person.name" name="firstName">\n       </div>\n    </form>`) } static missingFormException() { throw new Error(`formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       ${lv}`) } static groupParentException() { throw new Error(`formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${cv}`) } static arrayParentException() { throw new Error('formArrayName must be used with a parent formGroup directive.  You\'ll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        \n    <div [formGroup]="myGroup">\n      <div formArrayName="cities">\n        <div *ngFor="let city of cityArray.controls; index as i">\n          <input [formControlName]="i">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl(\'SF\')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });') } static disabledAttrWarning() { console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ") } static ngModelWarning(t) { console.warn(`\n    It looks like you're using ngModel on the same form field as ${t}. \n    Support for using the ngModel input property and ngModelChange event with \n    reactive form directives has been deprecated in Angular v6 and will be removed \n    in Angular v7.\n    \n    For more information on this, see our API docs here:\n    https://angular.io/api/forms/${"formControl" === t ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel\n    `) } } const uv = { provide: D_, useExisting: kt(() => dv), multi: !0 }; let dv = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = yo } set compareWith(t) { if ("function" != typeof t) throw new Error(`compareWith must be a function, but received ${JSON.stringify(t)}`); this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t); null == e && this._renderer.setProperty(this._elementRef.nativeElement, "selectedIndex", -1); const n = function (t, e) { return null == t ? `${e}` : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) }(e, t); this._renderer.setProperty(this._elementRef.nativeElement, "value", n) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, e) { 1 & t && Ho("change", (function (t) { return e.onChange(t.target.value) }))("blur", (function () { return e.onTouched() })) }, inputs: { compareWith: "compareWith" }, features: [ja([uv])] }), t })(); const pv = { provide: D_, useExisting: kt(() => fv), multi: !0 }; let fv = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = yo } set compareWith(t) { if ("function" != typeof t) throw new Error(`compareWith must be a function, but received ${JSON.stringify(t)}`); this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const n = t.map(t => this._getOptionId(t)); e = (t, e) => { t._setSelected(n.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) }; this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const n = []; if (e.hasOwnProperty("selectedOptions")) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const i = t.item(e), r = this._getOptionValue(i.value); n.push(r) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const i = t.item(e); if (i.selected) { const t = this._getOptionValue(i.value); n.push(t) } } } this.value = n, t(n) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Ho("change", (function (t) { return e.onChange(t.target) }))("blur", (function () { return e.onTouched() })) }, inputs: { compareWith: "compareWith" }, features: [ja([pv])] }), t })(); function mv(t, e) { return [...e.path, t] } function gv(t, e) { t || bv(e, "Cannot find control with"), e.valueAccessor || bv(e, "No value accessor for form control with"), t.validator = X_.compose([t.validator, e.validator]), t.asyncValidator = X_.composeAsync([t.asyncValidator, e.asyncValidator]), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && yv(t, e) }) }(t, e), function (t, e) { t.registerOnChange((t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && yv(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), e.valueAccessor.setDisabledState && t.registerOnDisabledChange(t => { e.valueAccessor.setDisabledState(t) }), e._rawValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }), e._rawAsyncValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }) } function yv(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function _v(t, e) { null == t && bv(e, "Cannot find control with"), t.validator = X_.compose([t.validator, e.validator]), t.asyncValidator = X_.composeAsync([t.asyncValidator, e.asyncValidator]) } function vv(t) { return bv(t, "There is no FormControl instance attached to form control element with") } function bv(t, e) { let n; throw n = t.path.length > 1 ? `path: '${t.path.join(" -> ")}'` : t.path[0] ? `name: '${t.path}'` : "unspecified name attribute", new Error(`${e} ${n}`) } function wv(t) { return null != t ? X_.compose(t.map(J_)) : null } function xv(t) { return null != t ? X_.composeAsync(t.map(tv)) : null } const Cv = [R_, av, nv, dv, fv, sv]; function Sv(t, e) { t._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }) } function kv(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } function Ev(t) { const e = Av(t) ? t.validators : t; return Array.isArray(e) ? wv(e) : e || null } function Ov(t, e) { const n = Av(e) ? e.asyncValidators : t; return Array.isArray(n) ? xv(n) : n || null } function Av(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class Tv { constructor(t, e) { this.validator = t, this.asyncValidator = e, this._onCollectionChange = () => { }, this.pristine = !0, this.touched = !1, this._onDisabledChange = [] } get parent() { return this._parent } get valid() { return "VALID" === this.status } get invalid() { return "INVALID" === this.status } get pending() { return "PENDING" == this.status } get disabled() { return "DISABLED" === this.status } get enabled() { return "DISABLED" !== this.status } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this.validator = Ev(t) } setAsyncValidators(t) { this.asyncValidator = Ov(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = "PENDING", !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = "DISABLED", this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = "VALID", this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), "VALID" !== this.status && "PENDING" !== this.status || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? "DISABLED" : "VALID" } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = "PENDING"; const e = Q_(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => this.setErrors(e, { emitEvent: t })) } } _cancelExistingSubscription() { this._asyncValidationSubscription && this._asyncValidationSubscription.unsubscribe() } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let i = t; return e.forEach(t => { i = i instanceof Dv ? i.controls.hasOwnProperty(t) ? i.controls[t] : null : i instanceof Iv && i.at(t) || null }), i }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new ql, this.statusChanges = new ql } _calculateStatus() { return this._allControlsDisabled() ? "DISABLED" : this.errors ? "INVALID" : this._anyControlsHaveStatus("PENDING") ? "PENDING" : this._anyControlsHaveStatus("INVALID") ? "INVALID" : "VALID" } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { Av(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && this._parent && this._parent.dirty && !this._parent._anyControlsDirty() } } class Pv extends Tv { constructor(t = null, e, n) { super(Ev(e), Ov(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }), this._initObservables() } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _clearChangeFns() { this._onChange = [], this._onDisabledChange = [], this._onCollectionChange = () => { } } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class Dv extends Tv { constructor(t, e, n) { super(Ev(e), Ov(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e) { this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } removeControl(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity(), this._onCollectionChange() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = {}, e = {}) { this._forEachChild((n, i) => { n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof Pv ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => t(this.controls[e], e)) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { let e = !1; return this._forEachChild((n, i) => { e = e || this.contains(i) && t(n) }), e } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, i) => { n = e(n, t, i) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class Iv extends Tv { constructor(t, e, n) { super(Ev(e), Ov(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } at(t) { return this.controls[t] } push(t) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity(), this._onCollectionChange() } insert(t, e) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity() } removeAt(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity(), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = [], e = {}) { this._forEachChild((n, i) => { n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof Pv ? t.value : t.getRawValue()) } clear() { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity()) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const Rv = { provide: V_, useExisting: kt(() => Lv) }, Mv = (() => Promise.resolve(null))(); let Lv = (() => { class t extends V_ { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new ql, this.form = new Dv({}, wv(t), xv(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Mv.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), gv(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Mv.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), kv(this._directives, t) }) } addFormGroup(t) { Mv.then(() => { const e = this._findContainer(t.path), n = new Dv({}); _v(n, t), e.registerControl(t.name, n), n.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Mv.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { Mv.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, Sv(this.form, this._directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function (e) { return new (e || t)(Ao(W_, 10), Ao(G_, 10)) }, t.\u0275dir = we({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, e) { 1 & t && Ho("submit", (function (t) { return e.onSubmit(t) }))("reset", (function () { return e.onReset() })) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ja([Rv]), Ca] }), t })(), Fv = (() => { class t extends V_ { ngOnInit() { this._checkParentType(), this.formDirective.addFormGroup(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormGroup(this) } get control() { return this.formDirective.getFormGroup(this) } get path() { return mv(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return wv(this._validators) } get asyncValidator() { return xv(this._asyncValidators) } _checkParentType() { } } return t.\u0275fac = function (e) { return Nv(e || t) }, t.\u0275dir = we({ type: t, features: [Ca] }), t })(); const Nv = hi(Fv); let Vv = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(); const jv = new Bt("NgModelWithFormControlWarning"), Bv = { provide: V_, useExisting: kt(() => zv) }; let zv = (() => { class t extends V_ { constructor(t, e) { super(), this._validators = t, this._asyncValidators = e, this.submitted = !1, this.directives = [], this.form = null, this.ngSubmit = new ql } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations()) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return gv(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { kv(this.directives, t) } addFormGroup(t) { const e = this.form.get(t.path); _v(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } removeFormGroup(t) { } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { const e = this.form.get(t.path); _v(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } removeFormArray(t) { } getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, Sv(this.form, this.directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = this.form.get(t.path); t.control !== e && (function (t, e) { e.valueAccessor.registerOnChange(() => vv(e)), e.valueAccessor.registerOnTouched(() => vv(e)), e._rawValidators.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(null) }), e._rawAsyncValidators.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(null) }), t && t._clearChangeFns() }(t.control, t), e && gv(e, t), t.control = e) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _updateRegistrations() { this.form._registerOnCollectionChange(() => this._updateDomValue()), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }), this._oldForm = this.form } _updateValidators() { const t = wv(this._validators); this.form.validator = X_.compose([this.form.validator, t]); const e = xv(this._asyncValidators); this.form.asyncValidator = X_.composeAsync([this.form.asyncValidator, e]) } _checkFormPresent() { this.form || hv.missingFormException() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(W_, 10), Ao(G_, 10)) }, t.\u0275dir = we({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (t, e) { 1 & t && Ho("submit", (function (t) { return e.onSubmit(t) }))("reset", (function () { return e.onReset() })) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ja([Bv]), Ca, Ta] }), t })(); const Hv = { provide: V_, useExisting: kt(() => Uv) }; let Uv = (() => { class t extends Fv { constructor(t, e, n) { super(), this._parent = t, this._validators = e, this._asyncValidators = n } _checkParentType() { Wv(this._parent) && hv.groupParentException() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(V_, 13), Ao(W_, 10), Ao(G_, 10)) }, t.\u0275dir = we({ type: t, selectors: [["", "formGroupName", ""]], inputs: { name: ["formGroupName", "name"] }, features: [ja([Hv]), Ca] }), t })(); const $v = { provide: V_, useExisting: kt(() => qv) }; let qv = (() => { class t extends V_ { constructor(t, e, n) { super(), this._parent = t, this._validators = e, this._asyncValidators = n } ngOnInit() { this._checkParentType(), this.formDirective.addFormArray(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormArray(this) } get control() { return this.formDirective.getFormArray(this) } get formDirective() { return this._parent ? this._parent.formDirective : null } get path() { return mv(null == this.name ? this.name : this.name.toString(), this._parent) } get validator() { return wv(this._validators) } get asyncValidator() { return xv(this._asyncValidators) } _checkParentType() { Wv(this._parent) && hv.arrayParentException() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(V_, 13), Ao(W_, 10), Ao(G_, 10)) }, t.\u0275dir = we({ type: t, selectors: [["", "formArrayName", ""]], inputs: { name: ["formArrayName", "name"] }, features: [ja([$v]), Ca] }), t })(); function Wv(t) { return !(t instanceof Uv || t instanceof zv || t instanceof qv) } const Gv = { provide: z_, useExisting: kt(() => Yv) }; let Yv = (() => { class t extends z_ { constructor(t, e, n, i, r) { super(), this._ngModelWarningConfig = r, this._added = !1, this.update = new ql, this._ngModelWarningSent = !1, this._parent = t, this._rawValidators = e || [], this._rawAsyncValidators = n || [], this.valueAccessor = function (t, e) { if (!e) return null; Array.isArray(e) || bv(t, "Value accessor was not provided as an array for form control with"); let n = void 0, i = void 0, r = void 0; return e.forEach(e => { var s; e.constructor === F_ ? n = e : (s = e, Cv.some(t => s.constructor === t) ? (i && bv(t, "More than one built-in value accessor matches form control with"), i = e) : (r && bv(t, "More than one custom value accessor matches form control with"), r = e)) }), r || i || n || (bv(t, "No valid value accessor for form control with"), null) }(this, i) } set isDisabled(t) { hv.disabledAttrWarning() } ngOnChanges(e) { var n, i; this._added || this._setUpControl(), function (t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !yo(e, n.currentValue) }(e, this.viewModel) && ("formControlName", n = t, this, i = this._ngModelWarningConfig, Ei() && "never" !== i && ((null !== i && "once" !== i || n._ngModelWarningSentOnce) && ("always" !== i || this._ngModelWarningSent) || (hv.ngModelWarning("formControlName"), n._ngModelWarningSentOnce = !0, this._ngModelWarningSent = !0)), this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return mv(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return wv(this._rawValidators) } get asyncValidator() { return xv(this._rawAsyncValidators) } _checkParentType() { !(this._parent instanceof Uv) && this._parent instanceof Fv ? hv.ngModelGroupException() : this._parent instanceof Uv || this._parent instanceof zv || this._parent instanceof qv || hv.controlParentException() } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ao(V_, 13), Ao(W_, 10), Ao(G_, 10), Ao(D_, 10), Ao(jv, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "formControlName", ""]], inputs: { isDisabled: ["disabled", "isDisabled"], name: ["formControlName", "name"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [ja([Gv]), Ca, Ta] }), t._ngModelWarningSentOnce = !1, t })(), Xv = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(), Kv = (() => { class t { group(t, e = null) { const n = this._reduceControls(t); let i = null, r = null, s = void 0; return null != e && (function (t) { return void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn }(e) ? (i = null != e.validators ? e.validators : null, r = null != e.asyncValidators ? e.asyncValidators : null, s = null != e.updateOn ? e.updateOn : void 0) : (i = null != e.validator ? e.validator : null, r = null != e.asyncValidator ? e.asyncValidator : null)), new Dv(n, { asyncValidators: r, updateOn: s, validators: i }) } control(t, e, n) { return new Pv(t, e, n) } array(t, e, n) { const i = t.map(t => this._createControl(t)); return new Iv(i, e, n) } _reduceControls(t) { const e = {}; return Object.keys(t).forEach(n => { e[n] = this._createControl(t[n]) }), e } _createControl(t) { return t instanceof Pv || t instanceof Dv || t instanceof Iv ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Qv = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: jv, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [Kv, rv], imports: [Xv] }), t })(); function Zv(t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey } class Jv extends u { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class tb extends Jv { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, i = this.scheduler; return null != n && (this.id = this.recycleAsyncId(i, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(i, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n = !1, i = void 0; try { this.work(t) } catch (r) { n = !0, i = !!r && r || new Error(r) } if (n) return this.unsubscribe(), i } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, i = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== i && n.splice(i, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let eb = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class nb extends eb { constructor(t, e = eb.now) { super(t, () => nb.delegate && nb.delegate !== this ? nb.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return nb.delegate && nb.delegate !== this ? nb.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } const ib = new nb(tb); function rb(t, e = ib) { return n => n.lift(new sb(t, e)) } class sb { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new ob(t, this.dueTime, this.scheduler)) } } class ob extends f { constructor(t, e, n) { super(t), this.dueTime = e, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(ab, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function ab(t) { t.debouncedNext() } function lb(t) { return null != t && "false" !== `${t}` } function cb(t, e = 0) { return hb(t) ? Number(t) : e } function hb(t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) } function ub(t) { return Array.isArray(t) ? t : [t] } function db(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` } function pb(t) { return t instanceof Ua ? t.nativeElement : t } let fb; try { fb = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (WM) { fb = !1 } let mb, gb = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? lu(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !fb) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (e) { return new (e || t)(Kt(vc, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(vc, 8)) }, token: t, providedIn: "root" }), t })(), yb = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); const _b = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function vb() { if (mb) return mb; if ("object" != typeof document || !document) return mb = new Set(_b), mb; let t = document.createElement("input"); return mb = new Set(_b.filter(e => (t.setAttribute("type", e), t.type === e))), mb } let bb, wb; function xb(t) { return function () { if (null == bb && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => bb = !0 })) } finally { bb = bb || !1 } return bb }() ? t : !!t.capture } function Cb(t) { if (function () { if (null == wb) { const t = "undefined" != typeof document ? document.head : null; wb = !(!t || !t.createShadowRoot && !t.attachShadow) } return wb }()) { const e = t.getRootNode ? t.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && e instanceof ShadowRoot) return e } return null } let Sb = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), kb = (() => { class t { constructor(t) { this._mutationObserverFactory = t, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((t, e) => this._cleanupObserver(e)) } observe(t) { const e = pb(t); return new b(t => { const n = this._observeElement(e).subscribe(t); return () => { n.unsubscribe(), this._unobserveElement(e) } }) } _observeElement(t) { if (this._observedElements.has(t)) this._observedElements.get(t).count++; else { const e = new k, n = this._mutationObserverFactory.create(t => e.next(t)); n && n.observe(t, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(t, { observer: n, stream: e, count: 1 }) } return this._observedElements.get(t).stream } _unobserveElement(t) { this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t)) } _cleanupObserver(t) { if (this._observedElements.has(t)) { const { observer: e, stream: n } = this._observedElements.get(t); e && e.disconnect(), n.complete(), this._observedElements.delete(t) } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Sb)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Sb)) }, token: t, providedIn: "root" }), t })(), Eb = (() => { class t { constructor(t, e, n) { this._contentObserver = t, this._elementRef = e, this._ngZone = n, this.event = new ql, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(t) { this._disabled = lb(t), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(t) { this._debounce = cb(t), this._subscribe() } ngAfterContentInit() { this._currentSubscription || this.disabled || this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const t = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? t.pipe(rb(this.debounce)) : t).subscribe(this.event) }) } _unsubscribe() { this._currentSubscription && this._currentSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(kb), Ao(Ua), Ao(Lc)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), Ob = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [Sb] }), t })(); function Ab(t, e) { return (t.getAttribute(e) || "").match(/\S+/g) || [] } let Tb = 0; const Pb = new Map; let Db = null, Ib = (() => { class t { constructor(t) { this._document = t } describe(t, e) { this._canBeDescribed(t, e) && ("string" != typeof e ? (this._setMessageId(e), Pb.set(e, { messageElement: e, referenceCount: 0 })) : Pb.has(e) || this._createMessageElement(e), this._isElementDescribedByMessage(t, e) || this._addMessageReference(t, e)) } removeDescription(t, e) { if (this._isElementNode(t)) { if (this._isElementDescribedByMessage(t, e) && this._removeMessageReference(t, e), "string" == typeof e) { const t = Pb.get(e); t && 0 === t.referenceCount && this._deleteMessageElement(e) } Db && 0 === Db.childNodes.length && this._deleteMessagesContainer() } } ngOnDestroy() { const t = this._document.querySelectorAll("[cdk-describedby-host]"); for (let e = 0; e < t.length; e++)this._removeCdkDescribedByReferenceIds(t[e]), t[e].removeAttribute("cdk-describedby-host"); Db && this._deleteMessagesContainer(), Pb.clear() } _createMessageElement(t) { const e = this._document.createElement("div"); this._setMessageId(e), e.textContent = t, this._createMessagesContainer(), Db.appendChild(e), Pb.set(t, { messageElement: e, referenceCount: 0 }) } _setMessageId(t) { t.id || (t.id = `cdk-describedby-message-${Tb++}`) } _deleteMessageElement(t) { const e = Pb.get(t), n = e && e.messageElement; Db && n && Db.removeChild(n), Pb.delete(t) } _createMessagesContainer() { if (!Db) { const t = this._document.getElementById("cdk-describedby-message-container"); t && t.parentNode.removeChild(t), Db = this._document.createElement("div"), Db.id = "cdk-describedby-message-container", Db.setAttribute("aria-hidden", "true"), Db.style.display = "none", this._document.body.appendChild(Db) } } _deleteMessagesContainer() { Db && Db.parentNode && (Db.parentNode.removeChild(Db), Db = null) } _removeCdkDescribedByReferenceIds(t) { const e = Ab(t, "aria-describedby").filter(t => 0 != t.indexOf("cdk-describedby-message")); t.setAttribute("aria-describedby", e.join(" ")) } _addMessageReference(t, e) { const n = Pb.get(e); !function (t, e, n) { const i = Ab(t, e); i.some(t => t.trim() == n.trim()) || (i.push(n.trim()), t.setAttribute(e, i.join(" "))) }(t, "aria-describedby", n.messageElement.id), t.setAttribute("cdk-describedby-host", ""), n.referenceCount++ } _removeMessageReference(t, e) { const n = Pb.get(e); n.referenceCount--, function (t, e, n) { const i = Ab(t, e).filter(t => t != n.trim()); i.length ? t.setAttribute(e, i.join(" ")) : t.removeAttribute(e) }(t, "aria-describedby", n.messageElement.id), t.removeAttribute("cdk-describedby-host") } _isElementDescribedByMessage(t, e) { const n = Ab(t, "aria-describedby"), i = Pb.get(e), r = i && i.messageElement.id; return !!r && -1 != n.indexOf(r) } _canBeDescribed(t, e) { if (!this._isElementNode(t)) return !1; if (e && "object" == typeof e) return !0; const n = null == e ? "" : `${e}`.trim(), i = t.getAttribute("aria-label"); return !(!n || i && i.trim() === n) } _isElementNode(t) { return t.nodeType === this._document.ELEMENT_NODE } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(ph)) }, token: t, providedIn: "root" }), t })(); class Rb { constructor(t) { this._items = t, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new k, this._typeaheadSubscription = u.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._skipPredicateFn = t => t.disabled, this._pressedLetters = [], this.tabOut = new k, this.change = new k, t instanceof Gl && t.changes.subscribe(t => { if (this._activeItem) { const e = t.toArray().indexOf(this._activeItem); e > -1 && e !== this._activeItemIndex && (this._activeItemIndex = e) } }) } skipPredicate(t) { return this._skipPredicateFn = t, this } withWrap(t = !0) { return this._wrap = t, this } withVerticalOrientation(t = !0) { return this._vertical = t, this } withHorizontalOrientation(t) { return this._horizontal = t, this } withAllowedModifierKeys(t) { return this._allowedModifierKeys = t, this } withTypeAhead(t = 200) { if (this._items.length && this._items.some(t => "function" != typeof t.getLabel)) throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method."); return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(am(t => this._pressedLetters.push(t)), rb(t), Of(() => this._pressedLetters.length > 0), N(() => this._pressedLetters.join(""))).subscribe(t => { const e = this._getItemsArray(); for (let n = 1; n < e.length + 1; n++) { const i = (this._activeItemIndex + n) % e.length, r = e[i]; if (!this._skipPredicateFn(r) && 0 === r.getLabel().toUpperCase().trim().indexOf(t)) { this.setActiveItem(i); break } } this._pressedLetters = [] }), this } setActiveItem(t) { const e = this._activeItemIndex; this.updateActiveItem(t), this._activeItemIndex !== e && this.change.next(this._activeItemIndex) } onKeydown(t) { const e = t.keyCode, n = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(e => !t[e] || this._allowedModifierKeys.indexOf(e) > -1); switch (e) { case 9: return void this.tabOut.next(); case 40: if (this._vertical && n) { this.setNextItemActive(); break } return; case 38: if (this._vertical && n) { this.setPreviousItemActive(); break } return; case 39: if (this._horizontal && n) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return; case 37: if (this._horizontal && n) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return; default: return void ((n || Zv(t, "shiftKey")) && (t.key && 1 === t.key.length ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e)))) }this._pressedLetters = [], t.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(t) { const e = this._getItemsArray(), n = "number" == typeof t ? t : e.indexOf(t), i = e[n]; this._activeItem = null == i ? null : i, this._activeItemIndex = n } _setActiveItemByDelta(t) { this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t) } _setActiveInWrapMode(t) { const e = this._getItemsArray(); for (let n = 1; n <= e.length; n++) { const i = (this._activeItemIndex + t * n + e.length) % e.length; if (!this._skipPredicateFn(e[i])) return void this.setActiveItem(i) } } _setActiveInDefaultMode(t) { this._setActiveItemByIndex(this._activeItemIndex + t, t) } _setActiveItemByIndex(t, e) { const n = this._getItemsArray(); if (n[t]) { for (; this._skipPredicateFn(n[t]);)if (!n[t += e]) return; this.setActiveItem(t) } } _getItemsArray() { return this._items instanceof Gl ? this._items.toArray() : this._items } } class Mb extends Rb { setActiveItem(t) { this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(t), this.activeItem && this.activeItem.setActiveStyles() } } class Lb extends Rb { constructor() { super(...arguments), this._origin = "program" } setFocusOrigin(t) { return this._origin = t, this } setActiveItem(t) { super.setActiveItem(t), this.activeItem && this.activeItem.focus(this._origin) } } "undefined" != typeof Element && Element; const Fb = new Bt("liveAnnouncerElement", { providedIn: "root", factory: function () { return null } }), Nb = new Bt("LIVE_ANNOUNCER_DEFAULT_OPTIONS"); let Vb = (() => { class t { constructor(t, e, n, i) { this._ngZone = e, this._defaultOptions = i, this._document = n, this._liveElement = t || this._createLiveElement() } announce(t, ...e) { const n = this._defaultOptions; let i, r; return 1 === e.length && "number" == typeof e[0] ? r = e[0] : [i, r] = e, this.clear(), clearTimeout(this._previousTimeout), i || (i = n && n.politeness ? n.politeness : "polite"), null == r && n && (r = n.duration), this._liveElement.setAttribute("aria-live", i), this._ngZone.runOutsideAngular(() => new Promise(e => { clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = t, e(), "number" == typeof r && (this._previousTimeout = setTimeout(() => this.clear(), r)) }, 100) })) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), this._liveElement = null) } _createLiveElement() { const t = this._document.getElementsByClassName("cdk-live-announcer-element"), e = this._document.createElement("div"); for (let n = 0; n < t.length; n++)t[n].parentNode.removeChild(t[n]); return e.classList.add("cdk-live-announcer-element"), e.classList.add("cdk-visually-hidden"), e.setAttribute("aria-atomic", "true"), e.setAttribute("aria-live", "polite"), this._document.body.appendChild(e), e } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Fb, 8), Kt(Lc), Kt(ph), Kt(Nb, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Fb, 8), Kt(Lc), Kt(ph), Kt(Nb, 8)) }, token: t, providedIn: "root" }), t })(); function jb(t) { return 0 === t.buttons } const Bb = new Bt("cdk-focus-monitor-default-options"), zb = xb({ passive: !0, capture: !0 }); let Hb = (() => { class t { constructor(t, e, n, i) { this._ngZone = t, this._platform = e, this._origin = null, this._windowFocused = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._documentKeydownListener = () => { this._lastTouchTarget = null, this._setOriginForCurrentEventQueue("keyboard") }, this._documentMousedownListener = t => { if (!this._lastTouchTarget) { const e = jb(t) ? "keyboard" : "mouse"; this._setOriginForCurrentEventQueue(e) } }, this._documentTouchstartListener = t => { null != this._touchTimeoutId && clearTimeout(this._touchTimeoutId), this._lastTouchTarget = Ub(t), this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, 650) }, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._rootNodeFocusAndBlurListener = t => { const e = Ub(t), n = "focus" === t.type ? this._onFocus : this._onBlur; for (let i = e; i; i = i.parentElement)n.call(this, t, i) }, this._document = n, this._detectionMode = (null == i ? void 0 : i.detectionMode) || 0 } monitor(t, e = !1) { if (!this._platform.isBrowser) return gf(null); const n = pb(t), i = Cb(n) || this._getDocument(); if (this._elementInfo.has(n)) { const t = this._elementInfo.get(n); return t.checkChildren = e, t.subject.asObservable() } const r = { checkChildren: e, subject: new k, rootNode: i }; return this._elementInfo.set(n, r), this._registerGlobalListeners(r), r.subject.asObservable() } stopMonitoring(t) { const e = pb(t), n = this._elementInfo.get(e); n && (n.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._removeGlobalListeners(n)) } focusVia(t, e, n) { const i = pb(t); this._setOriginForCurrentEventQueue(e), "function" == typeof i.focus && i.focus(n) } ngOnDestroy() { this._elementInfo.forEach((t, e) => this.stopMonitoring(e)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _toggleClass(t, e, n) { n ? t.classList.add(e) : t.classList.remove(e) } _getFocusOrigin(t) { return this._origin ? this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(t) ? "touch" : "program" } _setClasses(t, e) { this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e) } _setOriginForCurrentEventQueue(t) { this._ngZone.runOutsideAngular(() => { this._origin = t, 0 === this._detectionMode && (this._originTimeoutId = setTimeout(() => this._origin = null, 1)) }) } _wasCausedByTouch(t) { const e = Ub(t); return this._lastTouchTarget instanceof Node && e instanceof Node && (e === this._lastTouchTarget || e.contains(this._lastTouchTarget)) } _onFocus(t, e) { const n = this._elementInfo.get(e); if (!n || !n.checkChildren && e !== Ub(t)) return; const i = this._getFocusOrigin(t); this._setClasses(e, i), this._emitOrigin(n.subject, i), this._lastFocusOrigin = i } _onBlur(t, e) { const n = this._elementInfo.get(e); !n || n.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(n.subject, null)) } _emitOrigin(t, e) { this._ngZone.run(() => t.next(e)) } _registerGlobalListeners(t) { if (!this._platform.isBrowser) return; const e = t.rootNode, n = this._rootNodeFocusListenerCount.get(e) || 0; n || this._ngZone.runOutsideAngular(() => { e.addEventListener("focus", this._rootNodeFocusAndBlurListener, zb), e.addEventListener("blur", this._rootNodeFocusAndBlurListener, zb) }), this._rootNodeFocusListenerCount.set(e, n + 1), 1 == ++this._monitoredElementCount && this._ngZone.runOutsideAngular(() => { const t = this._getDocument(), e = this._getWindow(); t.addEventListener("keydown", this._documentKeydownListener, zb), t.addEventListener("mousedown", this._documentMousedownListener, zb), t.addEventListener("touchstart", this._documentTouchstartListener, zb), e.addEventListener("focus", this._windowFocusListener) }) } _removeGlobalListeners(t) { const e = t.rootNode; if (this._rootNodeFocusListenerCount.has(e)) { const t = this._rootNodeFocusListenerCount.get(e); t > 1 ? this._rootNodeFocusListenerCount.set(e, t - 1) : (e.removeEventListener("focus", this._rootNodeFocusAndBlurListener, zb), e.removeEventListener("blur", this._rootNodeFocusAndBlurListener, zb), this._rootNodeFocusListenerCount.delete(e)) } if (!--this._monitoredElementCount) { const t = this._getDocument(), e = this._getWindow(); t.removeEventListener("keydown", this._documentKeydownListener, zb), t.removeEventListener("mousedown", this._documentMousedownListener, zb), t.removeEventListener("touchstart", this._documentTouchstartListener, zb), e.removeEventListener("focus", this._windowFocusListener), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._touchTimeoutId), clearTimeout(this._originTimeoutId) } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Lc), Kt(gb), Kt(ph, 8), Kt(Bb, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Lc), Kt(gb), Kt(ph, 8), Kt(Bb, 8)) }, token: t, providedIn: "root" }), t })(); function Ub(t) { return t.composedPath ? t.composedPath()[0] : t.target } let $b = (() => { class t { constructor(t, e) { this._platform = t, this._document = e } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const t = this._document.createElement("div"); t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t); const e = this._document.defaultView || window, n = e && e.getComputedStyle ? e.getComputedStyle(t) : null, i = (n && n.backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(t), i) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (this._platform.isBrowser && this._document.body) { const t = this._document.body.classList; t.remove("cdk-high-contrast-active"), t.remove("cdk-high-contrast-black-on-white"), t.remove("cdk-high-contrast-white-on-black"); const e = this.getHighContrastMode(); 1 === e ? (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-black-on-white")) : 2 === e && (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-white-on-black")) } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(gb), Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(gb), Kt(ph)) }, token: t, providedIn: "root" }), t })(), qb = (() => { class t { constructor(t) { t._applyBodyHighContrastModeCssClasses() } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t)(Kt($b)) }, imports: [[yb, Ob]] }), t })(); const Wb = new Bt("cdk-dir-doc", { providedIn: "root", factory: function () { return Qt(ph) } }); let Gb = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new ql, t) { const e = t.documentElement ? t.documentElement.dir : null, n = (t.body ? t.body.dir : null) || e; this.value = "ltr" === n || "rtl" === n ? n : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Wb, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Wb, 8)) }, token: t, providedIn: "root" }), t })(), Yb = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); const Xb = new Ka("9.2.2"), Kb = ["*", [["mat-option"], ["ng-container"]]], Qb = ["*", "mat-option, ng-container"]; function Zb(t, e) { if (1 & t && Lo(0, "mat-pseudo-checkbox", 3), 2 & t) { const t = Go(); Do("state", t.selected ? "checked" : "unchecked")("disabled", t.disabled) } } const Jb = ["*"]; let tw = (() => { class t { } return t.STANDARD_CURVE = "cubic-bezier(0.4,0.0,0.2,1)", t.DECELERATION_CURVE = "cubic-bezier(0.0,0.0,0.2,1)", t.ACCELERATION_CURVE = "cubic-bezier(0.4,0.0,1,1)", t.SHARP_CURVE = "cubic-bezier(0.4,0.0,0.6,1)", t })(), ew = (() => { class t { } return t.COMPLEX = "375ms", t.ENTERING = "225ms", t.EXITING = "195ms", t })(); const nw = new Ka("9.2.2"), iw = new Bt("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let rw, sw = (() => { class t { constructor(t, e, n) { this._hasDoneGlobalChecks = !1, this._document = n, t._applyBodyHighContrastModeCssClasses(), this._sanityChecks = e, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _getDocument() { const t = this._document || document; return "object" == typeof t && t ? t : null } _getWindow() { const t = this._getDocument(), e = (null == t ? void 0 : t.defaultView) || window; return "object" == typeof e && e ? e : null } _checksAreEnabled() { return Ei() && !this._isTestEnv() } _isTestEnv() { const t = this._getWindow(); return t && (t.__karma__ || t.jasmine) } _checkDoctypeIsDefined() { const t = this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.doctype), e = this._getDocument(); t && e && !e.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { const t = !this._checksAreEnabled() || !1 === this._sanityChecks || !this._sanityChecks.theme, e = this._getDocument(); if (t || !e || !e.body || "function" != typeof getComputedStyle) return; const n = e.createElement("div"); n.classList.add("mat-theme-loaded-marker"), e.body.appendChild(n); const i = getComputedStyle(n); i && "none" !== i.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), e.body.removeChild(n) } _checkCdkVersionMatch() { this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.version) && nw.full !== Xb.full && console.warn("The Angular Material version (" + nw.full + ") does not match the Angular CDK version (" + Xb.full + ").\nPlease ensure the versions of these two packages exactly match.") } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t)(Kt($b), Kt(iw, 8), Kt(ph, 8)) }, imports: [[Yb], Yb] }), t })(); function ow(t) { return class extends t { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = lb(t) } } } function aw(t, e) { return class extends t { constructor(...t) { super(...t), this.color = e } get color() { return this._color } set color(t) { const n = t || e; n !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), n && this._elementRef.nativeElement.classList.add(`mat-${n}`), this._color = n) } } } function lw(t) { return class extends t { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = lb(t) } } } function cw(t, e = 0) { return class extends t { constructor(...t) { super(...t), this._tabIndex = e } get tabIndex() { return this.disabled ? -1 : this._tabIndex } set tabIndex(t) { this._tabIndex = null != t ? t : e } } } function hw(t) { return class extends t { constructor(...t) { super(...t), this.errorState = !1, this.stateChanges = new k } updateErrorState() { const t = this.errorState, e = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); e !== t && (this.errorState = e, this.stateChanges.next()) } } } function uw(t) { return class extends t { constructor(...t) { super(...t), this._isInitialized = !1, this._pendingSubscribers = [], this.initialized = new b(t => { this._isInitialized ? this._notifySubscriber(t) : this._pendingSubscribers.push(t) }) } _markInitialized() { if (this._isInitialized) throw Error("This directive has already been marked as initialized and should not be called twice."); this._isInitialized = !0, this._pendingSubscribers.forEach(this._notifySubscriber), this._pendingSubscribers = null } _notifySubscriber(t) { t.next(), t.complete() } } } try { rw = "undefined" != typeof Intl } catch (WM) { rw = !1 } let dw = (() => { class t { isErrorState(t, e) { return !!(t && t.invalid && (t.touched || e && e.submitted)) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); class pw { constructor(t, e, n) { this._renderer = t, this.element = e, this.config = n, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const fw = { enterDuration: 450, exitDuration: 400 }, mw = xb({ passive: !0 }), gw = ["mousedown", "touchstart"], yw = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class _w { constructor(t, e, n, i) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, i.isBrowser && (this._containerElement = pb(n)) } fadeInRipple(t, e, n = {}) { const i = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), r = Object.assign(Object.assign({}, fw), n.animation); n.centered && (t = i.left + i.width / 2, e = i.top + i.height / 2); const s = n.radius || function (t, e, n) { const i = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)), r = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom)); return Math.sqrt(i * i + r * r) }(t, e, i), o = t - i.left, a = e - i.top, l = r.enterDuration, c = document.createElement("div"); c.classList.add("mat-ripple-element"), c.style.left = `${o - s}px`, c.style.top = `${a - s}px`, c.style.height = `${2 * s}px`, c.style.width = `${2 * s}px`, null != n.color && (c.style.backgroundColor = n.color), c.style.transitionDuration = `${l}ms`, this._containerElement.appendChild(c), window.getComputedStyle(c).getPropertyValue("opacity"), c.style.transform = "scale(1)"; const h = new pw(this, c, n); return h.state = 0, this._activeRipples.add(h), n.persistent || (this._mostRecentTransientRipple = h), this._runTimeoutOutsideZone(() => { const t = h === this._mostRecentTransientRipple; h.state = 1, n.persistent || t && this._isPointerDown || h.fadeOut() }, l), h } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const n = t.element, i = Object.assign(Object.assign({}, fw), t.config.animation); n.style.transitionDuration = `${i.exitDuration}ms`, n.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => { t.state = 3, n.parentNode.removeChild(n) }, i.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } setupTriggerEvents(t) { const e = pb(t); e && e !== this._triggerElement && (this._removeTriggerEvents(), this._triggerElement = e, this._registerEvents(gw)) } handleEvent(t) { "mousedown" === t.type ? this._onMousedown(t) : "touchstart" === t.type ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(yw), this._pointerUpEventsRegistered = !0) } _onMousedown(t) { const e = jb(t), n = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; this._target.rippleDisabled || e || n || (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) } _onTouchStart(t) { if (!this._target.rippleDisabled) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let t = 0; t < e.length; t++)this.fadeInRipple(e[t].clientX, e[t].clientY, this._target.rippleConfig) } } _onPointerUp() { this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(t => { !t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut() })) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _registerEvents(t) { this._ngZone.runOutsideAngular(() => { t.forEach(t => { this._triggerElement.addEventListener(t, this, mw) }) }) } _removeTriggerEvents() { this._triggerElement && (gw.forEach(t => { this._triggerElement.removeEventListener(t, this, mw) }), this._pointerUpEventsRegistered && yw.forEach(t => { this._triggerElement.removeEventListener(t, this, mw) })) } } const vw = new Bt("mat-ripple-global-options"); let bw = (() => { class t { constructor(t, e, n, i, r) { this._elementRef = t, this._animationMode = r, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = i || {}, this._rippleRenderer = new _w(this, e, t, n) } get disabled() { return this._disabled } set disabled(t) { this._disabled = t, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(t) { this._trigger = t, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(t, e = 0, n) { return "number" == typeof t ? this._rippleRenderer.fadeInRipple(t, e, Object.assign(Object.assign({}, this.rippleConfig), n)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), t)) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Lc), Ao(gb), Ao(vw, 8), Ao(pf, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (t, e) { 2 & t && sa("mat-ripple-unbounded", e.unbounded) }, inputs: { radius: ["matRippleRadius", "radius"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"], color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], animation: ["matRippleAnimation", "animation"] }, exportAs: ["matRipple"] }), t })(), ww = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[sw, yb], sw] }), t })(), xw = (() => { class t { constructor(t) { this._animationMode = t, this.state = "unchecked", this.disabled = !1 } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pf, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-pseudo-checkbox"]], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 8, hostBindings: function (t, e) { 2 & t && sa("mat-pseudo-checkbox-indeterminate", "indeterminate" === e.state)("mat-pseudo-checkbox-checked", "checked" === e.state)("mat-pseudo-checkbox-disabled", e.disabled)("_mat-animation-noopable", "NoopAnimations" === e._animationMode) }, inputs: { state: "state", disabled: "disabled" }, decls: 0, vars: 0, template: function (t, e) { }, styles: ['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'], encapsulation: 2, changeDetection: 0 }), t })(), Cw = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); class Sw { } const kw = ow(Sw); let Ew = 0, Ow = (() => { class t extends kw { constructor() { super(...arguments), this._labelId = `mat-optgroup-label-${Ew++}` } } return t.\u0275fac = function (e) { return Aw(e || t) }, t.\u0275cmp = me({ type: t, selectors: [["mat-optgroup"]], hostAttrs: ["role", "group", 1, "mat-optgroup"], hostVars: 4, hostBindings: function (t, e) { 2 & t && (So("aria-disabled", e.disabled.toString())("aria-labelledby", e._labelId), sa("mat-optgroup-disabled", e.disabled)) }, inputs: { disabled: "disabled", label: "label" }, exportAs: ["matOptgroup"], features: [Ca], ngContentSelectors: Qb, decls: 4, vars: 2, consts: [[1, "mat-optgroup-label", 3, "id"]], template: function (t, e) { 1 & t && (Xo(Kb), Ro(0, "label", 0), ga(1), Ko(2), Mo(), Ko(3, 1)), 2 & t && (Do("id", e._labelId), yr(1), _a("", e.label, " ")) }, styles: [".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }), t })(); const Aw = hi(Ow); let Tw = 0; class Pw { constructor(t, e = !1) { this.source = t, this.isUserInput = e } } const Dw = new Bt("MAT_OPTION_PARENT_COMPONENT"); let Iw = (() => { class t { constructor(t, e, n, i) { this._element = t, this._changeDetectorRef = e, this._parent = n, this.group = i, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = `mat-option-${Tw++}`, this.onSelectionChange = new ql, this._stateChanges = new k } get multiple() { return this._parent && this._parent.multiple } get selected() { return this._selected } get disabled() { return this.group && this.group.disabled || this._disabled } set disabled(t) { this._disabled = lb(t) } get disableRipple() { return this._parent && this._parent.disableRipple } get active() { return this._active } get viewValue() { return (this._getHostElement().textContent || "").trim() } select() { this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } deselect() { this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } focus(t, e) { const n = this._getHostElement(); "function" == typeof n.focus && n.focus(e) } setActiveStyles() { this._active || (this._active = !0, this._changeDetectorRef.markForCheck()) } setInactiveStyles() { this._active && (this._active = !1, this._changeDetectorRef.markForCheck()) } getLabel() { return this.viewValue } _handleKeydown(t) { 13 !== t.keyCode && 32 !== t.keyCode || Zv(t) || (this._selectViaInteraction(), t.preventDefault()) } _selectViaInteraction() { this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0)) } _getAriaSelected() { return this.selected || !this.multiple && null } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._element.nativeElement } ngAfterViewChecked() { if (this._selected) { const t = this.viewValue; t !== this._mostRecentViewValue && (this._mostRecentViewValue = t, this._stateChanges.next()) } } ngOnDestroy() { this._stateChanges.complete() } _emitSelectionChangeEvent(t = !1) { this.onSelectionChange.emit(new Pw(this, t)) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Ws), Ao(Dw, 8), Ao(Ow, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-option"]], hostAttrs: ["role", "option", 1, "mat-option", "mat-focus-indicator"], hostVars: 12, hostBindings: function (t, e) { 1 & t && Ho("click", (function () { return e._selectViaInteraction() }))("keydown", (function (t) { return e._handleKeydown(t) })), 2 & t && (ba("id", e.id), So("tabindex", e._getTabIndex())("aria-selected", e._getAriaSelected())("aria-disabled", e.disabled.toString()), sa("mat-selected", e.selected)("mat-option-multiple", e.multiple)("mat-active", e.active)("mat-option-disabled", e.disabled)) }, inputs: { id: "id", disabled: "disabled", value: "value" }, outputs: { onSelectionChange: "onSelectionChange" }, exportAs: ["matOption"], ngContentSelectors: Jb, decls: 4, vars: 3, consts: [["class", "mat-option-pseudo-checkbox", 3, "state", "disabled", 4, "ngIf"], [1, "mat-option-text"], ["mat-ripple", "", 1, "mat-option-ripple", 3, "matRippleTrigger", "matRippleDisabled"], [1, "mat-option-pseudo-checkbox", 3, "state", "disabled"]], template: function (t, e) { 1 & t && (Xo(), Eo(0, Zb, 1, 2, "mat-pseudo-checkbox", 0), Ro(1, "span", 1), Ko(2), Mo(), Lo(3, "div", 2)), 2 & t && (Do("ngIf", e.multiple), yr(3), Do("matRippleTrigger", e._getHostElement())("matRippleDisabled", e.disabled || e.disableRipple)) }, directives: [$h, bw, xw], styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.cdk-high-contrast-active .mat-option .mat-option-ripple{opacity:.5}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }), t })(); function Rw(t, e, n) { if (n.length) { let i = e.toArray(), r = n.toArray(), s = 0; for (let e = 0; e < t + 1; e++)i[e].group && i[e].group === r[s] && s++; return s } return 0 } function Mw(t, e, n, i) { const r = t * e; return r < n ? r : r + e > n + i ? Math.max(0, r - i + e) : n } let Lw = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[ww, au, Cw]] }), t })(); const Fw = new Bt("mat-label-global-options"); let Nw = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[sw], sw] }), t })(); function Vw(t, e, n, r) { return i(n) && (r = n, n = void 0), r ? Vw(t, e, n).pipe(N(t => l(t) ? r(...t) : r(t))) : new b(i => { !function t(e, n, i, r, s) { let o; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(e)) { const t = e; e.addEventListener(n, i, s), o = () => t.removeEventListener(n, i, s) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(e)) { const t = e; e.on(n, i), o = () => t.off(n, i) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(e)) { const t = e; e.addListener(n, i), o = () => t.removeListener(n, i) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let o = 0, a = e.length; o < a; o++)t(e[o], n, i, r, s) } r.add(o) }(t, e, (function (t) { i.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }), i, n) }) } function jw(t) { return e => e.lift(new Bw(t)) } class Bw { constructor(t) { this.notifier = t } call(t, e) { const n = new zw(t), i = L(n, this.notifier); return i && !n.seenValue ? (n.add(i), e.subscribe(n)) : n } } class zw extends F { constructor(t) { super(t), this.seenValue = !1 } notifyNext(t, e, n, i, r) { this.seenValue = !0, this.complete() } notifyComplete() { } } const Hw = ["underline"], Uw = ["connectionContainer"], $w = ["inputContainer"], qw = ["label"]; function Ww(t, e) { 1 & t && (Fo(0), Ro(1, "div", 14), Lo(2, "div", 15), Lo(3, "div", 16), Lo(4, "div", 17), Mo(), Ro(5, "div", 18), Lo(6, "div", 15), Lo(7, "div", 16), Lo(8, "div", 17), Mo(), No()) } function Gw(t, e) { 1 & t && (Ro(0, "div", 19), Ko(1, 1), Mo()) } function Yw(t, e) { if (1 & t && (Fo(0), Ko(1, 2), Ro(2, "span"), ga(3), Mo(), No()), 2 & t) { const t = Go(2); yr(3), ya(t._control.placeholder) } } function Xw(t, e) { 1 & t && Ko(0, 3, ["*ngSwitchCase", "true"]) } function Kw(t, e) { 1 & t && (Ro(0, "span", 23), ga(1, " *"), Mo()) } function Qw(t, e) { if (1 & t) { const t = jo(); Ro(0, "label", 20, 21), Ho("cdkObserveContent", (function () { return Ze(t), Go().updateOutlineGap() })), Eo(2, Yw, 4, 1, "ng-container", 12), Eo(3, Xw, 1, 0, void 0, 12), Eo(4, Kw, 2, 0, "span", 22), Mo() } if (2 & t) { const t = Go(); sa("mat-empty", t._control.empty && !t._shouldAlwaysFloat)("mat-form-field-empty", t._control.empty && !t._shouldAlwaysFloat)("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color), Do("cdkObserveContentDisabled", "outline" != t.appearance)("id", t._labelId)("ngSwitch", t._hasLabel()), So("for", t._control.id)("aria-owns", t._control.id), yr(2), Do("ngSwitchCase", !1), yr(1), Do("ngSwitchCase", !0), yr(1), Do("ngIf", !t.hideRequiredMarker && t._control.required && !t._control.disabled) } } function Zw(t, e) { 1 & t && (Ro(0, "div", 24), Ko(1, 4), Mo()) } function Jw(t, e) { if (1 & t && (Ro(0, "div", 25, 26), Lo(2, "span", 27), Mo()), 2 & t) { const t = Go(); yr(2), sa("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color) } } function tx(t, e) { 1 & t && (Ro(0, "div"), Ko(1, 5), Mo()), 2 & t && Do("@transitionMessages", Go()._subscriptAnimationState) } function ex(t, e) { if (1 & t && (Ro(0, "div", 31), ga(1), Mo()), 2 & t) { const t = Go(2); Do("id", t._hintLabelId), yr(1), ya(t.hintLabel) } } function nx(t, e) { if (1 & t && (Ro(0, "div", 28), Eo(1, ex, 2, 2, "div", 29), Ko(2, 6), Lo(3, "div", 30), Ko(4, 7), Mo()), 2 & t) { const t = Go(); Do("@transitionMessages", t._subscriptAnimationState), yr(1), Do("ngIf", t.hintLabel) } } const ix = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], rx = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"]; let sx = 0, ox = (() => { class t { constructor() { this.id = `mat-error-${sx++}` } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-error"]], hostAttrs: ["role", "alert", 1, "mat-error"], hostVars: 1, hostBindings: function (t, e) { 2 & t && So("id", e.id) }, inputs: { id: "id" } }), t })(); const ax = { transitionMessages: qu("transitionMessages", [Ku("enter", Xu({ opacity: 1, transform: "translateY(0%)" })), Zu("void => enter", [Xu({ opacity: 0, transform: "translateY(-100%)" }), Wu("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let lx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t }), t })(); function cx(t) { return Error(`A hint was already declared for 'align="${t}"'.`) } let hx = 0, ux = (() => { class t { constructor() { this.align = "start", this.id = `mat-hint-${hx++}` } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-hint"]], hostAttrs: [1, "mat-hint"], hostVars: 4, hostBindings: function (t, e) { 2 & t && (So("id", e.id)("align", null), sa("mat-right", "end" == e.align)) }, inputs: { align: "align", id: "id" } }), t })(), dx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-label"]] }), t })(), px = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-placeholder"]] }), t })(), fx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matPrefix", ""]] }), t })(), mx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matSuffix", ""]] }), t })(), gx = 0; class yx { constructor(t) { this._elementRef = t } } const _x = aw(yx, "primary"), vx = new Bt("MAT_FORM_FIELD_DEFAULT_OPTIONS"), bx = new Bt("MatFormField"); let wx = (() => { class t extends _x { constructor(t, e, n, i, r, s, o, a) { super(t), this._elementRef = t, this._changeDetectorRef = e, this._dir = i, this._defaults = r, this._platform = s, this._ngZone = o, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new k, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = `mat-hint-${gx++}`, this._labelId = `mat-form-field-label-${gx++}`, this._labelOptions = n || {}, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== a, this.appearance = r && r.appearance ? r.appearance : "legacy", this._hideRequiredMarker = !(!r || null == r.hideRequiredMarker) && r.hideRequiredMarker } get appearance() { return this._appearance } set appearance(t) { const e = this._appearance; this._appearance = t || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && e !== t && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(t) { this._hideRequiredMarker = lb(t) } get _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } get _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(t) { this._hintLabel = t, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(t) { t !== this._floatLabel && (this._floatLabel = t || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(t) { this._explicitFormFieldControl = t } get _labelChild() { return this._labelChildNonStatic || this._labelChildStatic } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const t = this._control; t.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${t.controlType}`), t.stateChanges.pipe(em(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), t.ngControl && t.ngControl.valueChanges && t.ngControl.valueChanges.pipe(jw(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.asObservable().pipe(jw(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), G(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe(em(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe(em(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(jw(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(t) { const e = this._control ? this._control.ngControl : null; return e && e[t] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !!this._labelChild } _shouldLabelFloat() { return this._canLabelFloat && (this._control.shouldLabelFloat || this._shouldAlwaysFloat) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Vw(this._label.nativeElement, "transitionend").pipe(qf(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { if (this._control.placeholder && this._placeholderChild) throw Error("Placeholder attribute and child element were both specified.") } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { if (this._hintChildren) { let t, e; this._hintChildren.forEach(n => { if ("start" === n.align) { if (t || this.hintLabel) throw cx("start"); t = n } else if ("end" === n.align) { if (e) throw cx("end"); e = n } }) } } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || this._labelOptions.float || "auto" } _syncDescribedByIds() { if (this._control) { let t = []; if ("hint" === this._getDisplayedMessages()) { const e = this._hintChildren ? this._hintChildren.find(t => "start" === t.align) : null, n = this._hintChildren ? this._hintChildren.find(t => "end" === t.align) : null; e ? t.push(e.id) : this._hintLabel && t.push(this._hintLabelId), n && t.push(n.id) } else this._errorChildren && (t = this._errorChildren.map(t => t.id)); this._control.setDescribedByIds(t) } } _validateControlChild() { if (!this._control) throw Error("mat-form-field must contain a MatFormFieldControl.") } updateOutlineGap() { const t = this._label ? this._label.nativeElement : null; if ("outline" !== this.appearance || !t || !t.children.length || !t.textContent.trim()) return; if (!this._platform.isBrowser) return; if (!this._isAttachedToDOM()) return void (this._outlineGapCalculationNeededImmediately = !0); let e = 0, n = 0; const i = this._connectionContainerRef.nativeElement, r = i.querySelectorAll(".mat-form-field-outline-start"), s = i.querySelectorAll(".mat-form-field-outline-gap"); if (this._label && this._label.nativeElement.children.length) { const r = i.getBoundingClientRect(); if (0 === r.width && 0 === r.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const s = this._getStartEnd(r), o = this._getStartEnd(t.children[0].getBoundingClientRect()); let a = 0; for (const e of t.children) a += e.offsetWidth; e = Math.abs(o - s) - 5, n = a > 0 ? .75 * a + 10 : 0 } for (let o = 0; o < r.length; o++)r[o].style.width = `${e}px`; for (let o = 0; o < s.length; o++)s[o].style.width = `${n}px`; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(t) { return this._dir && "rtl" === this._dir.value ? t.right : t.left } _isAttachedToDOM() { const t = this._elementRef.nativeElement; if (t.getRootNode) { const e = t.getRootNode(); return e && e !== t } return document.documentElement.contains(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Ws), Ao(Fw, 8), Ao(Gb, 8), Ao(vx, 8), Ao(gb), Ao(Lc), Ao(pf, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-form-field"]], contentQueries: function (t, e, n) { var i; 1 & t && (oc(n, lx, !0), ac(n, lx, !0), oc(n, dx, !0), ac(n, dx, !0), oc(n, px, !0), oc(n, ox, !0), oc(n, ux, !0), oc(n, fx, !0), oc(n, mx, !0)), 2 & t && (nc(i = cc()) && (e._controlNonStatic = i.first), nc(i = cc()) && (e._controlStatic = i.first), nc(i = cc()) && (e._labelChildNonStatic = i.first), nc(i = cc()) && (e._labelChildStatic = i.first), nc(i = cc()) && (e._placeholderChild = i.first), nc(i = cc()) && (e._errorChildren = i), nc(i = cc()) && (e._hintChildren = i), nc(i = cc()) && (e._prefixChildren = i), nc(i = cc()) && (e._suffixChildren = i)) }, viewQuery: function (t, e) { var n; 1 & t && (rc(Hw, !0), ic(Uw, !0), rc($w, !0), rc(qw, !0)), 2 & t && (nc(n = cc()) && (e.underlineRef = n.first), nc(n = cc()) && (e._connectionContainerRef = n.first), nc(n = cc()) && (e._inputContainerRef = n.first), nc(n = cc()) && (e._label = n.first)) }, hostAttrs: [1, "mat-form-field"], hostVars: 44, hostBindings: function (t, e) { 2 & t && sa("mat-form-field-appearance-standard", "standard" == e.appearance)("mat-form-field-appearance-fill", "fill" == e.appearance)("mat-form-field-appearance-outline", "outline" == e.appearance)("mat-form-field-appearance-legacy", "legacy" == e.appearance)("mat-form-field-invalid", e._control.errorState)("mat-form-field-can-float", e._canLabelFloat)("mat-form-field-should-float", e._shouldLabelFloat())("mat-form-field-has-label", e._hasFloatingLabel())("mat-form-field-hide-placeholder", e._hideControlPlaceholder())("mat-form-field-disabled", e._control.disabled)("mat-form-field-autofilled", e._control.autofilled)("mat-focused", e._control.focused)("mat-accent", "accent" == e.color)("mat-warn", "warn" == e.color)("ng-untouched", e._shouldForward("untouched"))("ng-touched", e._shouldForward("touched"))("ng-pristine", e._shouldForward("pristine"))("ng-dirty", e._shouldForward("dirty"))("ng-valid", e._shouldForward("valid"))("ng-invalid", e._shouldForward("invalid"))("ng-pending", e._shouldForward("pending"))("_mat-animation-noopable", !e._animationsEnabled) }, inputs: { color: "color", floatLabel: "floatLabel", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [ja([{ provide: bx, useExisting: t }]), Ca], ngContentSelectors: rx, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], ["underline", ""], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function (t, e) { 1 & t && (Xo(ix), Ro(0, "div", 0), Ro(1, "div", 1, 2), Ho("click", (function (t) { return e._control.onContainerClick && e._control.onContainerClick(t) })), Eo(3, Ww, 9, 0, "ng-container", 3), Eo(4, Gw, 2, 0, "div", 4), Ro(5, "div", 5, 6), Ko(7), Ro(8, "span", 7), Eo(9, Qw, 5, 16, "label", 8), Mo(), Mo(), Eo(10, Zw, 2, 0, "div", 9), Mo(), Eo(11, Jw, 3, 4, "div", 10), Ro(12, "div", 11), Eo(13, tx, 2, 1, "div", 12), Eo(14, nx, 5, 2, "div", 13), Mo(), Mo()), 2 & t && (yr(3), Do("ngIf", "outline" == e.appearance), yr(1), Do("ngIf", e._prefixChildren.length), yr(5), Do("ngIf", e._hasFloatingLabel()), yr(1), Do("ngIf", e._suffixChildren.length), yr(1), Do("ngIf", "outline" != e.appearance), yr(1), Do("ngSwitch", e._getDisplayedMessages()), yr(1), Do("ngSwitchCase", "error"), yr(1), Do("ngSwitchCase", "hint")) }, directives: [$h, Yh, Xh, Eb], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:scaleX(1);transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n', '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"], encapsulation: 2, data: { animation: [ax.transitionMessages] }, changeDetection: 0 }), t })(), xx = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[au, Ob]] }), t })(); class Cx { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new Sx(t, this.durationSelector)) } } class Sx extends F { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let n; try { const { durationSelector: e } = this; n = e(t) } catch (e) { return this.destination.error(e) } const i = L(this, n); !i || i.closed ? this.clearThrottle() : this.add(this.throttled = i) } } clearThrottle() { const { value: t, hasValue: e, throttled: n } = this; n && (this.remove(n), this.throttled = null, n.unsubscribe()), e && (this.value = null, this.hasValue = !1, this.destination.next(t)) } notifyNext(t, e, n, i) { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function kx(t) { return !l(t) && t - parseFloat(t) + 1 >= 0 } function Ex(t) { const { index: e, period: n, subscriber: i } = t; if (i.next(e), !i.closed) { if (-1 === n) return i.complete(); t.index = e + 1, this.schedule(t, n) } } function Ox(t, e = ib) { return n = () => function (t = 0, e, n) { let i = -1; return kx(e) ? i = Number(e) < 1 ? 1 : Number(e) : O(e) && (n = e), O(n) || (n = ib), new b(e => { const r = kx(t) ? t : +t - n.now(); return n.schedule(Ex, r, { index: 0, period: i, subscriber: e }) }) }(t, e), function (t) { return t.lift(new Cx(n)) }; var n } const Ax = xb({ passive: !0 }); let Tx = (() => { class t { constructor(t, e) { this._platform = t, this._ngZone = e, this._monitoredElements = new Map } monitor(t) { if (!this._platform.isBrowser) return Cf; const e = pb(t), n = this._monitoredElements.get(e); if (n) return n.subject.asObservable(); const i = new k, r = "cdk-text-field-autofilled", s = t => { "cdk-text-field-autofill-start" !== t.animationName || e.classList.contains(r) ? "cdk-text-field-autofill-end" === t.animationName && e.classList.contains(r) && (e.classList.remove(r), this._ngZone.run(() => i.next({ target: t.target, isAutofilled: !1 }))) : (e.classList.add(r), this._ngZone.run(() => i.next({ target: t.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { e.addEventListener("animationstart", s, Ax), e.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(e, { subject: i, unlisten: () => { e.removeEventListener("animationstart", s, Ax) } }), i.asObservable() } stopMonitoring(t) { const e = pb(t), n = this._monitoredElements.get(e); n && (n.unlisten(), n.subject.complete(), e.classList.remove("cdk-text-field-autofill-monitored"), e.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(e)) } ngOnDestroy() { this._monitoredElements.forEach((t, e) => this.stopMonitoring(e)) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(gb), Kt(Lc)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(gb), Kt(Lc)) }, token: t, providedIn: "root" }), t })(), Px = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[yb]] }), t })(); const Dx = new Bt("MAT_INPUT_VALUE_ACCESSOR"), Ix = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let Rx = 0; class Mx { constructor(t, e, n, i) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = i } } const Lx = hw(Mx); let Fx = (() => { class t extends Lx { constructor(t, e, n, i, r, s, o, a, l) { super(s, i, r, n), this._elementRef = t, this._platform = e, this.ngControl = n, this._autofillMonitor = a, this._uid = `mat-input-${Rx++}`, this._isServer = !1, this._isNativeSelect = !1, this.focused = !1, this.stateChanges = new k, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(t => vb().has(t)); const c = this._elementRef.nativeElement; this._inputValueAccessor = o || c, this._previousNativeValue = this.value, this.id = this.id, e.IOS && l.runOutsideAngular(() => { t.nativeElement.addEventListener("keyup", t => { let e = t.target; e.value || e.selectionStart || e.selectionEnd || (e.setSelectionRange(1, 1), e.setSelectionRange(0, 0)) }) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === c.nodeName.toLowerCase(), this._isNativeSelect && (this.controlType = c.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = lb(t), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(t) { this._id = t || this._uid } get required() { return this._required } set required(t) { this._required = lb(t) } get type() { return this._type } set type(t) { this._type = t || "text", this._validateType(), !this._isTextarea() && vb().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(t) { t !== this.value && (this._inputValueAccessor.value = t, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(t) { this._readonly = lb(t) } ngOnInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t => { this.autofilled = t.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue() } focus(t) { this._elementRef.nativeElement.focus(t) } _focusChanged(t) { t === this.focused || this.readonly && t || (this.focused = t, this.stateChanges.next()) } _onInput() { } _isTextarea() { return "textarea" === this._elementRef.nativeElement.nodeName.toLowerCase() } _dirtyCheckNativeValue() { const t = this._elementRef.nativeElement.value; this._previousNativeValue !== t && (this._previousNativeValue = t, this.stateChanges.next()) } _validateType() { if (Ix.indexOf(this._type) > -1) throw Error(`Input type "${this._type}" isn't supported by matInput.`) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let t = this._elementRef.nativeElement.validity; return t && t.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const t = this._elementRef.nativeElement, e = t.options[0]; return this.focused || t.multiple || !this.empty || !!(t.selectedIndex > -1 && e && e.label) } return this.focused || !this.empty } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } onContainerClick() { this.focused || this.focus() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(gb), Ao(z_, 10), Ao(Lv, 8), Ao(zv, 8), Ao(dw), Ao(Dx, 10), Ao(Tx), Ao(Lc)) }, t.\u0275dir = we({ type: t, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 10, hostBindings: function (t, e) { 1 & t && Ho("focus", (function () { return e._focusChanged(!0) }))("blur", (function () { return e._focusChanged(!1) }))("input", (function () { return e._onInput() })), 2 & t && (ba("disabled", e.disabled)("required", e.required), So("id", e.id)("placeholder", e.placeholder)("readonly", e.readonly && !e._isNativeSelect || null)("aria-describedby", e._ariaDescribedby || null)("aria-invalid", e.errorState)("aria-required", e.required.toString()), sa("mat-input-server", e._isServer)) }, inputs: { id: "id", disabled: "disabled", required: "required", type: "type", value: "value", readonly: "readonly", placeholder: "placeholder", errorStateMatcher: "errorStateMatcher" }, exportAs: ["matInput"], features: [ja([{ provide: lx, useExisting: t }]), Ca, Ta] }), t })(), Nx = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [dw], imports: [[Px, xx], Px, xx] }), t })(); function Vx(t) { return !!t && (t instanceof b || "function" == typeof t.lift && "function" == typeof t.subscribe) } function jx(t, e) { return n => n.lift(new Bx(t, e)) } class Bx { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new zx(t, this.compare, this.keySelector)) } } class zx extends f { constructor(t, e, n) { super(t), this.keySelector = n, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: n } = this; e = n ? n(t) : t } catch (i) { return this.destination.error(i) } let n = !1; if (this.hasKey) try { const { compare: t } = this; n = t(this.key, e) } catch (i) { return this.destination.error(i) } else this.hasKey = !0; n || (this.key = e, this.destination.next(t)) } } function Hx(t, e) { return new b(e ? n => e.schedule(Ux, 0, { error: t, subscriber: n }) : e => e.error(t)) } function Ux({ error: t, subscriber: e }) { e.error(t) } let $x = (() => { class t { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return gf(this.value); case "E": return Hx(this.error); case "C": return Sf() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })(); class qx { } function Wx(t) { return t && "function" == typeof t.connect } class Gx { constructor(t = !1, e, n = !0) { this._multiple = t, this._emitChanges = n, this._selection = new Set, this._deselectedToEmit = [], this._selectedToEmit = [], this.changed = new k, e && e.length && (t ? e.forEach(t => this._markSelected(t)) : this._markSelected(e[0]), this._selectedToEmit.length = 0) } get selected() { return this._selected || (this._selected = Array.from(this._selection.values())), this._selected } select(...t) { this._verifyValueAssignment(t), t.forEach(t => this._markSelected(t)), this._emitChangeEvent() } deselect(...t) { this._verifyValueAssignment(t), t.forEach(t => this._unmarkSelected(t)), this._emitChangeEvent() } toggle(t) { this.isSelected(t) ? this.deselect(t) : this.select(t) } clear() { this._unmarkAll(), this._emitChangeEvent() } isSelected(t) { return this._selection.has(t) } isEmpty() { return 0 === this._selection.size } hasValue() { return !this.isEmpty() } sort(t) { this._multiple && this.selected && this._selected.sort(t) } isMultipleSelection() { return this._multiple } _emitChangeEvent() { this._selected = null, (this._selectedToEmit.length || this._deselectedToEmit.length) && (this.changed.next({ source: this, added: this._selectedToEmit, removed: this._deselectedToEmit }), this._deselectedToEmit = [], this._selectedToEmit = []) } _markSelected(t) { this.isSelected(t) || (this._multiple || this._unmarkAll(), this._selection.add(t), this._emitChanges && this._selectedToEmit.push(t)) } _unmarkSelected(t) { this.isSelected(t) && (this._selection.delete(t), this._emitChanges && this._deselectedToEmit.push(t)) } _unmarkAll() { this.isEmpty() || this._selection.forEach(t => this._unmarkSelected(t)) } _verifyValueAssignment(t) { if (t.length > 1 && !this._multiple) throw Error("Cannot pass multiple values into SelectionModel with single-value mode.") } } let Yx = (() => { class t { constructor() { this._listeners = [] } notify(t, e) { for (let n of this._listeners) n(t, e) } listen(t) { return this._listeners.push(t), () => { this._listeners = this._listeners.filter(e => t !== e) } } ngOnDestroy() { this._listeners = [] } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), Xx = (() => { class t { constructor(t, e, n) { this._ngZone = t, this._platform = e, this._scrolled = new k, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = n } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new b(e => { this._globalSubscription || this._addGlobalListener(); const n = t > 0 ? this._scrolled.pipe(Ox(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { n.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : gf() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const n = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(Of(t => !t || n.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((n, i) => { this._scrollableContainsElement(i, t) && e.push(i) }), e } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _scrollableContainsElement(t, e) { let n = e.nativeElement, i = t.getElementRef().nativeElement; do { if (n == i) return !0 } while (n = n.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => Vw(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Lc), Kt(gb), Kt(ph, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Lc), Kt(gb), Kt(ph, 8)) }, token: t, providedIn: "root" }), t })(), Kx = (() => { class t { constructor(t, e, n) { this._platform = t, this._document = n, e.runOutsideAngular(() => { const e = this._getWindow(); this._change = t.isBrowser ? G(Vw(e, "resize"), Vw(e, "orientationchange")) : gf(), this._invalidateCache = this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { this._invalidateCache.unsubscribe() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: n } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + n, right: t.left + e, height: n, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._getDocument(), e = this._getWindow(), n = t.documentElement, i = n.getBoundingClientRect(); return { top: -i.top || t.body.scrollTop || e.scrollY || n.scrollTop || 0, left: -i.left || t.body.scrollLeft || e.scrollX || n.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(Ox(t)) : this._change } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _updateViewportSize() { const t = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(gb), Kt(Lc), Kt(ph, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(gb), Kt(Lc), Kt(ph, 8)) }, token: t, providedIn: "root" }), t })(), Qx = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(), Zx = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[Yb, yb, Qx], Yb, Qx] }), t })(); function Jx() { throw Error("Host already has a portal attached") } class tC { attach(t) { return null == t && function () { throw Error("Attempting to attach a portal to a null PortalOutlet") }(), t.hasAttached() && Jx(), this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null == t ? function () { throw Error("Attempting to detach a portal that is not attached to a host") }() : (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class eC extends tC { constructor(t, e, n, i) { super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.componentFactoryResolver = i } } class nC extends tC { constructor(t, e, n) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = n } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class iC extends tC { constructor(t) { super(), this.element = t instanceof Ua ? t.nativeElement : t } } class rC { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t || function () { throw Error("Must provide a portal to attach") }(), this.hasAttached() && Jx(), this._isDisposed && function () { throw Error("This PortalOutlet has already been disposed") }(), t instanceof eC ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof nC ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof iC ? (this._attachedPortal = t, this.attachDomPortal(t)) : void function () { throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.") }() } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class sC extends rC { constructor(t, e, n, i, r) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = n, this._defaultInjector = i, this.attachDomPortal = t => { if (!this._document) throw Error("Cannot attach DOM portal without _document constructor parameter"); const e = t.element; if (!e.parentNode) throw Error("DOM portal content must be attached to a parent node."); const n = this._document.createComment("dom-portal"); e.parentNode.insertBefore(n, e), this.outletElement.appendChild(e), super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = r } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let n; return t.viewContainerRef ? (n = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => n.destroy())) : (n = e.create(t.injector || this._defaultInjector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => { this._appRef.detachView(n.hostView), n.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(n)), n } attachTemplatePortal(t) { let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context); return n.detectChanges(), n.rootNodes.forEach(t => this.outletElement.appendChild(t)), this.setDisposeFn(() => { let t = e.indexOf(n); -1 !== t && e.remove(t) }), n } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let oC = (() => { class t extends rC { constructor(t, e, n) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new ql, this.attachDomPortal = t => { if (!this._document) throw Error("Cannot attach DOM portal without _document constructor parameter"); const e = t.element; if (!e.parentNode) throw Error("DOM portal content must be attached to a parent node."); const n = this._document.createComment("dom-portal"); t.setAttachedHost(this), e.parentNode.insertBefore(n, e), this._getRootNode().appendChild(e), super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = n } get portal() { return this._attachedPortal } set portal(t) { (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef, n = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component), i = e.createComponent(n, e.length, t.injector || e.injector); return e !== this._viewContainerRef && this._getRootNode().appendChild(i.hostView.rootNodes[0]), super.setDisposeFn(() => i.destroy()), this._attachedPortal = t, this._attachedRef = i, this.attached.emit(i), i } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } _getRootNode() { const t = this._viewContainerRef.element.nativeElement; return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ha), Ao(ml), Ao(ph)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [Ca] }), t })(), aC = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); class lC { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = db(-this._previousScrollPosition.left), t.style.top = db(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, n = this._document.body.style, i = e.scrollBehavior || "", r = n.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), e.scrollBehavior = n.scrollBehavior = "auto", window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), e.scrollBehavior = i, n.scrollBehavior = r } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } function cC() { return Error("Scroll strategy has already been attached.") } class hC { constructor(t, e, n, i) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = i, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { if (this._overlayRef) throw cC(); this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class uC { enable() { } disable() { } attach() { } } function dC(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function pC(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class fC { constructor(t, e, n, i) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = i, this._scrollSubscription = null } attach(t) { if (this._overlayRef) throw cC(); this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: n } = this._viewportRuler.getViewportSize(); dC(t, [{ width: e, height: n, bottom: n, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let mC = (() => { class t { constructor(t, e, n, i) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this.noop = () => new uC, this.close = t => new hC(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new lC(this._viewportRuler, this._document), this.reposition = t => new fC(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = i } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Xx), Kt(Kx), Kt(Lc), Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Xx), Kt(Kx), Kt(Lc), Kt(ph)) }, token: t, providedIn: "root" }), t })(); class gC { constructor(t) { if (this.scrollStrategy = new uC, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const n of e) void 0 !== t[n] && (this[n] = t[n]) } } } class yC { constructor(t, e, n, i, r) { this.offsetX = n, this.offsetY = i, this.panelClass = r, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class _C { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } function vC(t, e) { if ("top" !== e && "bottom" !== e && "center" !== e) throw Error(`ConnectedPosition: Invalid ${t} "${e}". ` + 'Expected "top", "bottom" or "center".') } function bC(t, e) { if ("start" !== e && "end" !== e && "center" !== e) throw Error(`ConnectedPosition: Invalid ${t} "${e}". ` + 'Expected "start", "end" or "center".') } let wC = (() => { class t { constructor(t) { this._attachedOverlays = [], this._keydownListener = t => { const e = this._attachedOverlays; for (let n = e.length - 1; n > -1; n--)if (e[n]._keydownEventSubscriptions > 0) { e[n]._keydownEvents.next(t); break } }, this._document = t } ngOnDestroy() { this._detach() } add(t) { this.remove(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this._detach() } _detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(ph)) }, token: t, providedIn: "root" }), t })(); const xC = !("undefined" == typeof window || !window || !window.__karma__ && !window.jasmine); let CC = (() => { class t { constructor(t, e) { this._platform = e, this._document = t } ngOnDestroy() { const t = this._containerElement; t && t.parentNode && t.parentNode.removeChild(t) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = this._platform ? this._platform.isBrowser : "undefined" != typeof window; if (t || xC) { const t = this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]'); for (let e = 0; e < t.length; e++)t[e].parentNode.removeChild(t[e]) } const e = this._document.createElement("div"); e.classList.add("cdk-overlay-container"), xC ? e.setAttribute("platform", "test") : t || e.setAttribute("platform", "server"), this._document.body.appendChild(e), this._containerElement = e } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ph), Kt(gb)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(ph), Kt(gb)) }, token: t, providedIn: "root" }), t })(); class SC { constructor(t, e, n, i, r, s, o, a) { this._portalOutlet = t, this._host = e, this._pane = n, this._config = i, this._ngZone = r, this._keyboardDispatcher = s, this._document = o, this._location = a, this._backdropElement = null, this._backdropClick = new k, this._attachments = new k, this._detachments = new k, this._locationChanges = u.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEventsObservable = new b(t => { const e = this._keydownEvents.subscribe(t); return this._keydownEventSubscriptions++, () => { e.unsubscribe(), this._keydownEventSubscriptions-- } }), this._keydownEvents = new k, this._keydownEventSubscriptions = 0, i.scrollStrategy && (this._scrollStrategy = i.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = i.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.asObservable().pipe(qf(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && this._location && (this._locationChanges = this._location.subscribe(() => this.dispose())), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick.asObservable() } attachments() { return this._attachments.asObservable() } detachments() { return this._detachments.asObservable() } keydownEvents() { return this._keydownEventsObservable } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = db(this._config.width), t.height = db(this._config.height), t.minWidth = db(this._config.minWidth), t.minHeight = db(this._config.minHeight), t.maxWidth = db(this._config.maxWidth), t.maxHeight = db(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "auto" : "none" } _attachBackdrop() { this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing") }) }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing") } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let n = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", n), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) }; e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", n) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)) } _toggleClasses(t, e, n) { const i = t.classList; ub(e).forEach(t => { t && (n ? i.add(t) : i.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.asObservable().pipe(jw(G(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } const kC = /([A-Za-z%]+)$/; class EC { constructor(t, e, n, i, r) { this._viewportRuler = e, this._document = n, this._platform = i, this._overlayContainer = r, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new k, this._resizeSubscription = u.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges.asObservable(), this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { if (this._overlayRef && t !== this._overlayRef) throw Error("This position strategy is already attached to an overlay"); this._validatePositions(), t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, n = this._viewportRect, i = []; let r; for (let s of this._preferredPositions) { let o = this._getOriginPoint(t, s), a = this._getOverlayPoint(o, e, s), l = this._getOverlayFit(a, e, n, s); if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(s, o); this._canFitWithFlexibleDimensions(l, a, n) ? i.push({ position: s, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, s) }) : (!r || r.overlayFit.visibleArea < l.visibleArea) && (r = { overlayFit: l, overlayPoint: a, originPoint: o, position: s, overlayRect: e }) } if (i.length) { let t = null, e = -1; for (const n of i) { const i = n.boundingBoxRect.width * n.boundingBoxRect.height * (n.position.weight || 1); i > e && (e = i, t = n) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(r.position, r.originPoint); this._applyPosition(r.position, r.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && OC(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let n, i; if ("center" == e.originX) n = t.left + t.width / 2; else { const i = this._isRtl() ? t.right : t.left, r = this._isRtl() ? t.left : t.right; n = "start" == e.originX ? i : r } return i = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: n, y: i } } _getOverlayPoint(t, e, n) { let i, r; return i = "center" == n.overlayX ? -e.width / 2 : "start" === n.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, r = "center" == n.overlayY ? -e.height / 2 : "top" == n.overlayY ? 0 : -e.height, { x: t.x + i, y: t.y + r } } _getOverlayFit(t, e, n, i) { let { x: r, y: s } = t, o = this._getOffset(i, "x"), a = this._getOffset(i, "y"); o && (r += o), a && (s += a); let l = 0 - s, c = s + e.height - n.height, h = this._subtractOverflows(e.width, 0 - r, r + e.width - n.width), u = this._subtractOverflows(e.height, l, c), d = h * u; return { visibleArea: d, isCompletelyWithinViewport: e.width * e.height === d, fitsInViewportVertically: u === e.height, fitsInViewportHorizontally: h == e.width } } _canFitWithFlexibleDimensions(t, e, n) { if (this._hasFlexibleDimensions) { const i = n.bottom - e.y, r = n.right - e.x, s = AC(this._overlayRef.getConfig().minHeight), o = AC(this._overlayRef.getConfig().minWidth), a = t.fitsInViewportHorizontally || null != o && o <= r; return (t.fitsInViewportVertically || null != s && s <= i) && a } return !1 } _pushOverlayOnScreen(t, e, n) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const i = this._viewportRect, r = Math.max(t.x + e.width - i.right, 0), s = Math.max(t.y + e.height - i.bottom, 0), o = Math.max(i.top - n.top - t.y, 0), a = Math.max(i.left - n.left - t.x, 0); let l = 0, c = 0; return l = e.width <= i.width ? a || -r : t.x < this._viewportMargin ? i.left - n.left - t.x : 0, c = e.height <= i.height ? o || -s : t.y < this._viewportMargin ? i.top - n.top - t.y : 0, this._previousPushAmount = { x: l, y: c }, { x: t.x + l, y: t.y + c } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), n = new _C(t, e); this._positionChanges.next(n) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let n, i = t.overlayY; n = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let r = 0; r < e.length; r++)e[r].style.transformOrigin = `${n} ${i}` } _calculateBoundingBoxRect(t, e) { const n = this._viewportRect, i = this._isRtl(); let r, s, o, a, l, c; if ("top" === e.overlayY) s = t.y, r = n.height - s + this._viewportMargin; else if ("bottom" === e.overlayY) o = n.height - t.y + 2 * this._viewportMargin, r = n.height - o + this._viewportMargin; else { const e = Math.min(n.bottom - t.y + n.top, t.y), i = this._lastBoundingBoxSize.height; r = 2 * e, s = t.y - e, r > i && !this._isInitialRender && !this._growAfterOpen && (s = t.y - i / 2) } if ("end" === e.overlayX && !i || "start" === e.overlayX && i) c = n.width - t.x + this._viewportMargin, a = t.x - this._viewportMargin; else if ("start" === e.overlayX && !i || "end" === e.overlayX && i) l = t.x, a = n.right - t.x; else { const e = Math.min(n.right - t.x + n.left, t.x), i = this._lastBoundingBoxSize.width; a = 2 * e, l = t.x - e, a > i && !this._isInitialRender && !this._growAfterOpen && (l = t.x - i / 2) } return { top: s, left: l, bottom: o, right: c, width: a, height: r } } _setBoundingBoxStyles(t, e) { const n = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width)); const i = {}; if (this._hasExactPosition()) i.top = i.left = "0", i.bottom = i.right = i.maxHeight = i.maxWidth = "", i.width = i.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, r = this._overlayRef.getConfig().maxWidth; i.height = db(n.height), i.top = db(n.top), i.bottom = db(n.bottom), i.width = db(n.width), i.left = db(n.left), i.right = db(n.right), i.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", i.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (i.maxHeight = db(t)), r && (i.maxWidth = db(r)) } this._lastBoundingBoxSize = n, OC(this._boundingBox.style, i) } _resetBoundingBoxStyles() { OC(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { OC(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const n = {}, i = this._hasExactPosition(), r = this._hasFlexibleDimensions, s = this._overlayRef.getConfig(); if (i) { const i = this._viewportRuler.getViewportScrollPosition(); OC(n, this._getExactOverlayY(e, t, i)), OC(n, this._getExactOverlayX(e, t, i)) } else n.position = "static"; let o = "", a = this._getOffset(e, "x"), l = this._getOffset(e, "y"); a && (o += `translateX(${a}px) `), l && (o += `translateY(${l}px)`), n.transform = o.trim(), s.maxHeight && (i ? n.maxHeight = db(s.maxHeight) : r && (n.maxHeight = "")), s.maxWidth && (i ? n.maxWidth = db(s.maxWidth) : r && (n.maxWidth = "")), OC(this._pane.style, n) } _getExactOverlayY(t, e, n) { let i = { top: "", bottom: "" }, r = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, n)); let s = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return r.y -= s, "bottom" === t.overlayY ? i.bottom = `${this._document.documentElement.clientHeight - (r.y + this._overlayRect.height)}px` : i.top = db(r.y), i } _getExactOverlayX(t, e, n) { let i, r = { left: "", right: "" }, s = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, n)), i = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === i ? r.right = `${this._document.documentElement.clientWidth - (s.x + this._overlayRect.width)}px` : r.left = db(s.x), r } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: pC(t, n), isOriginOutsideView: dC(t, n), isOverlayClipped: pC(e, n), isOverlayOutsideView: dC(e, n) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition(); return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { if (!this._preferredPositions.length) throw Error("FlexibleConnectedPositionStrategy: At least one position is required."); this._preferredPositions.forEach(t => { bC("originX", t.originX), vC("originY", t.originY), bC("overlayX", t.overlayX), vC("overlayY", t.overlayY) }) } _addPanelClasses(t) { this._pane && ub(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof Ua) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, n = t.height || 0; return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e } } } function OC(t, e) { for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } function AC(t) { if ("number" != typeof t && null != t) { const [e, n] = t.split(kC); return n && "px" !== n ? null : parseFloat(e) } return t || null } class TC { constructor(t, e, n, i, r, s, o) { this._preferredPositions = [], this._positionStrategy = new EC(n, i, r, s, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e) } get _isRtl() { return "rtl" === this._overlayRef.getDirection() } get onPositionChange() { return this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, n, i) { const r = new yC(t, e, n, i); return this._preferredPositions.push(r), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } class PC { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add("cdk-global-overlay-wrapper"), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(), { width: i, height: r, maxWidth: s, maxHeight: o } = n, a = !("100%" !== i && "100vw" !== i || s && "100%" !== s && "100vw" !== s), l = !("100%" !== r && "100vh" !== r || o && "100%" !== o && "100vh" !== o); t.position = this._cssPosition, t.marginLeft = a ? "0" : this._leftOffset, t.marginTop = l ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, a ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = l ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style; e.classList.remove("cdk-global-overlay-wrapper"), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let DC = (() => { class t { constructor(t, e, n, i) { this._viewportRuler = t, this._document = e, this._platform = n, this._overlayContainer = i } global() { return new PC } connectedTo(t, e, n) { return new TC(e, n, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new EC(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Kx), Kt(ph), Kt(gb), Kt(CC)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Kx), Kt(ph), Kt(gb), Kt(CC)) }, token: t, providedIn: "root" }), t })(), IC = 0, RC = (() => { class t { constructor(t, e, n, i, r, s, o, a, l, c) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = n, this._positionBuilder = i, this._keyboardDispatcher = r, this._injector = s, this._ngZone = o, this._document = a, this._directionality = l, this._location = c } create(t) { const e = this._createHostElement(), n = this._createPaneElement(e), i = this._createPortalOutlet(n), r = new gC(t); return r.direction = r.direction || this._directionality.value, new SC(i, e, n, r, this._ngZone, this._keyboardDispatcher, this._document, this._location) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = `cdk-overlay-${IC++}`, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(eh)), new sC(t, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(mC), Kt(CC), Kt(Ha), Kt(DC), Kt(wC), Kt(lo), Kt(Lc), Kt(ph), Kt(Gb), Kt(Ah, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const MC = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }], LC = new Bt("cdk-connected-overlay-scroll-strategy"); let FC = (() => { class t { constructor(t) { this.elementRef = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]], exportAs: ["cdkOverlayOrigin"] }), t })(), NC = (() => { class t { constructor(t, e, n, i, r) { this._overlay = t, this._dir = r, this._hasBackdrop = !1, this._lockPosition = !1, this._growAfterOpen = !1, this._flexibleDimensions = !1, this._push = !1, this._backdropSubscription = u.EMPTY, this.viewportMargin = 0, this.open = !1, this.backdropClick = new ql, this.positionChange = new ql, this.attach = new ql, this.detach = new ql, this.overlayKeydown = new ql, this._templatePortal = new nC(e, n), this._scrollStrategyFactory = i, this.scrollStrategy = this._scrollStrategyFactory() } get offsetX() { return this._offsetX } set offsetX(t) { this._offsetX = t, this._position && this._updatePositionStrategy(this._position) } get offsetY() { return this._offsetY } set offsetY(t) { this._offsetY = t, this._position && this._updatePositionStrategy(this._position) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(t) { this._hasBackdrop = lb(t) } get lockPosition() { return this._lockPosition } set lockPosition(t) { this._lockPosition = lb(t) } get flexibleDimensions() { return this._flexibleDimensions } set flexibleDimensions(t) { this._flexibleDimensions = lb(t) } get growAfterOpen() { return this._growAfterOpen } set growAfterOpen(t) { this._growAfterOpen = lb(t) } get push() { return this._push } set push(t) { this._push = lb(t) } get overlayRef() { return this._overlayRef } get dir() { return this._dir ? this._dir.value : "ltr" } ngOnDestroy() { this._overlayRef && this._overlayRef.dispose(), this._backdropSubscription.unsubscribe() } ngOnChanges(t) { this._position && (this._updatePositionStrategy(this._position), this._overlayRef.updateSize({ width: this.width, minWidth: this.minWidth, height: this.height, minHeight: this.minHeight }), t.origin && this.open && this._position.apply()), t.open && (this.open ? this._attachOverlay() : this._detachOverlay()) } _createOverlay() { this.positions && this.positions.length || (this.positions = MC), this._overlayRef = this._overlay.create(this._buildConfig()), this._overlayRef.keydownEvents().subscribe(t => { this.overlayKeydown.next(t), 27 !== t.keyCode || Zv(t) || (t.preventDefault(), this._detachOverlay()) }) } _buildConfig() { const t = this._position = this.positionStrategy || this._createPositionStrategy(), e = new gC({ direction: this._dir, positionStrategy: t, scrollStrategy: this.scrollStrategy, hasBackdrop: this.hasBackdrop }); return (this.width || 0 === this.width) && (e.width = this.width), (this.height || 0 === this.height) && (e.height = this.height), (this.minWidth || 0 === this.minWidth) && (e.minWidth = this.minWidth), (this.minHeight || 0 === this.minHeight) && (e.minHeight = this.minHeight), this.backdropClass && (e.backdropClass = this.backdropClass), this.panelClass && (e.panelClass = this.panelClass), e } _updatePositionStrategy(t) { const e = this.positions.map(t => ({ originX: t.originX, originY: t.originY, overlayX: t.overlayX, overlayY: t.overlayY, offsetX: t.offsetX || this.offsetX, offsetY: t.offsetY || this.offsetY, panelClass: t.panelClass || void 0 })); return t.setOrigin(this.origin.elementRef).withPositions(e).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector) } _createPositionStrategy() { const t = this._overlay.position().flexibleConnectedTo(this.origin.elementRef); return this._updatePositionStrategy(t), t.positionChanges.subscribe(t => this.positionChange.emit(t)), t } _attachOverlay() { this._overlayRef ? this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop : this._createOverlay(), this._overlayRef.hasAttached() || (this._overlayRef.attach(this._templatePortal), this.attach.emit()), this.hasBackdrop ? this._backdropSubscription = this._overlayRef.backdropClick().subscribe(t => { this.backdropClick.emit(t) }) : this._backdropSubscription.unsubscribe() } _detachOverlay() { this._overlayRef && (this._overlayRef.detach(), this.detach.emit()), this._backdropSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(RC), Ao(pl), Ao(ml), Ao(LC), Ao(Gb, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]], inputs: { viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"], open: ["cdkConnectedOverlayOpen", "open"], scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"], offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"], offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"], hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"], lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"], flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"], growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"], push: ["cdkConnectedOverlayPush", "push"], positions: ["cdkConnectedOverlayPositions", "positions"], origin: ["cdkConnectedOverlayOrigin", "origin"], positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"], width: ["cdkConnectedOverlayWidth", "width"], height: ["cdkConnectedOverlayHeight", "height"], minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"], minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"], backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"], panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"], transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"] }, outputs: { backdropClick: "backdropClick", positionChange: "positionChange", attach: "attach", detach: "detach", overlayKeydown: "overlayKeydown" }, exportAs: ["cdkConnectedOverlay"], features: [Ta] }), t })(); const VC = { provide: LC, deps: [RC], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let jC = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [RC, VC], imports: [[Yb, aC, Zx], Zx] }), t })(); function BC(t, e = ib) { var n; const i = (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t); return t => t.lift(new zC(i, e)) } class zC { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new HC(t, this.delay, this.scheduler)) } } class HC extends f { constructor(t, e, n) { super(t), this.delay = e, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source, n = e.queue, i = t.scheduler, r = t.destination; for (; n.length > 0 && n[0].time - i.now() <= 0;)n.shift().notification.observe(r); if (n.length > 0) { const e = Math.max(0, n[0].time - i.now()); this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(HC.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler, n = new UC(e.now() + this.delay, t); this.queue.push(n), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification($x.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification($x.createComplete()), this.unsubscribe() } } class UC { constructor(t, e) { this.time = t, this.notification = e } } const $C = ["panel"]; function qC(t, e) { if (1 & t && (Ro(0, "div", 0, 1), Ko(2), Mo()), 2 & t) { const t = Go(); Do("id", t.id)("ngClass", t._classList) } } const WC = ["*"]; let GC = 0; class YC { constructor(t, e) { this.source = t, this.option = e } } class XC { } const KC = lw(XC), QC = new Bt("mat-autocomplete-default-options", { providedIn: "root", factory: function () { return { autoActiveFirstOption: !1 } } }); let ZC = (() => { class t extends KC { constructor(t, e, n) { super(), this._changeDetectorRef = t, this._elementRef = e, this._activeOptionChanges = u.EMPTY, this.showPanel = !1, this._isOpen = !1, this.displayWith = null, this.optionSelected = new ql, this.opened = new ql, this.closed = new ql, this.optionActivated = new ql, this._classList = {}, this.id = `mat-autocomplete-${GC++}`, this._autoActiveFirstOption = !!n.autoActiveFirstOption } get isOpen() { return this._isOpen && this.showPanel } get autoActiveFirstOption() { return this._autoActiveFirstOption } set autoActiveFirstOption(t) { this._autoActiveFirstOption = lb(t) } set classList(t) { this._classList = t && t.length ? t.split(" ").reduce((t, e) => (t[e.trim()] = !0, t), {}) : {}, this._setVisibilityClasses(this._classList), this._elementRef.nativeElement.className = "" } ngAfterContentInit() { this._keyManager = new Mb(this.options).withWrap(), this._activeOptionChanges = this._keyManager.change.subscribe(t => { this.optionActivated.emit({ source: this, option: this.options.toArray()[t] || null }) }), this._setVisibility() } ngOnDestroy() { this._activeOptionChanges.unsubscribe() } _setScrollTop(t) { this.panel && (this.panel.nativeElement.scrollTop = t) } _getScrollTop() { return this.panel ? this.panel.nativeElement.scrollTop : 0 } _setVisibility() { this.showPanel = !!this.options.length, this._setVisibilityClasses(this._classList), this._changeDetectorRef.markForCheck() } _emitSelectEvent(t) { const e = new YC(this, t); this.optionSelected.emit(e) } _setVisibilityClasses(t) { t["mat-autocomplete-visible"] = this.showPanel, t["mat-autocomplete-hidden"] = !this.showPanel } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ws), Ao(Ua), Ao(QC)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-autocomplete"]], contentQueries: function (t, e, n) { var i; 1 & t && (oc(n, Iw, !0), oc(n, Ow, !0)), 2 & t && (nc(i = cc()) && (e.options = i), nc(i = cc()) && (e.optionGroups = i)) }, viewQuery: function (t, e) { var n; 1 & t && (ic(pl, !0), rc($C, !0)), 2 & t && (nc(n = cc()) && (e.template = n.first), nc(n = cc()) && (e.panel = n.first)) }, hostAttrs: [1, "mat-autocomplete"], inputs: { disableRipple: "disableRipple", displayWith: "displayWith", autoActiveFirstOption: "autoActiveFirstOption", classList: ["class", "classList"], panelWidth: "panelWidth" }, outputs: { optionSelected: "optionSelected", opened: "opened", closed: "closed", optionActivated: "optionActivated" }, exportAs: ["matAutocomplete"], features: [ja([{ provide: Dw, useExisting: t }]), Ca], ngContentSelectors: WC, decls: 1, vars: 0, consts: [["role", "listbox", 1, "mat-autocomplete-panel", 3, "id", "ngClass"], ["panel", ""]], template: function (t, e) { 1 & t && (Xo(), Eo(0, qC, 3, 2, "ng-template")) }, directives: [Bh], styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\n"], encapsulation: 2, changeDetection: 0 }), t })(); const JC = new Bt("mat-autocomplete-scroll-strategy"), tS = { provide: JC, deps: [RC], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }, eS = { provide: D_, useExisting: kt(() => nS), multi: !0 }; let nS = (() => { class t { constructor(t, e, n, i, r, s, o, a, l, c) { this._element = t, this._overlay = e, this._viewContainerRef = n, this._zone = i, this._changeDetectorRef = r, this._dir = o, this._formField = a, this._document = l, this._viewportRuler = c, this._componentDestroyed = !1, this._autocompleteDisabled = !1, this._manuallyFloatingLabel = !1, this._viewportSubscription = u.EMPTY, this._canOpenOnNextFocus = !0, this._closeKeyEventStream = new k, this._windowBlurHandler = () => { this._canOpenOnNextFocus = this._document.activeElement !== this._element.nativeElement || this.panelOpen }, this._onChange = () => { }, this._onTouched = () => { }, this.position = "auto", this.autocompleteAttribute = "off", this._overlayAttached = !1, this.optionSelections = kf(() => this.autocomplete && this.autocomplete.options ? G(...this.autocomplete.options.map(t => t.onSelectionChange)) : this._zone.onStable.asObservable().pipe(qf(1), Qf(() => this.optionSelections))), this._scrollStrategy = s } get autocompleteDisabled() { return this._autocompleteDisabled } set autocompleteDisabled(t) { this._autocompleteDisabled = lb(t) } ngAfterViewInit() { const t = this._getWindow(); void 0 !== t && (this._zone.runOutsideAngular(() => { t.addEventListener("blur", this._windowBlurHandler) }), this._isInsideShadowRoot = !!Cb(this._element.nativeElement)) } ngOnChanges(t) { t.position && this._positionStrategy && (this._setStrategyPositions(this._positionStrategy), this.panelOpen && this._overlayRef.updatePosition()) } ngOnDestroy() { const t = this._getWindow(); void 0 !== t && t.removeEventListener("blur", this._windowBlurHandler), this._viewportSubscription.unsubscribe(), this._componentDestroyed = !0, this._destroyPanel(), this._closeKeyEventStream.complete() } get panelOpen() { return this._overlayAttached && this.autocomplete.showPanel } openPanel() { this._attachOverlay(), this._floatLabel() } closePanel() { this._resetLabel(), this._overlayAttached && (this.panelOpen && this.autocomplete.closed.emit(), this.autocomplete._isOpen = this._overlayAttached = !1, this._overlayRef && this._overlayRef.hasAttached() && (this._overlayRef.detach(), this._closingActionsSubscription.unsubscribe()), this._componentDestroyed || this._changeDetectorRef.detectChanges()) } updatePosition() { this._overlayAttached && this._overlayRef.updatePosition() } get panelClosingActions() { return G(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Of(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(Of(() => this._overlayAttached)) : gf()).pipe(N(t => t instanceof Pw ? t : null)) } get activeOption() { return this.autocomplete && this.autocomplete._keyManager ? this.autocomplete._keyManager.activeItem : null } _getOutsideClickStream() { return G(Vw(this._document, "click"), Vw(this._document, "touchend")).pipe(Of(t => { const e = this._isInsideShadowRoot && t.composedPath ? t.composedPath()[0] : t.target, n = this._formField ? this._formField._elementRef.nativeElement : null; return this._overlayAttached && e !== this._element.nativeElement && (!n || !n.contains(e)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(e) })) } writeValue(t) { Promise.resolve(null).then(() => this._setTriggerValue(t)) } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this._element.nativeElement.disabled = t } _handleKeydown(t) { const e = t.keyCode; if (27 === e && t.preventDefault(), this.activeOption && 13 === e && this.panelOpen) this.activeOption._selectViaInteraction(), this._resetActiveItem(), t.preventDefault(); else if (this.autocomplete) { const n = this.autocomplete._keyManager.activeItem, i = 38 === e || 40 === e; this.panelOpen || 9 === e ? this.autocomplete._keyManager.onKeydown(t) : i && this._canOpen() && this.openPanel(), (i || this.autocomplete._keyManager.activeItem !== n) && this._scrollToOption() } } _handleInput(t) { let e = t.target, n = e.value; "number" === e.type && (n = "" == n ? null : parseFloat(n)), this._previousValue !== n && (this._previousValue = n, this._onChange(n), this._canOpen() && this._document.activeElement === t.target && this.openPanel()) } _handleFocus() { this._canOpenOnNextFocus ? this._canOpen() && (this._previousValue = this._element.nativeElement.value, this._attachOverlay(), this._floatLabel(!0)) : this._canOpenOnNextFocus = !0 } _floatLabel(t = !1) { this._formField && "auto" === this._formField.floatLabel && (t ? this._formField._animateAndLockLabel() : this._formField.floatLabel = "always", this._manuallyFloatingLabel = !0) } _resetLabel() { this._manuallyFloatingLabel && (this._formField.floatLabel = "auto", this._manuallyFloatingLabel = !1) } _scrollToOption() { const t = this.autocomplete._keyManager.activeItemIndex || 0, e = Rw(t, this.autocomplete.options, this.autocomplete.optionGroups); if (0 === t && 1 === e) this.autocomplete._setScrollTop(0); else { const n = Mw(t + e, 48, this.autocomplete._getScrollTop(), 256); this.autocomplete._setScrollTop(n) } } _subscribeToClosingActions() { return G(this._zone.onStable.asObservable().pipe(qf(1)), this.autocomplete.options.changes.pipe(am(() => this._positionStrategy.reapplyLastPosition()), BC(0))).pipe(Qf(() => { const t = this.panelOpen; return this._resetActiveItem(), this.autocomplete._setVisibility(), this.panelOpen && (this._overlayRef.updatePosition(), t !== this.panelOpen && this.autocomplete.opened.emit()), this.panelClosingActions }), qf(1)).subscribe(t => this._setValueAndClose(t)) } _destroyPanel() { this._overlayRef && (this.closePanel(), this._overlayRef.dispose(), this._overlayRef = null) } _setTriggerValue(t) { const e = this.autocomplete && this.autocomplete.displayWith ? this.autocomplete.displayWith(t) : t, n = null != e ? e : ""; this._formField ? this._formField._control.value = n : this._element.nativeElement.value = n, this._previousValue = n } _setValueAndClose(t) { t && t.source && (this._clearPreviousSelectedOption(t.source), this._setTriggerValue(t.source.value), this._onChange(t.source.value), this._element.nativeElement.focus(), this.autocomplete._emitSelectEvent(t.source)), this.closePanel() } _clearPreviousSelectedOption(t) { this.autocomplete.options.forEach(e => { e != t && e.selected && e.deselect() }) } _attachOverlay() { if (!this.autocomplete) throw Error("Attempting to open an undefined instance of `mat-autocomplete`. Make sure that the id passed to the `matAutocomplete` is correct and that you're attempting to open it after the ngAfterContentInit hook."); let t = this._overlayRef; t ? (this._positionStrategy.setOrigin(this._getConnectedElement()), t.updateSize({ width: this._getPanelWidth() })) : (this._portal = new nC(this.autocomplete.template, this._viewContainerRef), t = this._overlay.create(this._getOverlayConfig()), this._overlayRef = t, t.keydownEvents().subscribe(t => { (27 === t.keyCode || 38 === t.keyCode && t.altKey) && (this._resetActiveItem(), this._closeKeyEventStream.next(), t.stopPropagation(), t.preventDefault()) }), this._viewportRuler && (this._viewportSubscription = this._viewportRuler.change().subscribe(() => { this.panelOpen && t && t.updateSize({ width: this._getPanelWidth() }) }))), t && !t.hasAttached() && (t.attach(this._portal), this._closingActionsSubscription = this._subscribeToClosingActions()); const e = this.panelOpen; this.autocomplete._setVisibility(), this.autocomplete._isOpen = this._overlayAttached = !0, this.panelOpen && e !== this.panelOpen && this.autocomplete.opened.emit() } _getOverlayConfig() { return new gC({ positionStrategy: this._getOverlayPosition(), scrollStrategy: this._scrollStrategy(), width: this._getPanelWidth(), direction: this._dir }) } _getOverlayPosition() { const t = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(!1).withPush(!1); return this._setStrategyPositions(t), this._positionStrategy = t, t } _setStrategyPositions(t) { const e = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }], n = [{ originX: "start", originY: "top", overlayX: "start", overlayY: "bottom", panelClass: "mat-autocomplete-panel-above" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom", panelClass: "mat-autocomplete-panel-above" }]; let i; i = "above" === this.position ? n : "below" === this.position ? e : [...e, ...n], t.withPositions(i) } _getConnectedElement() { return this.connectedTo ? this.connectedTo.elementRef : this._formField ? this._formField.getConnectedOverlayOrigin() : this._element } _getPanelWidth() { return this.autocomplete.panelWidth || this._getHostWidth() } _getHostWidth() { return this._getConnectedElement().nativeElement.getBoundingClientRect().width } _resetActiveItem() { this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1) } _canOpen() { const t = this._element.nativeElement; return !t.readOnly && !t.disabled && !this._autocompleteDisabled } _getWindow() { var t; return (null === (t = this._document) || void 0 === t ? void 0 : t.defaultView) || window } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(RC), Ao(ml), Ao(Lc), Ao(Ws), Ao(JC), Ao(Gb, 8), Ao(bx, 9), Ao(ph, 8), Ao(Kx)) }, t.\u0275dir = we({ type: t, selectors: [["input", "matAutocomplete", ""], ["textarea", "matAutocomplete", ""]], hostAttrs: [1, "mat-autocomplete-trigger"], hostVars: 7, hostBindings: function (t, e) { 1 & t && Ho("focusin", (function () { return e._handleFocus() }))("blur", (function () { return e._onTouched() }))("input", (function (t) { return e._handleInput(t) }))("keydown", (function (t) { return e._handleKeydown(t) })), 2 & t && So("autocomplete", e.autocompleteAttribute)("role", e.autocompleteDisabled ? null : "combobox")("aria-autocomplete", e.autocompleteDisabled ? null : "list")("aria-activedescendant", e.panelOpen && e.activeOption ? e.activeOption.id : null)("aria-expanded", e.autocompleteDisabled ? null : e.panelOpen.toString())("aria-owns", e.autocompleteDisabled || !e.panelOpen || null == e.autocomplete ? null : e.autocomplete.id)("aria-haspopup", !e.autocompleteDisabled) }, inputs: { position: ["matAutocompletePosition", "position"], autocompleteAttribute: ["autocomplete", "autocompleteAttribute"], autocompleteDisabled: ["matAutocompleteDisabled", "autocompleteDisabled"], autocomplete: ["matAutocomplete", "autocomplete"], connectedTo: ["matAutocompleteConnectedTo", "connectedTo"] }, exportAs: ["matAutocompleteTrigger"], features: [ja([eS]), Ta] }), t })(), iS = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [tS], imports: [[Lw, jC, sw, au], Qx, Lw, sw] }), t })(), rS = (() => { class t { constructor() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = me({ type: t, selectors: [["app-root"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Lo(0, "router-outlet") }, directives: [Ry], styles: [""] }), t })(); function sS(t, e, n, i) { return new (n || (n = Promise))((function (r, s) { function o(t) { try { l(i.next(t)) } catch (e) { s(e) } } function a(t) { try { l(i.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) { t(e) }))).then(o, a) } l((i = i.apply(t, e || [])).next()) })) } var oS = n("Gt99"); const aS = [[["caption"]]], lS = ["caption"]; function cS(t) { return class extends t { constructor(...t) { super(...t), this._sticky = !1, this._hasStickyChanged = !1 } get sticky() { return this._sticky } set sticky(t) { const e = this._sticky; this._sticky = lb(t), this._hasStickyChanged = e !== this._sticky } hasStickyChanged() { const t = this._hasStickyChanged; return this._hasStickyChanged = !1, t } resetStickyChanged() { this._hasStickyChanged = !1 } } } const hS = new Bt("CDK_TABLE"); let uS = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkCellDef", ""]] }), t })(), dS = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkHeaderCellDef", ""]] }), t })(), pS = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkFooterCellDef", ""]] }), t })(); class fS { } const mS = cS(fS); let gS = (() => { class t extends mS { constructor(t) { super(), this._table = t, this._stickyEnd = !1 } get name() { return this._name } set name(t) { t && (this._name = t, this.cssClassFriendlyName = t.replace(/[^a-z0-9_-]/gi, "-")) } get stickyEnd() { return this._stickyEnd } set stickyEnd(t) { const e = this._stickyEnd; this._stickyEnd = lb(t), this._hasStickyChanged = e !== this._stickyEnd } } return t.\u0275fac = function (e) { return new (e || t)(Ao(hS, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkColumnDef", ""]], contentQueries: function (t, e, n) { var i; 1 & t && (oc(n, uS, !0), oc(n, dS, !0), oc(n, pS, !0)), 2 & t && (nc(i = cc()) && (e.cell = i.first), nc(i = cc()) && (e.headerCell = i.first), nc(i = cc()) && (e.footerCell = i.first)) }, inputs: { sticky: "sticky", name: ["cdkColumnDef", "name"], stickyEnd: "stickyEnd" }, features: [ja([{ provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: t }]), Ca] }), t })(); class yS { constructor(t, e) { e.nativeElement.classList.add(`cdk-column-${t.cssClassFriendlyName}`) } } let _S = (() => { class t extends yS { constructor(t, e) { super(t, e) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(gS), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]], hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"], features: [Ca] }), t })(), vS = (() => { class t extends yS { constructor(t, e) { super(t, e) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(gS), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["cdk-cell"], ["td", "cdk-cell", ""]], hostAttrs: ["role", "gridcell", 1, "cdk-cell"], features: [Ca] }), t })(), bS = (() => { class t { constructor(t, e) { this.template = t, this._differs = e } ngOnChanges(t) { if (!this._columnsDiffer) { const e = t.columns && t.columns.currentValue || []; this._columnsDiffer = this._differs.find(e).create(), this._columnsDiffer.diff(e) } } getColumnsDiff() { return this._columnsDiffer.diff(this.columns) } extractCellTemplate(t) { return this instanceof CS ? t.headerCell.template : this instanceof ES ? t.footerCell.template : t.cell.template } } return t.\u0275fac = function (t) { Po() }, t.\u0275dir = we({ type: t, features: [Ta] }), t })(); class wS extends bS { } const xS = cS(wS); let CS = (() => { class t extends xS { constructor(t, e, n) { super(t, e), this._table = n } ngOnChanges(t) { super.ngOnChanges(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl), Ao(ll), Ao(hS, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkHeaderRowDef", ""]], inputs: { columns: ["cdkHeaderRowDef", "columns"], sticky: ["cdkHeaderRowDefSticky", "sticky"] }, features: [Ca, Ta] }), t })(); class SS extends bS { } const kS = cS(SS); let ES = (() => { class t extends kS { constructor(t, e, n) { super(t, e), this._table = n } ngOnChanges(t) { super.ngOnChanges(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl), Ao(ll), Ao(hS, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkFooterRowDef", ""]], inputs: { columns: ["cdkFooterRowDef", "columns"], sticky: ["cdkFooterRowDefSticky", "sticky"] }, features: [Ca, Ta] }), t })(), OS = (() => { class t extends bS { constructor(t, e, n) { super(t, e), this._table = n } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl), Ao(ll), Ao(hS, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkRowDef", ""]], inputs: { columns: ["cdkRowDefColumns", "columns"], when: ["cdkRowDefWhen", "when"] }, features: [Ca] }), t })(), AS = (() => { class t { constructor(e) { this._viewContainer = e, t.mostRecentCellOutlet = this } ngOnDestroy() { t.mostRecentCellOutlet === this && (t.mostRecentCellOutlet = null) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkCellOutlet", ""]] }), t.mostRecentCellOutlet = null, t })(), TS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = me({ type: t, selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]], hostAttrs: ["role", "row", 1, "cdk-header-row"], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && Vo(0, 0) }, directives: [AS], encapsulation: 2 }), t })(), PS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = me({ type: t, selectors: [["cdk-row"], ["tr", "cdk-row", ""]], hostAttrs: ["role", "row", 1, "cdk-row"], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && Vo(0, 0) }, directives: [AS], encapsulation: 2 }), t })(); const DS = ["top", "bottom", "left", "right"]; class IS { constructor(t, e, n, i = !0) { this._isNativeHtmlTable = t, this._stickCellCss = e, this.direction = n, this._isBrowser = i } clearStickyPositioning(t, e) { for (const n of t) if (n.nodeType === n.ELEMENT_NODE) { this._removeStickyStyle(n, e); for (let t = 0; t < n.children.length; t++)this._removeStickyStyle(n.children[t], e) } } updateStickyColumns(t, e, n) { const i = e.some(t => t) || n.some(t => t); if (!t.length || !i || !this._isBrowser) return; const r = t[0], s = r.children.length, o = this._getCellWidths(r), a = this._getStickyStartColumnPositions(o, e), l = this._getStickyEndColumnPositions(o, n), c = "rtl" === this.direction; for (const h of t) for (let t = 0; t < s; t++) { const i = h.children[t]; e[t] && this._addStickyStyle(i, c ? "right" : "left", a[t]), n[t] && this._addStickyStyle(i, c ? "left" : "right", l[t]) } } stickRows(t, e, n) { if (!this._isBrowser) return; const i = "bottom" === n ? t.reverse() : t; let r = 0; for (let s = 0; s < i.length; s++) { if (!e[s]) continue; const t = i[s]; if (this._isNativeHtmlTable) for (let e = 0; e < t.children.length; e++)this._addStickyStyle(t.children[e], n, r); else this._addStickyStyle(t, n, r); if (s === i.length - 1) return; r += t.getBoundingClientRect().height } } updateStickyFooterContainer(t, e) { if (!this._isNativeHtmlTable) return; const n = t.querySelector("tfoot"); e.some(t => !t) ? this._removeStickyStyle(n, ["bottom"]) : this._addStickyStyle(n, "bottom", 0) } _removeStickyStyle(t, e) { for (const n of e) t.style[n] = ""; t.style.zIndex = this._getCalculatedZIndex(t), DS.some(e => !!t.style[e]) || (t.style.position = "", t.classList.remove(this._stickCellCss)) } _addStickyStyle(t, e, n) { t.classList.add(this._stickCellCss), t.style[e] = `${n}px`, t.style.cssText += "position: -webkit-sticky; position: sticky; ", t.style.zIndex = this._getCalculatedZIndex(t) } _getCalculatedZIndex(t) { const e = { top: 100, bottom: 10, left: 1, right: 1 }; let n = 0; for (const i of DS) t.style[i] && (n += e[i]); return n ? `${n}` : "" } _getCellWidths(t) { const e = [], n = t.children; for (let i = 0; i < n.length; i++)e.push(n[i].getBoundingClientRect().width); return e } _getStickyStartColumnPositions(t, e) { const n = []; let i = 0; for (let r = 0; r < t.length; r++)e[r] && (n[r] = i, i += t[r]); return n } _getStickyEndColumnPositions(t, e) { const n = []; let i = 0; for (let r = t.length; r > 0; r--)e[r] && (n[r] = i, i += t[r]); return n } } function RS(t) { return Error(`Could not find column with id "${t}".`) } let MS = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "rowOutlet", ""]] }), t })(), LS = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "headerRowOutlet", ""]] }), t })(), FS = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "footerRowOutlet", ""]] }), t })(), NS = (() => { class t { constructor(t, e, n, i, r, s, o) { this._differs = t, this._changeDetectorRef = e, this._elementRef = n, this._dir = r, this._platform = o, this._onDestroy = new k, this._columnDefsByName = new Map, this._customColumnDefs = new Set, this._customRowDefs = new Set, this._customHeaderRowDefs = new Set, this._customFooterRowDefs = new Set, this._headerRowDefChanged = !0, this._footerRowDefChanged = !0, this._cachedRenderRowsMap = new Map, this.stickyCssClass = "cdk-table-sticky", this._multiTemplateDataRows = !1, this.viewChange = new yf({ start: 0, end: Number.MAX_VALUE }), i || this._elementRef.nativeElement.setAttribute("role", "grid"), this._document = s, this._isNativeHtmlTable = "TABLE" === this._elementRef.nativeElement.nodeName } get trackBy() { return this._trackByFn } set trackBy(t) { Ei() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}.`), this._trackByFn = t } get dataSource() { return this._dataSource } set dataSource(t) { this._dataSource !== t && this._switchDataSource(t) } get multiTemplateDataRows() { return this._multiTemplateDataRows } set multiTemplateDataRows(t) { this._multiTemplateDataRows = lb(t), this._rowOutlet && this._rowOutlet.viewContainer.length && this._forceRenderDataRows() } ngOnInit() { this._setupStickyStyler(), this._isNativeHtmlTable && this._applyNativeTableSections(), this._dataDiffer = this._differs.find([]).create((t, e) => this.trackBy ? this.trackBy(e.dataIndex, e.data) : e) } ngAfterContentChecked() { if (this._cacheRowDefs(), this._cacheColumnDefs(), !this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) throw Error("Missing definitions for header, footer, and row; cannot determine which columns should be rendered."); this._renderUpdatedColumns(), this._headerRowDefChanged && (this._forceRenderHeaderRows(), this._headerRowDefChanged = !1), this._footerRowDefChanged && (this._forceRenderFooterRows(), this._footerRowDefChanged = !1), this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription && this._observeRenderChanges(), this._checkStickyStates() } ngOnDestroy() { this._rowOutlet.viewContainer.clear(), this._headerRowOutlet.viewContainer.clear(), this._footerRowOutlet.viewContainer.clear(), this._cachedRenderRowsMap.clear(), this._onDestroy.next(), this._onDestroy.complete(), Wx(this.dataSource) && this.dataSource.disconnect(this) } renderRows() { this._renderRows = this._getAllRenderRows(); const t = this._dataDiffer.diff(this._renderRows); if (!t) return; const e = this._rowOutlet.viewContainer; t.forEachOperation((t, n, i) => { if (null == t.previousIndex) this._insertRow(t.item, i); else if (null == i) e.remove(n); else { const t = e.get(n); e.move(t, i) } }), this._updateRowIndexContext(), t.forEachIdentityChange(t => { e.get(t.currentIndex).context.$implicit = t.item.data }), this.updateStickyColumnStyles() } setHeaderRowDef(t) { this._customHeaderRowDefs = new Set([t]), this._headerRowDefChanged = !0 } setFooterRowDef(t) { this._customFooterRowDefs = new Set([t]), this._footerRowDefChanged = !0 } addColumnDef(t) { this._customColumnDefs.add(t) } removeColumnDef(t) { this._customColumnDefs.delete(t) } addRowDef(t) { this._customRowDefs.add(t) } removeRowDef(t) { this._customRowDefs.delete(t) } addHeaderRowDef(t) { this._customHeaderRowDefs.add(t), this._headerRowDefChanged = !0 } removeHeaderRowDef(t) { this._customHeaderRowDefs.delete(t), this._headerRowDefChanged = !0 } addFooterRowDef(t) { this._customFooterRowDefs.add(t), this._footerRowDefChanged = !0 } removeFooterRowDef(t) { this._customFooterRowDefs.delete(t), this._footerRowDefChanged = !0 } updateStickyHeaderRowStyles() { const t = this._getRenderedRows(this._headerRowOutlet), e = this._elementRef.nativeElement.querySelector("thead"); e && (e.style.display = t.length ? "" : "none"); const n = this._headerRowDefs.map(t => t.sticky); this._stickyStyler.clearStickyPositioning(t, ["top"]), this._stickyStyler.stickRows(t, n, "top"), this._headerRowDefs.forEach(t => t.resetStickyChanged()) } updateStickyFooterRowStyles() { const t = this._getRenderedRows(this._footerRowOutlet), e = this._elementRef.nativeElement.querySelector("tfoot"); e && (e.style.display = t.length ? "" : "none"); const n = this._footerRowDefs.map(t => t.sticky); this._stickyStyler.clearStickyPositioning(t, ["bottom"]), this._stickyStyler.stickRows(t, n, "bottom"), this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, n), this._footerRowDefs.forEach(t => t.resetStickyChanged()) } updateStickyColumnStyles() { const t = this._getRenderedRows(this._headerRowOutlet), e = this._getRenderedRows(this._rowOutlet), n = this._getRenderedRows(this._footerRowOutlet); this._stickyStyler.clearStickyPositioning([...t, ...e, ...n], ["left", "right"]), t.forEach((t, e) => { this._addStickyColumnStyles([t], this._headerRowDefs[e]) }), this._rowDefs.forEach(t => { const n = []; for (let i = 0; i < e.length; i++)this._renderRows[i].rowDef === t && n.push(e[i]); this._addStickyColumnStyles(n, t) }), n.forEach((t, e) => { this._addStickyColumnStyles([t], this._footerRowDefs[e]) }), Array.from(this._columnDefsByName.values()).forEach(t => t.resetStickyChanged()) } _getAllRenderRows() { const t = [], e = this._cachedRenderRowsMap; this._cachedRenderRowsMap = new Map; for (let n = 0; n < this._data.length; n++) { let i = this._data[n]; const r = this._getRenderRowsForData(i, n, e.get(i)); this._cachedRenderRowsMap.has(i) || this._cachedRenderRowsMap.set(i, new WeakMap); for (let e = 0; e < r.length; e++) { let n = r[e]; const i = this._cachedRenderRowsMap.get(n.data); i.has(n.rowDef) ? i.get(n.rowDef).push(n) : i.set(n.rowDef, [n]), t.push(n) } } return t } _getRenderRowsForData(t, e, n) { return this._getRowDefs(t, e).map(i => { const r = n && n.has(i) ? n.get(i) : []; if (r.length) { const t = r.shift(); return t.dataIndex = e, t } return { data: t, rowDef: i, dataIndex: e } }) } _cacheColumnDefs() { this._columnDefsByName.clear(), VS(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs).forEach(t => { if (this._columnDefsByName.has(t.name)) throw Error(`Duplicate column definition name provided: "${t.name}".`); this._columnDefsByName.set(t.name, t) }) } _cacheRowDefs() { this._headerRowDefs = VS(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs), this._footerRowDefs = VS(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs), this._rowDefs = VS(this._getOwnDefs(this._contentRowDefs), this._customRowDefs); const t = this._rowDefs.filter(t => !t.when); if (!this.multiTemplateDataRows && t.length > 1) throw Error("There can only be one default row without a when predicate function."); this._defaultRowDef = t[0] } _renderUpdatedColumns() { const t = (t, e) => t || !!e.getColumnsDiff(); this._rowDefs.reduce(t, !1) && this._forceRenderDataRows(), this._headerRowDefs.reduce(t, !1) && this._forceRenderHeaderRows(), this._footerRowDefs.reduce(t, !1) && this._forceRenderFooterRows() } _switchDataSource(t) { this._data = [], Wx(this.dataSource) && this.dataSource.disconnect(this), this._renderChangeSubscription && (this._renderChangeSubscription.unsubscribe(), this._renderChangeSubscription = null), t || (this._dataDiffer && this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear()), this._dataSource = t } _observeRenderChanges() { if (!this.dataSource) return; let t; if (Wx(this.dataSource) ? t = this.dataSource.connect(this) : Vx(this.dataSource) ? t = this.dataSource : Array.isArray(this.dataSource) && (t = gf(this.dataSource)), void 0 === t) throw Error("Provided data source did not match an array, Observable, or DataSource"); this._renderChangeSubscription = t.pipe(jw(this._onDestroy)).subscribe(t => { this._data = t || [], this.renderRows() }) } _forceRenderHeaderRows() { this._headerRowOutlet.viewContainer.length > 0 && this._headerRowOutlet.viewContainer.clear(), this._headerRowDefs.forEach((t, e) => this._renderRow(this._headerRowOutlet, t, e)), this.updateStickyHeaderRowStyles(), this.updateStickyColumnStyles() } _forceRenderFooterRows() { this._footerRowOutlet.viewContainer.length > 0 && this._footerRowOutlet.viewContainer.clear(), this._footerRowDefs.forEach((t, e) => this._renderRow(this._footerRowOutlet, t, e)), this.updateStickyFooterRowStyles(), this.updateStickyColumnStyles() } _addStickyColumnStyles(t, e) { const n = Array.from(e.columns || []).map(t => { const e = this._columnDefsByName.get(t); if (!e) throw RS(t); return e }), i = n.map(t => t.sticky), r = n.map(t => t.stickyEnd); this._stickyStyler.updateStickyColumns(t, i, r) } _getRenderedRows(t) { const e = []; for (let n = 0; n < t.viewContainer.length; n++) { const i = t.viewContainer.get(n); e.push(i.rootNodes[0]) } return e } _getRowDefs(t, e) { if (1 == this._rowDefs.length) return [this._rowDefs[0]]; let n = []; if (this.multiTemplateDataRows) n = this._rowDefs.filter(n => !n.when || n.when(e, t)); else { let i = this._rowDefs.find(n => n.when && n.when(e, t)) || this._defaultRowDef; i && n.push(i) } if (!n.length) throw function (t) { return Error("Could not find a matching row definition for the" + `provided row data: ${JSON.stringify(t)}`) }(t); return n } _insertRow(t, e) { this._renderRow(this._rowOutlet, t.rowDef, e, { $implicit: t.data }) } _renderRow(t, e, n, i = {}) { t.viewContainer.createEmbeddedView(e.template, i, n); for (let r of this._getCellTemplates(e)) AS.mostRecentCellOutlet && AS.mostRecentCellOutlet._viewContainer.createEmbeddedView(r, i); this._changeDetectorRef.markForCheck() } _updateRowIndexContext() { const t = this._rowOutlet.viewContainer; for (let e = 0, n = t.length; e < n; e++) { const i = t.get(e).context; i.count = n, i.first = 0 === e, i.last = e === n - 1, i.even = e % 2 == 0, i.odd = !i.even, this.multiTemplateDataRows ? (i.dataIndex = this._renderRows[e].dataIndex, i.renderIndex = e) : i.index = this._renderRows[e].dataIndex } } _getCellTemplates(t) { return t && t.columns ? Array.from(t.columns, e => { const n = this._columnDefsByName.get(e); if (!n) throw RS(e); return t.extractCellTemplate(n) }) : [] } _applyNativeTableSections() { const t = this._document.createDocumentFragment(), e = [{ tag: "thead", outlet: this._headerRowOutlet }, { tag: "tbody", outlet: this._rowOutlet }, { tag: "tfoot", outlet: this._footerRowOutlet }]; for (const n of e) { const e = this._document.createElement(n.tag); e.setAttribute("role", "rowgroup"), e.appendChild(n.outlet.elementRef.nativeElement), t.appendChild(e) } this._elementRef.nativeElement.appendChild(t) } _forceRenderDataRows() { this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear(), this.renderRows(), this.updateStickyColumnStyles() } _checkStickyStates() { const t = (t, e) => t || e.hasStickyChanged(); this._headerRowDefs.reduce(t, !1) && this.updateStickyHeaderRowStyles(), this._footerRowDefs.reduce(t, !1) && this.updateStickyFooterRowStyles(), Array.from(this._columnDefsByName.values()).reduce(t, !1) && this.updateStickyColumnStyles() } _setupStickyStyler() { this._stickyStyler = new IS(this._isNativeHtmlTable, this.stickyCssClass, this._dir ? this._dir.value : "ltr", this._platform.isBrowser), (this._dir ? this._dir.change : gf()).pipe(jw(this._onDestroy)).subscribe(t => { this._stickyStyler.direction = t, this.updateStickyColumnStyles() }) } _getOwnDefs(t) { return t.filter(t => !t._table || t._table === this) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ll), Ao(Ws), Ao(Ua), To("role"), Ao(Gb, 8), Ao(ph), Ao(gb)) }, t.\u0275cmp = me({ type: t, selectors: [["cdk-table"], ["table", "cdk-table", ""]], contentQueries: function (t, e, n) { var i; 1 & t && (oc(n, gS, !0), oc(n, OS, !0), oc(n, CS, !0), oc(n, ES, !0)), 2 & t && (nc(i = cc()) && (e._contentColumnDefs = i), nc(i = cc()) && (e._contentRowDefs = i), nc(i = cc()) && (e._contentHeaderRowDefs = i), nc(i = cc()) && (e._contentFooterRowDefs = i)) }, viewQuery: function (t, e) { var n; 1 & t && (ic(MS, !0), ic(LS, !0), ic(FS, !0)), 2 & t && (nc(n = cc()) && (e._rowOutlet = n.first), nc(n = cc()) && (e._headerRowOutlet = n.first), nc(n = cc()) && (e._footerRowOutlet = n.first)) }, hostAttrs: [1, "cdk-table"], inputs: { trackBy: "trackBy", dataSource: "dataSource", multiTemplateDataRows: "multiTemplateDataRows" }, exportAs: ["cdkTable"], features: [ja([{ provide: hS, useExisting: t }])], ngContentSelectors: lS, decls: 4, vars: 0, consts: [["headerRowOutlet", ""], ["rowOutlet", ""], ["footerRowOutlet", ""]], template: function (t, e) { 1 & t && (Xo(aS), Ko(0), Vo(1, 0), Vo(2, 1), Vo(3, 2)) }, directives: [LS, MS, FS], encapsulation: 2 }), t })(); function VS(t, e) { return t.concat(Array.from(e)) } let jS = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); const BS = [[["caption"]]], zS = ["caption"]; let HS = (() => { class t extends NS { constructor() { super(...arguments), this.stickyCssClass = "mat-table-sticky" } } return t.\u0275fac = function (e) { return US(e || t) }, t.\u0275cmp = me({ type: t, selectors: [["mat-table"], ["table", "mat-table", ""]], hostAttrs: [1, "mat-table"], exportAs: ["matTable"], features: [ja([{ provide: NS, useExisting: t }, { provide: hS, useExisting: t }]), Ca], ngContentSelectors: zS, decls: 4, vars: 0, consts: [["headerRowOutlet", ""], ["rowOutlet", ""], ["footerRowOutlet", ""]], template: function (t, e) { 1 & t && (Xo(BS), Ko(0), Vo(1, 0), Vo(2, 1), Vo(3, 2)) }, directives: [LS, MS, FS], styles: ['mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-row::after,mat-header-row::after,mat-footer-row::after{display:inline-block;min-height:inherit;content:""}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type,[dir=rtl] mat-header-cell:first-of-type,[dir=rtl] mat-footer-cell:first-of-type{padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type,[dir=rtl] mat-header-cell:last-of-type,[dir=rtl] mat-footer-cell:last-of-type{padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-row,tr.mat-footer-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}th.mat-header-cell,td.mat-cell,td.mat-footer-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}th.mat-header-cell:first-of-type,td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] th.mat-header-cell:first-of-type,[dir=rtl] td.mat-cell:first-of-type,[dir=rtl] td.mat-footer-cell:first-of-type{padding-left:0;padding-right:24px}th.mat-header-cell:last-of-type,td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] th.mat-header-cell:last-of-type,[dir=rtl] td.mat-cell:last-of-type,[dir=rtl] td.mat-footer-cell:last-of-type{padding-right:0;padding-left:24px}\n'], encapsulation: 2 }), t })(); const US = hi(HS); let $S = (() => { class t extends uS { } return t.\u0275fac = function (e) { return qS(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matCellDef", ""]], features: [ja([{ provide: uS, useExisting: t }]), Ca] }), t })(); const qS = hi($S); let WS = (() => { class t extends dS { } return t.\u0275fac = function (e) { return GS(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matHeaderCellDef", ""]], features: [ja([{ provide: dS, useExisting: t }]), Ca] }), t })(); const GS = hi(WS); let YS = (() => { class t extends gS { } return t.\u0275fac = function (e) { return XS(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matColumnDef", ""]], inputs: { sticky: "sticky", name: ["matColumnDef", "name"] }, features: [ja([{ provide: gS, useExisting: t }, { provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: t }]), Ca] }), t })(); const XS = hi(YS); let KS = (() => { class t extends _S { constructor(t, e) { super(t, e), e.nativeElement.classList.add(`mat-column-${t.cssClassFriendlyName}`) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(gS), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["mat-header-cell"], ["th", "mat-header-cell", ""]], hostAttrs: ["role", "columnheader", 1, "mat-header-cell"], features: [Ca] }), t })(), QS = (() => { class t extends vS { constructor(t, e) { super(t, e), e.nativeElement.classList.add(`mat-column-${t.cssClassFriendlyName}`) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(gS), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["mat-cell"], ["td", "mat-cell", ""]], hostAttrs: ["role", "gridcell", 1, "mat-cell"], features: [Ca] }), t })(), ZS = (() => { class t extends CS { } return t.\u0275fac = function (e) { return JS(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matHeaderRowDef", ""]], inputs: { columns: ["matHeaderRowDef", "columns"], sticky: ["matHeaderRowDefSticky", "sticky"] }, features: [ja([{ provide: CS, useExisting: t }]), Ca] }), t })(); const JS = hi(ZS); let tk = (() => { class t extends OS { } return t.\u0275fac = function (e) { return ek(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matRowDef", ""]], inputs: { columns: ["matRowDefColumns", "columns"], when: ["matRowDefWhen", "when"] }, features: [ja([{ provide: OS, useExisting: t }]), Ca] }), t })(); const ek = hi(tk); let nk = (() => { class t extends TS { } return t.\u0275fac = function (e) { return ik(e || t) }, t.\u0275cmp = me({ type: t, selectors: [["mat-header-row"], ["tr", "mat-header-row", ""]], hostAttrs: ["role", "row", 1, "mat-header-row"], exportAs: ["matHeaderRow"], features: [ja([{ provide: TS, useExisting: t }]), Ca], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && Vo(0, 0) }, directives: [AS], encapsulation: 2 }), t })(); const ik = hi(nk); let rk = (() => { class t extends PS { } return t.\u0275fac = function (e) { return sk(e || t) }, t.\u0275cmp = me({ type: t, selectors: [["mat-row"], ["tr", "mat-row", ""]], hostAttrs: ["role", "row", 1, "mat-row"], exportAs: ["matRow"], features: [ja([{ provide: PS, useExisting: t }]), Ca], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && Vo(0, 0) }, directives: [AS], encapsulation: 2 }), t })(); const sk = hi(rk); let ok = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[jS, sw], sw] }), t })(); class ak extends qx { constructor(t = []) { super(), this._renderData = new yf([]), this._filter = new yf(""), this._internalPageChanges = new k, this._renderChangesSubscription = u.EMPTY, this.sortingDataAccessor = (t, e) => { const n = t[e]; if (hb(n)) { const t = Number(n); return t < 9007199254740991 ? t : n } return n }, this.sortData = (t, e) => { const n = e.active, i = e.direction; return n && "" != i ? t.sort((t, e) => { let r = this.sortingDataAccessor(t, n), s = this.sortingDataAccessor(e, n), o = 0; return null != r && null != s ? r > s ? o = 1 : r < s && (o = -1) : null != r ? o = 1 : null != s && (o = -1), o * ("asc" == i ? 1 : -1) }) : t }, this.filterPredicate = (t, e) => { const n = Object.keys(t).reduce((e, n) => e + t[n] + "\u25ec", "").toLowerCase(), i = e.trim().toLowerCase(); return -1 != n.indexOf(i) }, this._data = new yf(t), this._updateChangeSubscription() } get data() { return this._data.value } set data(t) { this._data.next(t) } get filter() { return this._filter.value } set filter(t) { this._filter.next(t) } get sort() { return this._sort } set sort(t) { this._sort = t, this._updateChangeSubscription() } get paginator() { return this._paginator } set paginator(t) { this._paginator = t, this._updateChangeSubscription() } _updateChangeSubscription() { const t = this._sort ? G(this._sort.sortChange, this._sort.initialized) : gf(null), e = this._paginator ? G(this._paginator.page, this._internalPageChanges, this._paginator.initialized) : gf(null), n = bf([this._data, this._filter]).pipe(N(([t]) => this._filterData(t))), i = bf([n, t]).pipe(N(([t]) => this._orderData(t))), r = bf([i, e]).pipe(N(([t]) => this._pageData(t))); this._renderChangesSubscription.unsubscribe(), this._renderChangesSubscription = r.subscribe(t => this._renderData.next(t)) } _filterData(t) { return this.filteredData = this.filter ? t.filter(t => this.filterPredicate(t, this.filter)) : t, this.paginator && this._updatePaginator(this.filteredData.length), this.filteredData } _orderData(t) { return this.sort ? this.sortData(t.slice(), this.sort) : t } _pageData(t) { if (!this.paginator) return t; const e = this.paginator.pageIndex * this.paginator.pageSize; return t.slice(e, e + this.paginator.pageSize) } _updatePaginator(t) { Promise.resolve().then(() => { const e = this.paginator; if (e && (e.length = t, e.pageIndex > 0)) { const t = Math.ceil(e.length / e.pageSize) - 1 || 0, n = Math.min(e.pageIndex, t); n !== e.pageIndex && (e.pageIndex = n, this._internalPageChanges.next()) } }) } connect() { return this._renderData } disconnect() { } } var lk = n("isOO"); let ck = (() => { class t { constructor(t) { this.httpClient = t, this.account = { cpu_limit: { used: 1, max: 1 }, net_limit: { used: 1, max: 1 } }, this.actions = [], this.tokens = [], this.streamClientStatus = !1, this.pendingSet = new Set, this.loaded = !1, this.getServerUrl(), this.getAccountUrl = "/v2/state/get_account?account=", this.getActionsUrl = "/v2/history/get_actions?account=", this.getCreatorUrl = "/v2/history/get_creator?account=", this.getTxUrl = "/v2/history/get_transaction?id=", this.getBlockUrl = "/v1/trace_api/get_block", this.getKeyUrl = "/v2/state/get_key_accounts?public_key=", this.tableDataSource = new ak([]), this.initStreamClient().catch(console.log) } monitorLib() { return sS(this, void 0, void 0, (function* () { console.log("Starting LIB monitoring..."), this.verificationLoop || (this.verificationLoop = setInterval(() => sS(this, void 0, void 0, (function* () { yield this.updateLib() })), 126e3)), this.predictionLoop || (this.predictionLoop = setInterval(() => { this.libNum += 12, this.pendingSet.size > 0 ? this.pendingSet.forEach(t => sS(this, void 0, void 0, (function* () { t < this.libNum && (console.log(`Block cleared ${t} < ${this.libNum}`), this.pendingSet.delete(t)) }))) : (console.log("No more pending actions, clearing loops"), this.clearLoops()) }, 6e3)) })) } checkIrreversibility() { return sS(this, void 0, void 0, (function* () { if (this.libNum = yield this.checkLib(), this.libNum) { let t = 0; for (const e of this.actions) e.block_num <= this.libNum ? e.irreversible = !0 : (t++, this.pendingSet.add(e.block_num)); t > 0 && (console.log("Pending actions: " + t), this.monitorLib().catch(console.log)) } })) } getServerUrl() { let t; t = window.location.origin, this.server = t } updateLib() { return sS(this, void 0, void 0, (function* () { this.libNum = yield this.checkLib() })) } checkLib() { return sS(this, void 0, void 0, (function* () { try { const t = yield this.httpClient.get(this.server + "/v1/chain/get_info").toPromise(); return t ? t.last_irreversible_block_num : null } catch (t) { return console.log(t), null } })) } initStreamClient() { return sS(this, void 0, void 0, (function* () { try { (yield this.httpClient.get(this.server + "/v2/health").toPromise()).features.streaming.enable && (this.streamClient = new lk.HyperionSocketClient(this.server, { async: !0 }), this.streamClient.onConnect = () => { this.streamClientStatus = this.streamClient.online }, this.streamClient.onLIB = t => { this.libNum = t.block_num }, this.streamClient.onData = (t, e) => sS(this, void 0, void 0, (function* () { "action" === t.type && (this.actions.unshift(t.content), this.actions.length > 20 && this.actions.pop(), this.tableDataSource.data = this.actions), e() }))) } catch (t) { console.log(t) } })) } setupRequests() { let t = 0; for (const e of this.actions) e.block_num > t && (t = e.block_num); console.log(t), this.streamClient.onConnect = () => { this.streamClient.streamActions({ account: this.account.account_name, action: "*", contract: "*", filters: [], read_until: 0, start_from: t + 1 }), this.streamClientStatus = this.streamClient.online } } loadAccountData(t) { return sS(this, void 0, void 0, (function* () { this.loaded = !1; try { return this.jsonData = yield this.httpClient.get(this.getAccountUrl + t).toPromise(), this.jsonData.account && (this.account = this.jsonData.account), this.jsonData.tokens && (this.tokens = this.jsonData.tokens), this.jsonData.actions && (this.actions = this.jsonData.actions, this.checkIrreversibility().catch(console.log), this.tableDataSource.data = this.actions), this.loaded = !0, !0 } catch (e) { return console.log(e), this.jsonData = null, this.loaded = !0, !1 } })) } loadMoreActions(t) { return sS(this, void 0, void 0, (function* () { const e = this.actions[this.actions.length - 1].global_sequence - 1; try { const n = this.getActionsUrl + t + "&global_sequence=0-" + e + "&limit=50", i = yield this.httpClient.get(n).toPromise(); i.actions && i.actions.length > 0 && (this.actions.push(...i.actions), this.tableDataSource.data = this.actions) } catch (n) { console.log(n) } })) } loadTxData(t) { return sS(this, void 0, void 0, (function* () { this.loaded = !1; try { const e = yield this.httpClient.get(this.getTxUrl + t).toPromise(); return this.loaded = !0, e } catch (e) { return console.log(e), this.loaded = !0, null } })) } loadBlockData(t) { return sS(this, void 0, void 0, (function* () { this.loaded = !1; try { const e = yield this.httpClient.post(this.getBlockUrl, { block_num: t }).toPromise(); return this.loaded = !0, e } catch (e) { return console.log(e), this.loaded = !0, null } })) } loadPubKey(t) { return sS(this, void 0, void 0, (function* () { this.loaded = !1; try { const e = yield this.httpClient.get(this.getKeyUrl + t + "&details=true").toPromise(); return this.loaded = !0, e } catch (e) { return console.log(e), this.loaded = !0, null } })) } getCreator(t) { return sS(this, void 0, void 0, (function* () { try { return yield this.httpClient.get(this.getCreatorUrl + t).toPromise() } catch (e) { return console.log(e), null } })) } toggleStreaming() { this.streamClientStatus ? (this.streamClient.disconnect(), this.streamClientStatus = !1, this.checkIrreversibility().catch(console.log)) : (this.tableDataSource.paginator.firstPage(), this.clearLoops(), this.setupRequests(), this.streamClient.connect(() => { console.log("hyperion streaming client connected!") })) } clearLoops() { this.predictionLoop && clearInterval(this.predictionLoop), this.verificationLoop && clearInterval(this.verificationLoop) } disconnectStream() { this.streamClient && this.streamClientStatus && (this.streamClient.disconnect(), this.streamClient.online = !1, this.streamClientStatus = !1) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(f_)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), hk = (() => { class t { constructor(t, e) { this.httpClient = t, this.router = e, this.searchAccountUrl = "/v1/chain/get_table_by_scope" } filterAccountNames(t) { return sS(this, void 0, void 0, (function* () { if (t && t.length > 12 || !t) return []; try { const e = t.toLowerCase(), n = { code: "lpc", table: "userres", lower_bound: e, limit: 5 }, i = yield this.httpClient.post(this.searchAccountUrl, n).toPromise(); if (i.rows) return i.rows.filter(t => t.scope.startsWith(e)).map(t => t.scope) } catch (e) { return console.log(e), [] } })) } submitSearch(t, e) { return sS(this, void 0, void 0, (function* () { const n = t.toLowerCase(); if (e.length > 0) return yield this.router.navigate(["/account", n]), !0; if (64 === n.length) return yield this.router.navigate(["/transaction", n]), !0; if (n.length > 0 && n.length <= 12 && isNaN(n)) return yield this.router.navigate(["/account", n]), !0; if (t.startsWith("PUB_K1_") || t.startsWith("LPC")) return yield this.router.navigate(["/key", t]), !0; const i = t.replace(/[,.]/g, ""); return parseInt(i, 10) > 0 && (yield this.router.navigate(["/block", i]), !0) })) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(f_), Kt(Oy)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), uk = (() => { class t { constructor(t, e) { this.http = t, this.title = e, this.chainInfoData = {}, this.loadChainData().catch(console.log) } loadChainData() { return sS(this, void 0, void 0, (function* () { try { this.chainInfoData = yield this.http.get("/v2/explorer_metadata").toPromise(), this.chainInfoData.chain_name && this.title.setTitle(`${this.chainInfoData.chain_name} Hyperion Explorer`) } catch (t) { console.log(t) } })) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(f_), Kt(Uu)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const dk = { provide: bc, useFactory: function (t, e) { return () => { if (lu(e)) { const e = Array.from(t.querySelectorAll(`[class*=${pk}]`)), n = /\bflex-layout-.+?\b/g; e.forEach(t => { t.classList.contains(`${pk}ssr`) && t.parentNode ? t.parentNode.removeChild(t) : t.className.replace(n, "") }) } } }, deps: [ph, vc], multi: !0 }, pk = "flex-layout-"; let fk = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [dk] }), t })(); class mk { constructor(t = !1, e = "all", n = "", i = "", r = 0) { this.matches = t, this.mediaQuery = e, this.mqAlias = n, this.suffix = i, this.priority = r, this.property = "" } clone() { return new mk(this.matches, this.mediaQuery, this.mqAlias, this.suffix) } } let gk = (() => { class t { constructor() { this.stylesheet = new Map } addStyleToElement(t, e, n) { const i = this.stylesheet.get(t); i ? i.set(e, n) : this.stylesheet.set(t, new Map([[e, n]])) } clearStyles() { this.stylesheet.clear() } getStyleForElement(t, e) { const n = this.stylesheet.get(t); let i = ""; if (n) { const t = n.get(e); "number" != typeof t && "string" != typeof t || (i = t + "") } return i } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const yk = { addFlexToParent: !0, addOrientationBps: !1, disableDefaultBps: !1, disableVendorPrefixes: !1, serverLoaded: !1, useColumnBasisZero: !0, printWithBreakpoints: [], mediaTriggerAutoRestore: !0, ssrObserveBreakpoints: [] }, _k = new Bt("Flex Layout token, config options for the library", { providedIn: "root", factory: () => yk }), vk = new Bt("FlexLayoutServerLoaded", { providedIn: "root", factory: () => !1 }), bk = new Bt("Flex Layout token, collect all breakpoints into one provider", { providedIn: "root", factory: () => null }); function wk(t, e) { return t = t ? t.clone() : new mk, e && (t.mqAlias = e.alias, t.mediaQuery = e.mediaQuery, t.suffix = e.suffix, t.priority = e.priority), t } const xk = ["row", "column", "row-reverse", "column-reverse"]; function Ck(t) { if (t) switch (t.toLowerCase()) { case "reverse": case "wrap-reverse": case "reverse-wrap": t = "wrap-reverse"; break; case "no": case "none": case "nowrap": t = "nowrap"; break; default: t = "wrap" }return t } let Sk = (() => { class t { constructor(t, e, n, i) { this.elementRef = t, this.styleBuilder = e, this.styler = n, this.marshal = i, this.DIRECTIVE_KEY = "", this.inputs = [], this.mru = {}, this.destroySubject = new k, this.styleCache = new Map } get parentElement() { return this.elementRef.nativeElement.parentElement } get nativeElement() { return this.elementRef.nativeElement } get activatedValue() { return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY) } set activatedValue(t) { this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, t, this.marshal.activatedAlias) } ngOnChanges(t) { Object.keys(t).forEach(e => { if (-1 !== this.inputs.indexOf(e)) { const n = e.split(".").slice(1).join("."); this.setValue(t[e].currentValue, n) } }) } ngOnDestroy() { this.destroySubject.next(), this.destroySubject.complete(), this.marshal.releaseElement(this.nativeElement) } init(t = []) { this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), t) } addStyles(t, e) { const n = this.styleBuilder, i = n.shouldCache; let r = this.styleCache.get(t); r && i || (r = n.buildStyles(t, e), i && this.styleCache.set(t, r)), this.mru = Object.assign({}, r), this.applyStyleToElement(r), n.sideEffect(t, r, e) } clearStyles() { Object.keys(this.mru).forEach(t => { this.mru[t] = "" }), this.applyStyleToElement(this.mru), this.mru = {} } triggerUpdate() { this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY) } getFlexFlowDirection(t, e = !1) { if (t) { const [n, i] = this.styler.getFlowDirection(t); if (!i && e) { const e = function (t) { let [e, n, i] = function (t) { t = t ? t.toLowerCase() : ""; let [e, n, i] = t.split(" "); return xk.find(t => t === e) || (e = xk[0]), "inline" === n && (n = "inline" !== i ? i : "", i = "inline"), [e, Ck(n), !!i] }(t); return function (t, e = null, n = !1) { return { display: n ? "inline-flex" : "flex", "box-sizing": "border-box", "flex-direction": t, "flex-wrap": e || null } }(e, n, i) }(n); this.styler.applyStyleToElements(e, [t]) } return n.trim() } return "row" } applyStyleToElement(t, e, n = this.nativeElement) { this.styler.applyStyleToElement(n, t, e) } setValue(t, e) { this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, t, e) } updateWithValue(t) { this.addStyles(t) } } return t.\u0275fac = function (t) { Po() }, t.\u0275dir = we({ type: t, features: [Ta] }), t })(); const kk = [{ alias: "xs", mediaQuery: "screen and (min-width: 0px) and (max-width: 599.9px)", priority: 1e3 }, { alias: "sm", mediaQuery: "screen and (min-width: 600px) and (max-width: 959.9px)", priority: 900 }, { alias: "md", mediaQuery: "screen and (min-width: 960px) and (max-width: 1279.9px)", priority: 800 }, { alias: "lg", mediaQuery: "screen and (min-width: 1280px) and (max-width: 1919.9px)", priority: 700 }, { alias: "xl", mediaQuery: "screen and (min-width: 1920px) and (max-width: 4999.9px)", priority: 600 }, { alias: "lt-sm", overlapping: !0, mediaQuery: "screen and (max-width: 599.9px)", priority: 950 }, { alias: "lt-md", overlapping: !0, mediaQuery: "screen and (max-width: 959.9px)", priority: 850 }, { alias: "lt-lg", overlapping: !0, mediaQuery: "screen and (max-width: 1279.9px)", priority: 750 }, { alias: "lt-xl", overlapping: !0, priority: 650, mediaQuery: "screen and (max-width: 1919.9px)" }, { alias: "gt-xs", overlapping: !0, mediaQuery: "screen and (min-width: 600px)", priority: -950 }, { alias: "gt-sm", overlapping: !0, mediaQuery: "screen and (min-width: 960px)", priority: -850 }, { alias: "gt-md", overlapping: !0, mediaQuery: "screen and (min-width: 1280px)", priority: -750 }, { alias: "gt-lg", overlapping: !0, mediaQuery: "screen and (min-width: 1920px)", priority: -650 }], Ek = "(orientation: portrait) and (min-width: 600px) and (max-width: 839.9px)", Ok = "(orientation: landscape) and (min-width: 960px) and (max-width: 1279.9px)", Ak = "(orientation: portrait) and (min-width: 840px)", Tk = "(orientation: landscape) and (min-width: 1280px)", Pk = { HANDSET: "(orientation: portrait) and (max-width: 599.9px), (orientation: landscape) and (max-width: 959.9px)", TABLET: `${Ek} , ${Ok}`, WEB: `${Ak}, ${Tk} `, HANDSET_PORTRAIT: "(orientation: portrait) and (max-width: 599.9px)", TABLET_PORTRAIT: `${Ek} `, WEB_PORTRAIT: `${Ak}`, HANDSET_LANDSCAPE: "(orientation: landscape) and (max-width: 959.9px)]", TABLET_LANDSCAPE: `${Ok}`, WEB_LANDSCAPE: `${Tk}` }, Dk = [{ alias: "handset", priority: 2e3, mediaQuery: Pk.HANDSET }, { alias: "handset.landscape", priority: 2e3, mediaQuery: Pk.HANDSET_LANDSCAPE }, { alias: "handset.portrait", priority: 2e3, mediaQuery: Pk.HANDSET_PORTRAIT }, { alias: "tablet", priority: 2100, mediaQuery: Pk.TABLET }, { alias: "tablet.landscape", priority: 2100, mediaQuery: Pk.TABLET }, { alias: "tablet.portrait", priority: 2100, mediaQuery: Pk.TABLET_PORTRAIT }, { alias: "web", priority: 2200, mediaQuery: Pk.WEB, overlapping: !0 }, { alias: "web.landscape", priority: 2200, mediaQuery: Pk.WEB_LANDSCAPE, overlapping: !0 }, { alias: "web.portrait", priority: 2200, mediaQuery: Pk.WEB_PORTRAIT, overlapping: !0 }], Ik = /(\.|-|_)/g; function Rk(t) { let e = t.length > 0 ? t.charAt(0) : "", n = t.length > 1 ? t.slice(1) : ""; return e.toUpperCase() + n } const Mk = new Bt("Token (@angular/flex-layout) Breakpoints", { providedIn: "root", factory: () => { const t = Qt(bk), e = Qt(_k), n = [].concat.apply([], (t || []).map(t => Array.isArray(t) ? t : [t])); return function (t, e = []) { const n = {}; return t.forEach(t => { n[t.alias] = t }), e.forEach(t => { n[t.alias] ? function (t, ...e) { if (null == t) throw TypeError("Cannot convert undefined or null to object"); for (let n of e) if (null != n) for (let e in n) n.hasOwnProperty(e) && (t[e] = n[e]) }(n[t.alias], t) : n[t.alias] = t }), (i = Object.keys(n).map(t => n[t])).forEach(t => { t.suffix || (t.suffix = t.alias.replace(Ik, "|").split("|").map(Rk).join(""), t.overlapping = !!t.overlapping) }), i; var i }((e.disableDefaultBps ? [] : kk).concat(e.addOrientationBps ? Dk : []), n) } }); function Lk(t, e) { return (e && e.priority || 0) - (t && t.priority || 0) } function Fk(t, e) { return (t.priority || 0) - (e.priority || 0) } let Nk = (() => { class t { constructor(t) { this.findByMap = new Map, this.items = [...t].sort(Fk) } findByAlias(t) { return t ? this.findWithPredicate(t, e => e.alias == t) : null } findByQuery(t) { return this.findWithPredicate(t, e => e.mediaQuery == t) } get overlappings() { return this.items.filter(t => 1 == t.overlapping) } get aliases() { return this.items.map(t => t.alias) } get suffixes() { return this.items.map(t => t.suffix ? t.suffix : "") } findWithPredicate(t, e) { let n = this.findByMap.get(t); return n || (n = this.items.find(e) || null, this.findByMap.set(t, n)), n || null } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Mk)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Mk)) }, token: t, providedIn: "root" }), t })(), Vk = (() => { class t { constructor(t, e, n) { this._zone = t, this._platformId = e, this._document = n, this.source = new yf(new mk(!0)), this.registry = new Map, this._observable$ = this.source.asObservable() } get activations() { const t = []; return this.registry.forEach((e, n) => { e.matches && t.push(n) }), t } isActive(t) { const e = this.registry.get(t); return !!e && e.matches } observe(t, e = !1) { if (t && t.length) { const n = this._observable$.pipe(Of(n => !e || t.indexOf(n.mediaQuery) > -1)); return G(new b(e => { const n = this.registerQuery(t); if (n.length) { const t = n.pop(); n.forEach(t => { e.next(t) }), this.source.next(t) } e.complete() }), n) } return this._observable$ } registerQuery(t) { const e = Array.isArray(t) ? t : [t], n = []; return function (t, e) { const n = t.filter(t => !jk[t]); if (n.length > 0) { const t = n.join(", "); try { const i = e.createElement("style"); i.setAttribute("type", "text/css"), i.styleSheet || i.appendChild(e.createTextNode(`\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${t} {.fx-query-test{ }}\n`)), e.head.appendChild(i), n.forEach(t => jk[t] = i) } catch (i) { console.error(i) } } }(e, this._document), e.forEach(t => { let e = this.registry.get(t); e || (e = this.buildMQL(t), e.addListener(e => { this._zone.run(() => this.source.next(new mk(e.matches, t))) }), this.registry.set(t, e)), e.matches && n.push(new mk(!0, t)) }), n } buildMQL(t) { return function (t, e) { return e && window.matchMedia("all").addListener ? window.matchMedia(t) : { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } }(t, lu(this._platformId)) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Lc), Kt(vc), Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Lc), Kt(vc), Kt(ph)) }, token: t, providedIn: "root" }), t })(); const jk = {}, Bk = { alias: "print", mediaQuery: "print", priority: 1e3 }; let zk = (() => { class t { constructor(t, e, n) { this.breakpoints = t, this.layoutConfig = e, this._document = n, this.registeredBeforeAfterPrintHooks = !1, this.isPrintingBeforeAfterEvent = !1, this.isPrinting = !1, this.queue = new Hk, this.deactivations = [] } withPrintQuery(t) { return [...t, "print"] } isPrintEvent(t) { return t.mediaQuery.startsWith("print") } get printAlias() { return this.layoutConfig.printWithBreakpoints || [] } get printBreakPoints() { return this.printAlias.map(t => this.breakpoints.findByAlias(t)).filter(t => null !== t) } getEventBreakpoints({ mediaQuery: t }) { const e = this.breakpoints.findByQuery(t); return (e ? [...this.printBreakPoints, e] : this.printBreakPoints).sort(Lk) } updateEvent(t) { let e = this.breakpoints.findByQuery(t.mediaQuery); return this.isPrintEvent(t) && (e = this.getEventBreakpoints(t)[0], t.mediaQuery = e ? e.mediaQuery : ""), wk(t, e) } registerBeforeAfterPrintHooks(t) { this._document.defaultView && !this.registeredBeforeAfterPrintHooks && (this.registeredBeforeAfterPrintHooks = !0, this._document.defaultView.addEventListener("beforeprint", () => { this.isPrinting || (this.isPrintingBeforeAfterEvent = !0, this.startPrinting(t, this.getEventBreakpoints(new mk(!0, "print"))), t.updateStyles()) }), this._document.defaultView.addEventListener("afterprint", () => { this.isPrintingBeforeAfterEvent = !1, this.isPrinting && (this.stopPrinting(t), t.updateStyles()) })) } interceptEvents(t) { return this.registerBeforeAfterPrintHooks(t), e => { this.isPrintEvent(e) ? e.matches && !this.isPrinting ? (this.startPrinting(t, this.getEventBreakpoints(e)), t.updateStyles()) : e.matches || !this.isPrinting || this.isPrintingBeforeAfterEvent || (this.stopPrinting(t), t.updateStyles()) : this.collectActivations(e) } } blockPropagation() { return t => !(this.isPrinting || this.isPrintEvent(t)) } startPrinting(t, e) { this.isPrinting = !0, t.activatedBreakpoints = this.queue.addPrintBreakpoints(e) } stopPrinting(t) { t.activatedBreakpoints = this.deactivations, this.deactivations = [], this.queue.clear(), this.isPrinting = !1 } collectActivations(t) { if (!this.isPrinting || this.isPrintingBeforeAfterEvent) if (t.matches) this.isPrintingBeforeAfterEvent || (this.deactivations = []); else { const e = this.breakpoints.findByQuery(t.mediaQuery); e && (this.deactivations.push(e), this.deactivations.sort(Lk)) } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Nk), Kt(_k), Kt(ph)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Nk), Kt(_k), Kt(ph)) }, token: t, providedIn: "root" }), t })(); class Hk { constructor() { this.printBreakpoints = [] } addPrintBreakpoints(t) { return t.push(Bk), t.sort(Lk), t.forEach(t => this.addBreakpoint(t)), this.printBreakpoints } addBreakpoint(t) { t && void 0 === this.printBreakpoints.find(e => e.mediaQuery === t.mediaQuery) && (this.printBreakpoints = function (t) { return !!t && t.mediaQuery.startsWith("print") }(t) ? [t, ...this.printBreakpoints] : [...this.printBreakpoints, t]) } clear() { this.printBreakpoints = [] } } function Uk(t) { for (let e in t) { let n = t[e] || ""; switch (e) { case "display": t.display = "flex" === n ? ["-webkit-flex", "flex"] : "inline-flex" === n ? ["-webkit-inline-flex", "inline-flex"] : n; break; case "align-items": case "align-self": case "align-content": case "flex": case "flex-basis": case "flex-flow": case "flex-grow": case "flex-shrink": case "flex-wrap": case "justify-content": t["-webkit-" + e] = n; break; case "flex-direction": n = n || "row", t["-webkit-flex-direction"] = n, t["flex-direction"] = n; break; case "order": t.order = t["-webkit-" + e] = isNaN(+n) ? "0" : n } } return t } let $k = (() => { class t { constructor(t, e, n, i) { this._serverStylesheet = t, this._serverModuleLoaded = e, this._platformId = n, this.layoutConfig = i } applyStyleToElement(t, e, n = null) { let i = {}; "string" == typeof e && (i[e] = n, e = i), i = this.layoutConfig.disableVendorPrefixes ? e : Uk(e), this._applyMultiValueStyleToElement(i, t) } applyStyleToElements(t, e = []) { const n = this.layoutConfig.disableVendorPrefixes ? t : Uk(t); e.forEach(t => { this._applyMultiValueStyleToElement(n, t) }) } getFlowDirection(t) { let e = this.lookupStyle(t, "flex-direction"); return [e || "row", this.lookupInlineStyle(t, "flex-direction") || cu(this._platformId) && this._serverModuleLoaded ? e : ""] } lookupAttributeValue(t, e) { return t.getAttribute(e) || "" } lookupInlineStyle(t, e) { return lu(this._platformId) ? t.style.getPropertyValue(e) : this._getServerStyle(t, e) } lookupStyle(t, e, n = !1) { let i = ""; return t && ((i = this.lookupInlineStyle(t, e)) || (lu(this._platformId) ? n || (i = getComputedStyle(t).getPropertyValue(e)) : this._serverModuleLoaded && (i = this._serverStylesheet.getStyleForElement(t, e)))), i ? i.trim() : "" } _applyMultiValueStyleToElement(t, e) { Object.keys(t).sort().forEach(n => { const i = t[n], r = Array.isArray(i) ? i : [i]; r.sort(); for (let t of r) t = t ? t + "" : "", lu(this._platformId) || !this._serverModuleLoaded ? lu(this._platformId) ? e.style.setProperty(n, t) : this._setServerStyle(e, n, t) : this._serverStylesheet.addStyleToElement(e, n, t) }) } _setServerStyle(t, e, n) { e = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); const i = this._readStyleAttribute(t); i[e] = n || "", this._writeStyleAttribute(t, i) } _getServerStyle(t, e) { return this._readStyleAttribute(t)[e] || "" } _readStyleAttribute(t) { const e = {}, n = t.getAttribute("style"); if (n) { const t = n.split(/;+/g); for (let n = 0; n < t.length; n++) { const i = t[n].trim(); if (i.length > 0) { const t = i.indexOf(":"); if (-1 === t) throw new Error(`Invalid CSS style: ${i}`); e[i.substr(0, t).trim()] = i.substr(t + 1).trim() } } } return e } _writeStyleAttribute(t, e) { let n = ""; for (const i in e) e[i] && (n += i + ":" + e[i] + ";"); t.setAttribute("style", n) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(gk), Kt(vk), Kt(vc), Kt(_k)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(gk), Kt(vk), Kt(vc), Kt(_k)) }, token: t, providedIn: "root" }), t })(); class qk { constructor() { this.shouldCache = !0 } sideEffect(t, e, n) { } } function Wk(t, e = "1", n = "1") { let i = [e, n, t], r = t.indexOf("calc"); if (r > 0) { i[2] = Gk(t.substring(r).trim()); let e = t.substr(0, r).trim().split(" "); 2 == e.length && (i[0] = e[0], i[1] = e[1]) } else if (0 == r) i[2] = Gk(t.trim()); else { let r = t.split(" "); i = 3 === r.length ? r : [e, n, t] } return i } function Gk(t) { return t.replace(/[\s]/g, "").replace(/[\/\*\+\-]/g, " $& ") } let Yk = (() => { class t { constructor(t, e, n) { this.matchMedia = t, this.breakpoints = e, this.hook = n, this.activatedBreakpoints = [], this.elementMap = new Map, this.elementKeyMap = new WeakMap, this.watcherMap = new WeakMap, this.updateMap = new WeakMap, this.clearMap = new WeakMap, this.subject = new k, this.observeActivations() } get activatedAlias() { return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : "" } onMediaChange(t) { const e = this.findByQuery(t.mediaQuery); e && ((t = wk(t, e)).matches && -1 === this.activatedBreakpoints.indexOf(e) ? (this.activatedBreakpoints.push(e), this.activatedBreakpoints.sort(Lk), this.updateStyles()) : t.matches || -1 === this.activatedBreakpoints.indexOf(e) || (this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(e), 1), this.activatedBreakpoints.sort(Lk), this.updateStyles())) } init(t, e, n, i, r = []) { Xk(this.updateMap, t, e, n), Xk(this.clearMap, t, e, i), this.buildElementKeyMap(t, e), this.watchExtraTriggers(t, e, r) } getValue(t, e, n) { const i = this.elementMap.get(t); if (i) { const t = void 0 !== n ? i.get(n) : this.getActivatedValues(i, e); if (t) return t.get(e) } } hasValue(t, e) { const n = this.elementMap.get(t); if (n) { const t = this.getActivatedValues(n, e); if (t) return void 0 !== t.get(e) || !1 } return !1 } setValue(t, e, n, i) { let r = this.elementMap.get(t); if (r) { const s = (r.get(i) || new Map).set(e, n); r.set(i, s), this.elementMap.set(t, r) } else r = (new Map).set(i, (new Map).set(e, n)), this.elementMap.set(t, r); const s = this.getValue(t, e); void 0 !== s && this.updateElement(t, e, s) } trackValue(t, e) { return this.subject.asObservable().pipe(Of(n => n.element === t && n.key === e)) } updateStyles() { this.elementMap.forEach((t, e) => { const n = new Set(this.elementKeyMap.get(e)); let i = this.getActivatedValues(t); i && i.forEach((t, i) => { this.updateElement(e, i, t), n.delete(i) }), n.forEach(n => { if (i = this.getActivatedValues(t, n), i) { const t = i.get(n); this.updateElement(e, n, t) } else this.clearElement(e, n) }) }) } clearElement(t, e) { const n = this.clearMap.get(t); if (n) { const i = n.get(e); i && (i(), this.subject.next({ element: t, key: e, value: "" })) } } updateElement(t, e, n) { const i = this.updateMap.get(t); if (i) { const r = i.get(e); r && (r(n), this.subject.next({ element: t, key: e, value: n })) } } releaseElement(t) { const e = this.watcherMap.get(t); e && (e.forEach(t => t.unsubscribe()), this.watcherMap.delete(t)); const n = this.elementMap.get(t); n && (n.forEach((t, e) => n.delete(e)), this.elementMap.delete(t)) } triggerUpdate(t, e) { const n = this.elementMap.get(t); if (n) { const i = this.getActivatedValues(n, e); i && (e ? this.updateElement(t, e, i.get(e)) : i.forEach((e, n) => this.updateElement(t, n, e))) } } buildElementKeyMap(t, e) { let n = this.elementKeyMap.get(t); n || (n = new Set, this.elementKeyMap.set(t, n)), n.add(e) } watchExtraTriggers(t, e, n) { if (n && n.length) { let i = this.watcherMap.get(t); if (i || (i = new Map, this.watcherMap.set(t, i)), !i.get(e)) { const r = G(...n).subscribe(() => { const n = this.getValue(t, e); this.updateElement(t, e, n) }); i.set(e, r) } } } findByQuery(t) { return this.breakpoints.findByQuery(t) } getActivatedValues(t, e) { for (let i = 0; i < this.activatedBreakpoints.length; i++) { const n = t.get(this.activatedBreakpoints[i].alias); if (n && (void 0 === e || n.has(e))) return n } const n = t.get(""); return void 0 === e || n && n.has(e) ? n : void 0 } observeActivations() { const t = this.breakpoints.items.map(t => t.mediaQuery); this.matchMedia.observe(this.hook.withPrintQuery(t)).pipe(am(this.hook.interceptEvents(this)), Of(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this)) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(Vk), Kt(Nk), Kt(zk)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(Vk), Kt(Nk), Kt(zk)) }, token: t, providedIn: "root" }), t })(); function Xk(t, e, n, i) { if (void 0 !== i) { let r = t.get(e); r || (r = new Map, t.set(e, r)), r.set(n, i) } } const Kk = ["row", "column", "row-reverse", "column-reverse"]; function Qk(t) { t = t ? t.toLowerCase() : ""; let [e, n, i] = t.split(" "); return Kk.find(t => t === e) || (e = Kk[0]), "inline" === n && (n = "inline" !== i ? i : "", i = "inline"), [e, Jk(n), !!i] } function Zk(t) { let [e] = Qk(t); return e.indexOf("row") > -1 } function Jk(t) { if (t) switch (t.toLowerCase()) { case "reverse": case "wrap-reverse": case "reverse-wrap": t = "wrap-reverse"; break; case "no": case "none": case "nowrap": t = "nowrap"; break; default: t = "wrap" }return t } let tE = (() => { class t extends qk { buildStyles(t) { return function (t) { let [e, n, i] = Qk(t); return function (t, e = null, n = !1) { return { display: n ? "inline-flex" : "flex", "box-sizing": "border-box", "flex-direction": t, "flex-wrap": e || null } }(e, n, i) }(t) } } return t.\u0275fac = function (e) { return eE(e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const eE = hi(tE), nE = ["fxLayout", "fxLayout.xs", "fxLayout.sm", "fxLayout.md", "fxLayout.lg", "fxLayout.xl", "fxLayout.lt-sm", "fxLayout.lt-md", "fxLayout.lt-lg", "fxLayout.lt-xl", "fxLayout.gt-xs", "fxLayout.gt-sm", "fxLayout.gt-md", "fxLayout.gt-lg"]; let iE = (() => { class t extends Sk { constructor(t, e, n, i) { super(t, n, e, i), this.DIRECTIVE_KEY = "layout", this.styleCache = oE, this.init() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao($k), Ao(tE), Ao(Yk)) }, t.\u0275dir = we({ type: t, features: [Ca] }), t })(), rE = (() => { class t extends iE { constructor() { super(...arguments), this.inputs = nE } } return t.\u0275fac = function (e) { return sE(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "fxLayout", ""], ["", "fxLayout.xs", ""], ["", "fxLayout.sm", ""], ["", "fxLayout.md", ""], ["", "fxLayout.lg", ""], ["", "fxLayout.xl", ""], ["", "fxLayout.lt-sm", ""], ["", "fxLayout.lt-md", ""], ["", "fxLayout.lt-lg", ""], ["", "fxLayout.lt-xl", ""], ["", "fxLayout.gt-xs", ""], ["", "fxLayout.gt-sm", ""], ["", "fxLayout.gt-md", ""], ["", "fxLayout.gt-lg", ""]], inputs: { fxLayout: "fxLayout", "fxLayout.xs": "fxLayout.xs", "fxLayout.sm": "fxLayout.sm", "fxLayout.md": "fxLayout.md", "fxLayout.lg": "fxLayout.lg", "fxLayout.xl": "fxLayout.xl", "fxLayout.lt-sm": "fxLayout.lt-sm", "fxLayout.lt-md": "fxLayout.lt-md", "fxLayout.lt-lg": "fxLayout.lt-lg", "fxLayout.lt-xl": "fxLayout.lt-xl", "fxLayout.gt-xs": "fxLayout.gt-xs", "fxLayout.gt-sm": "fxLayout.gt-sm", "fxLayout.gt-md": "fxLayout.gt-md", "fxLayout.gt-lg": "fxLayout.gt-lg" }, features: [Ca] }), t })(); const sE = hi(rE), oE = new Map, aE = { "margin-left": null, "margin-right": null, "margin-top": null, "margin-bottom": null }; let lE = (() => { class t extends qk { constructor(t) { super(), this._styler = t } buildStyles(t, e) { return t.endsWith(yE) ? function (t, e) { let n = "0px", i = "0px"; return "rtl" === e ? i = "-" + t : n = "-" + t, { margin: `0px ${n} ${"-" + t} ${i}` } }(t = t.slice(0, t.indexOf(yE)), e.directionality) : {} } sideEffect(t, e, n) { const i = n.items; if (t.endsWith(yE)) { const e = function (t, e) { let n = "0px", i = "0px"; return "rtl" === e ? i = t : n = t, { padding: `0px ${n} ${t} ${i}` } }(t = t.slice(0, t.indexOf(yE)), n.directionality); this._styler.applyStyleToElements(e, n.items) } else { const e = i.pop(), r = function (t, e) { const n = _E(e.directionality, e.layout), i = Object.assign({}, aE); return i[n] = t, i }(t, n); this._styler.applyStyleToElements(r, i), this._styler.applyStyleToElements(aE, [e]) } } } return t.\u0275fac = function (e) { return new (e || t)(Kt($k)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt($k)) }, token: t, providedIn: "root" }), t })(); const cE = ["fxLayoutGap", "fxLayoutGap.xs", "fxLayoutGap.sm", "fxLayoutGap.md", "fxLayoutGap.lg", "fxLayoutGap.xl", "fxLayoutGap.lt-sm", "fxLayoutGap.lt-md", "fxLayoutGap.lt-lg", "fxLayoutGap.lt-xl", "fxLayoutGap.gt-xs", "fxLayoutGap.gt-sm", "fxLayoutGap.gt-md", "fxLayoutGap.gt-lg"]; let hE = (() => { class t extends Sk { constructor(t, e, n, i, r, s) { super(t, r, i, s), this.zone = e, this.directionality = n, this.styleUtils = i, this.layout = "row", this.DIRECTIVE_KEY = "layout-gap", this.observerSubject = new k; const o = [this.directionality.change, this.observerSubject.asObservable()]; this.init(o), this.marshal.trackValue(this.nativeElement, "layout").pipe(jw(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)) } get childrenNodes() { const t = this.nativeElement.children, e = []; for (let n = t.length; n--;)e[n] = t[n]; return e } ngAfterContentInit() { this.buildChildObservable(), this.triggerUpdate() } ngOnDestroy() { super.ngOnDestroy(), this.observer && this.observer.disconnect() } onLayoutChange(t) { const e = t.value.split(" "); this.layout = e[0], Kk.find(t => t === this.layout) || (this.layout = "row"), this.triggerUpdate() } updateWithValue(t) { const e = this.childrenNodes.filter(t => 1 === t.nodeType && this.willDisplay(t)).sort((t, e) => { const n = +this.styler.lookupStyle(t, "order"), i = +this.styler.lookupStyle(e, "order"); return isNaN(n) || isNaN(i) || n === i ? 0 : n > i ? 1 : -1 }); if (e.length > 0) { const n = this.directionality.value, i = this.layout; "row" === i && "rtl" === n ? this.styleCache = pE : "row" === i && "rtl" !== n ? this.styleCache = mE : "column" === i && "rtl" === n ? this.styleCache = fE : "column" === i && "rtl" !== n && (this.styleCache = gE), this.addStyles(t, { directionality: n, items: e, layout: i }) } } clearStyles() { const t = Object.keys(this.mru).length > 0, e = t ? "padding" : _E(this.directionality.value, this.layout); t && super.clearStyles(), this.styleUtils.applyStyleToElements({ [e]: "" }, this.childrenNodes) } willDisplay(t) { const e = this.marshal.getValue(t, "show-hide"); return !0 === e || void 0 === e && "none" !== this.styleUtils.lookupStyle(t, "display") } buildChildObservable() { this.zone.runOutsideAngular(() => { "undefined" != typeof MutationObserver && (this.observer = new MutationObserver(t => { t.some(t => t.addedNodes && t.addedNodes.length > 0 || t.removedNodes && t.removedNodes.length > 0) && this.observerSubject.next() }), this.observer.observe(this.nativeElement, { childList: !0 })) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Lc), Ao(Gb), Ao($k), Ao(lE), Ao(Yk)) }, t.\u0275dir = we({ type: t, features: [Ca] }), t })(), uE = (() => { class t extends hE { constructor() { super(...arguments), this.inputs = cE } } return t.\u0275fac = function (e) { return dE(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "fxLayoutGap", ""], ["", "fxLayoutGap.xs", ""], ["", "fxLayoutGap.sm", ""], ["", "fxLayoutGap.md", ""], ["", "fxLayoutGap.lg", ""], ["", "fxLayoutGap.xl", ""], ["", "fxLayoutGap.lt-sm", ""], ["", "fxLayoutGap.lt-md", ""], ["", "fxLayoutGap.lt-lg", ""], ["", "fxLayoutGap.lt-xl", ""], ["", "fxLayoutGap.gt-xs", ""], ["", "fxLayoutGap.gt-sm", ""], ["", "fxLayoutGap.gt-md", ""], ["", "fxLayoutGap.gt-lg", ""]], inputs: { fxLayoutGap: "fxLayoutGap", "fxLayoutGap.xs": "fxLayoutGap.xs", "fxLayoutGap.sm": "fxLayoutGap.sm", "fxLayoutGap.md": "fxLayoutGap.md", "fxLayoutGap.lg": "fxLayoutGap.lg", "fxLayoutGap.xl": "fxLayoutGap.xl", "fxLayoutGap.lt-sm": "fxLayoutGap.lt-sm", "fxLayoutGap.lt-md": "fxLayoutGap.lt-md", "fxLayoutGap.lt-lg": "fxLayoutGap.lt-lg", "fxLayoutGap.lt-xl": "fxLayoutGap.lt-xl", "fxLayoutGap.gt-xs": "fxLayoutGap.gt-xs", "fxLayoutGap.gt-sm": "fxLayoutGap.gt-sm", "fxLayoutGap.gt-md": "fxLayoutGap.gt-md", "fxLayoutGap.gt-lg": "fxLayoutGap.gt-lg" }, features: [Ca] }), t })(); const dE = hi(uE), pE = new Map, fE = new Map, mE = new Map, gE = new Map, yE = " grid"; function _E(t, e) { switch (e) { case "column": return "margin-bottom"; case "column-reverse": return "margin-top"; case "row": return "rtl" === t ? "margin-left" : "margin-right"; case "row-reverse": return "rtl" === t ? "margin-right" : "margin-left"; default: return "rtl" === t ? "margin-left" : "margin-right" } } function vE(t, ...e) { if (null == t) throw TypeError("Cannot convert undefined or null to object"); for (let n of e) if (null != n) for (let e in n) n.hasOwnProperty(e) && (t[e] = n[e]); return t } let bE = (() => { class t extends qk { constructor(t) { super(), this.layoutConfig = t } buildStyles(t, e) { let [n, i, ...r] = t.split(" "), s = r.join(" "); const o = e.direction.indexOf("column") > -1 ? "column" : "row", a = Zk(o) ? "max-width" : "max-height", l = Zk(o) ? "min-width" : "min-height", c = String(s).indexOf("calc") > -1, h = c || "auto" === s, u = String(s).indexOf("%") > -1 && !c, d = String(s).indexOf("px") > -1 || String(s).indexOf("rem") > -1 || String(s).indexOf("em") > -1 || String(s).indexOf("vw") > -1 || String(s).indexOf("vh") > -1; let p = c || d; n = "0" == n ? 0 : n, i = "0" == i ? 0 : i; const f = !n && !i; let m = {}; const g = { "max-width": null, "max-height": null, "min-width": null, "min-height": null }; switch (s || "") { case "": const t = !1 !== this.layoutConfig.useColumnBasisZero; s = "row" === o ? "0%" : t ? "0.000000001px" : "auto"; break; case "initial": case "nogrow": n = 0, s = "auto"; break; case "grow": s = "100%"; break; case "noshrink": i = 0, s = "auto"; break; case "auto": break; case "none": n = 0, i = 0, s = "auto"; break; default: p || u || isNaN(s) || (s += "%"), "0%" === s && (p = !0), "0px" === s && (s = "0%"), m = vE(g, c ? { "flex-grow": n, "flex-shrink": i, "flex-basis": p ? s : "100%" } : { flex: `${n} ${i} ${p ? s : "100%"}` }) }return m.flex || m["flex-grow"] || (m = vE(g, c ? { "flex-grow": n, "flex-shrink": i, "flex-basis": s } : { flex: `${n} ${i} ${s}` })), "0%" !== s && "0px" !== s && "0.000000001px" !== s && "auto" !== s && (m[l] = f || p && n ? s : null, m[a] = f || !h && i ? s : null), m[l] || m[a] ? e.hasWrap && (m[c ? "flex-basis" : "flex"] = m[a] ? c ? m[a] : `${n} ${i} ${m[a]}` : c ? m[l] : `${n} ${i} ${m[l]}`) : m = vE(g, c ? { "flex-grow": n, "flex-shrink": i, "flex-basis": s } : { flex: `${n} ${i} ${s}` }), vE(m, { "box-sizing": "border-box" }) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(_k)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(_k)) }, token: t, providedIn: "root" }), t })(); const wE = ["fxFlex", "fxFlex.xs", "fxFlex.sm", "fxFlex.md", "fxFlex.lg", "fxFlex.xl", "fxFlex.lt-sm", "fxFlex.lt-md", "fxFlex.lt-lg", "fxFlex.lt-xl", "fxFlex.gt-xs", "fxFlex.gt-sm", "fxFlex.gt-md", "fxFlex.gt-lg"]; let xE = (() => { class t extends Sk { constructor(t, e, n, i, r) { super(t, i, e, r), this.layoutConfig = n, this.DIRECTIVE_KEY = "flex", this.direction = "", this.wrap = !1, this.flexGrow = "1", this.flexShrink = "1", this.init(), this.parentElement && (this.marshal.trackValue(this.parentElement, "layout").pipe(jw(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)), this.marshal.trackValue(this.nativeElement, "layout-align").pipe(jw(this.destroySubject)).subscribe(this.triggerReflow.bind(this))) } get shrink() { return this.flexShrink } set shrink(t) { this.flexShrink = t || "1", this.triggerReflow() } get grow() { return this.flexGrow } set grow(t) { this.flexGrow = t || "1", this.triggerReflow() } onLayoutChange(t) { const e = t.value.split(" "); this.direction = e[0], this.wrap = void 0 !== e[1] && "wrap" === e[1], this.triggerUpdate() } updateWithValue(t) { this.direction || (this.direction = this.getFlexFlowDirection(this.parentElement, !1 !== this.layoutConfig.addFlexToParent)); const e = this.direction, n = e.startsWith("row"), i = this.wrap; n && i ? this.styleCache = OE : n && !i ? this.styleCache = kE : !n && i ? this.styleCache = AE : n || i || (this.styleCache = EE); const r = Wk(String(t).replace(";", ""), this.flexGrow, this.flexShrink); this.addStyles(r.join(" "), { direction: e, hasWrap: i }) } triggerReflow() { const t = this.activatedValue; if (void 0 !== t) { const e = Wk(t + "", this.flexGrow, this.flexShrink); this.marshal.updateElement(this.nativeElement, this.DIRECTIVE_KEY, e.join(" ")) } } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao($k), Ao(_k), Ao(bE), Ao(Yk)) }, t.\u0275dir = we({ type: t, inputs: { shrink: ["fxShrink", "shrink"], grow: ["fxGrow", "grow"] }, features: [Ca] }), t })(), CE = (() => { class t extends xE { constructor() { super(...arguments), this.inputs = wE } } return t.\u0275fac = function (e) { return SE(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "fxFlex", ""], ["", "fxFlex.xs", ""], ["", "fxFlex.sm", ""], ["", "fxFlex.md", ""], ["", "fxFlex.lg", ""], ["", "fxFlex.xl", ""], ["", "fxFlex.lt-sm", ""], ["", "fxFlex.lt-md", ""], ["", "fxFlex.lt-lg", ""], ["", "fxFlex.lt-xl", ""], ["", "fxFlex.gt-xs", ""], ["", "fxFlex.gt-sm", ""], ["", "fxFlex.gt-md", ""], ["", "fxFlex.gt-lg", ""]], inputs: { fxFlex: "fxFlex", "fxFlex.xs": "fxFlex.xs", "fxFlex.sm": "fxFlex.sm", "fxFlex.md": "fxFlex.md", "fxFlex.lg": "fxFlex.lg", "fxFlex.xl": "fxFlex.xl", "fxFlex.lt-sm": "fxFlex.lt-sm", "fxFlex.lt-md": "fxFlex.lt-md", "fxFlex.lt-lg": "fxFlex.lt-lg", "fxFlex.lt-xl": "fxFlex.lt-xl", "fxFlex.gt-xs": "fxFlex.gt-xs", "fxFlex.gt-sm": "fxFlex.gt-sm", "fxFlex.gt-md": "fxFlex.gt-md", "fxFlex.gt-lg": "fxFlex.gt-lg" }, features: [Ca] }), t })(); const SE = hi(CE), kE = new Map, EE = new Map, OE = new Map, AE = new Map, TE = { margin: 0, width: "100%", height: "100%", "min-width": "100%", "min-height": "100%" }; let PE = (() => { class t extends qk { buildStyles(t) { return TE } } return t.\u0275fac = function (e) { return DE(e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const DE = hi(PE); let IE = (() => { class t extends Sk { constructor(t, e, n, i) { super(t, n, e, i), this.styleCache = RE, this.addStyles("") } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao($k), Ao(PE), Ao(Yk)) }, t.\u0275dir = we({ type: t, selectors: [["", "fxFill", ""], ["", "fxFlexFill", ""]], features: [Ca] }), t })(); const RE = new Map; let ME = (() => { class t extends qk { buildStyles(t, e) { const n = {}, [i, r] = t.split(" "); switch (i) { case "center": n["justify-content"] = "center"; break; case "space-around": n["justify-content"] = "space-around"; break; case "space-between": n["justify-content"] = "space-between"; break; case "space-evenly": n["justify-content"] = "space-evenly"; break; case "end": case "flex-end": n["justify-content"] = "flex-end"; break; case "start": case "flex-start": default: n["justify-content"] = "flex-start" }switch (r) { case "start": case "flex-start": n["align-items"] = n["align-content"] = "flex-start"; break; case "center": n["align-items"] = n["align-content"] = "center"; break; case "end": case "flex-end": n["align-items"] = n["align-content"] = "flex-end"; break; case "space-between": n["align-content"] = "space-between", n["align-items"] = "stretch"; break; case "space-around": n["align-content"] = "space-around", n["align-items"] = "stretch"; break; case "baseline": n["align-content"] = "stretch", n["align-items"] = "baseline"; break; case "stretch": default: n["align-items"] = n["align-content"] = "stretch" }return vE(n, { display: e.inline ? "inline-flex" : "flex", "flex-direction": e.layout, "box-sizing": "border-box", "max-width": "stretch" === r ? Zk(e.layout) ? null : "100%" : null, "max-height": "stretch" === r && Zk(e.layout) ? "100%" : null }) } } return t.\u0275fac = function (e) { return LE(e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const LE = hi(ME), FE = ["fxLayoutAlign", "fxLayoutAlign.xs", "fxLayoutAlign.sm", "fxLayoutAlign.md", "fxLayoutAlign.lg", "fxLayoutAlign.xl", "fxLayoutAlign.lt-sm", "fxLayoutAlign.lt-md", "fxLayoutAlign.lt-lg", "fxLayoutAlign.lt-xl", "fxLayoutAlign.gt-xs", "fxLayoutAlign.gt-sm", "fxLayoutAlign.gt-md", "fxLayoutAlign.gt-lg"]; let NE = (() => { class t extends Sk { constructor(t, e, n, i) { super(t, n, e, i), this.DIRECTIVE_KEY = "layout-align", this.layout = "row", this.inline = !1, this.init(), this.marshal.trackValue(this.nativeElement, "layout").pipe(jw(this.destroySubject)).subscribe(this.onLayoutChange.bind(this)) } updateWithValue(t) { const e = this.layout || "row", n = this.inline; "row" === e && n ? this.styleCache = $E : "row" !== e || n ? "row-reverse" === e && n ? this.styleCache = WE : "row-reverse" !== e || n ? "column" === e && n ? this.styleCache = qE : "column" !== e || n ? "column-reverse" === e && n ? this.styleCache = GE : "column-reverse" !== e || n || (this.styleCache = UE) : this.styleCache = zE : this.styleCache = HE : this.styleCache = BE, this.addStyles(t, { layout: e, inline: n }) } onLayoutChange(t) { const e = t.value.split(" "); this.layout = e[0], this.inline = t.value.includes("inline"), Kk.find(t => t === this.layout) || (this.layout = "row"), this.triggerUpdate() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao($k), Ao(ME), Ao(Yk)) }, t.\u0275dir = we({ type: t, features: [Ca] }), t })(), VE = (() => { class t extends NE { constructor() { super(...arguments), this.inputs = FE } } return t.\u0275fac = function (e) { return jE(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "fxLayoutAlign", ""], ["", "fxLayoutAlign.xs", ""], ["", "fxLayoutAlign.sm", ""], ["", "fxLayoutAlign.md", ""], ["", "fxLayoutAlign.lg", ""], ["", "fxLayoutAlign.xl", ""], ["", "fxLayoutAlign.lt-sm", ""], ["", "fxLayoutAlign.lt-md", ""], ["", "fxLayoutAlign.lt-lg", ""], ["", "fxLayoutAlign.lt-xl", ""], ["", "fxLayoutAlign.gt-xs", ""], ["", "fxLayoutAlign.gt-sm", ""], ["", "fxLayoutAlign.gt-md", ""], ["", "fxLayoutAlign.gt-lg", ""]], inputs: { fxLayoutAlign: "fxLayoutAlign", "fxLayoutAlign.xs": "fxLayoutAlign.xs", "fxLayoutAlign.sm": "fxLayoutAlign.sm", "fxLayoutAlign.md": "fxLayoutAlign.md", "fxLayoutAlign.lg": "fxLayoutAlign.lg", "fxLayoutAlign.xl": "fxLayoutAlign.xl", "fxLayoutAlign.lt-sm": "fxLayoutAlign.lt-sm", "fxLayoutAlign.lt-md": "fxLayoutAlign.lt-md", "fxLayoutAlign.lt-lg": "fxLayoutAlign.lt-lg", "fxLayoutAlign.lt-xl": "fxLayoutAlign.lt-xl", "fxLayoutAlign.gt-xs": "fxLayoutAlign.gt-xs", "fxLayoutAlign.gt-sm": "fxLayoutAlign.gt-sm", "fxLayoutAlign.gt-md": "fxLayoutAlign.gt-md", "fxLayoutAlign.gt-lg": "fxLayoutAlign.gt-lg" }, features: [Ca] }), t })(); const jE = hi(VE), BE = new Map, zE = new Map, HE = new Map, UE = new Map, $E = new Map, qE = new Map, WE = new Map, GE = new Map; let YE = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[fk, Yb]] }), t })(); const XE = ["*", [["mat-card-footer"]]], KE = ["*", "mat-card-footer"]; let QE = (() => { class t { constructor(t) { this._animationMode = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pf, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-card"]], hostAttrs: [1, "mat-card", "mat-focus-indicator"], hostVars: 2, hostBindings: function (t, e) { 2 & t && sa("_mat-animation-noopable", "NoopAnimations" === e._animationMode) }, exportAs: ["matCard"], ngContentSelectors: KE, decls: 2, vars: 0, template: function (t, e) { 1 & t && (Xo(XE), Ko(0), Ko(1, 1)) }, styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), ZE = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[sw], sw] }), t })(); const JE = ["mat-button", ""], tO = ["*"], eO = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"]; class nO { constructor(t) { this._elementRef = t } } const iO = aw(ow(lw(nO))); let rO = (() => { class t extends iO { constructor(t, e, n) { super(t), this._focusMonitor = e, this._animationMode = n, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const i of eO) this._hasHostAttributes(i) && this._getHostElement().classList.add(i); t.nativeElement.classList.add("mat-button-base"), this._focusMonitor.monitor(this._elementRef, !0), this.isRoundButton && (this.color = "accent") } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(t = "program", e) { this._focusMonitor.focusVia(this._getHostElement(), t, e) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...t) { return t.some(t => this._getHostElement().hasAttribute(t)) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Hb), Ao(pf, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function (t, e) { var n; 1 & t && rc(bw, !0), 2 & t && nc(n = cc()) && (e.ripple = n.first) }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 3, hostBindings: function (t, e) { 2 & t && (So("disabled", e.disabled || null), sa("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [Ca], attrs: JE, ngContentSelectors: tO, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function (t, e) { 1 & t && (Xo(), Ro(0, "span", 0), Ko(1), Mo(), Lo(2, "div", 1), Lo(3, "div", 2)), 2 & t && (yr(2), sa("mat-button-ripple-round", e.isRoundButton || e.isIconButton), Do("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement())) }, directives: [bw], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled],.mat-flat-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.cdk-high-contrast-active .mat-button-focus-overlay{background-color:#fff}.cdk-high-contrast-black-on-white .mat-button-focus-overlay{background-color:#000}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), sO = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[ww, sw], sw] }), t })(); function oO(t) { return (oO = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function aO(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function lO(t) { for (var e = 1; e < arguments.length; e++) { var n = null != arguments[e] ? arguments[e] : {}, i = Object.keys(n); "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function (t) { return Object.getOwnPropertyDescriptor(n, t).enumerable })))), i.forEach((function (e) { aO(t, e, n[e]) })) } return t } function cO(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { var n = [], i = !0, r = !1, s = void 0; try { for (var o, a = t[Symbol.iterator](); !(i = (o = a.next()).done) && (n.push(o.value), !e || n.length !== e); i = !0); } catch (l) { r = !0, s = l } finally { try { i || null == a.return || a.return() } finally { if (r) throw s } } return n }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() } var hO = {}, uO = {}; try { "undefined" != typeof window && (hO = window), "undefined" != typeof document && (uO = document), "undefined" != typeof MutationObserver && MutationObserver, "undefined" != typeof performance && performance } catch (GM) { } var dO = (hO.navigator || {}).userAgent, pO = void 0 === dO ? "" : dO, fO = hO, mO = uO, gO = !!mO.documentElement && !!mO.head && "function" == typeof mO.addEventListener && "function" == typeof mO.createElement, yO = (~pO.indexOf("MSIE") || pO.indexOf("Trident/"), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), _O = yO.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), vO = { GROUP: "group", SWAP_OPACITY: "swap-opacity", PRIMARY: "primary", SECONDARY: "secondary" }, bO = (["xs", "sm", "lg", "fw", "ul", "li", "border", "pull-left", "pull-right", "spin", "pulse", "rotate-90", "rotate-180", "rotate-270", "flip-horizontal", "flip-vertical", "flip-both", "stack", "stack-1x", "stack-2x", "inverse", "layers", "layers-text", "layers-counter", vO.GROUP, vO.SWAP_OPACITY, vO.PRIMARY, vO.SECONDARY].concat(yO.map((function (t) { return "".concat(t, "x") }))).concat(_O.map((function (t) { return "w-".concat(t) }))), fO.FontAwesomeConfig || {}); mO && "function" == typeof mO.querySelector && [["data-family-prefix", "familyPrefix"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((function (t) { var e = cO(t, 2), n = e[1], i = function (t) { return "" === t || "false" !== t && ("true" === t || t) }(function (t) { var e = mO.querySelector("script[" + t + "]"); if (e) return e.getAttribute(t) }(e[0])); null != i && (bO[n] = i) })); var wO = lO({}, { familyPrefix: "fa", replacementClass: "svg-inline--fa", autoReplaceSvg: !0, autoAddCss: !0, autoA11y: !0, searchPseudoElements: !1, observeMutations: !0, mutateApproach: "async", keepOriginalSource: !0, measurePerformance: !1, showMissingIcons: !0 }, bO); wO.autoReplaceSvg || (wO.observeMutations = !1); var xO = lO({}, wO); fO.FontAwesomeConfig = xO; var CO = fO || {}; CO.___FONT_AWESOME___ || (CO.___FONT_AWESOME___ = {}), CO.___FONT_AWESOME___.styles || (CO.___FONT_AWESOME___.styles = {}), CO.___FONT_AWESOME___.hooks || (CO.___FONT_AWESOME___.hooks = {}), CO.___FONT_AWESOME___.shims || (CO.___FONT_AWESOME___.shims = []); var SO = CO.___FONT_AWESOME___, kO = []; gO && ((mO.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(mO.readyState) || mO.addEventListener("DOMContentLoaded", (function t() { mO.removeEventListener("DOMContentLoaded", t), kO.map((function (t) { return t() })) }))); var EO, OO = function () { }, AO = "undefined" != typeof global && void 0 !== global.process && "function" == typeof global.process.emit, TO = "undefined" == typeof setImmediate ? setTimeout : setImmediate, PO = []; function DO() { for (var t = 0; t < PO.length; t++)PO[t][0](PO[t][1]); PO = [], EO = !1 } function IO(t, e) { PO.push([t, e]), EO || (EO = !0, TO(DO, 0)) } function RO(t) { var e = t.owner, n = e._state, i = e._data, r = t[n], s = t.then; if ("function" == typeof r) { n = "fulfilled"; try { i = r(i) } catch (GM) { NO(s, GM) } } MO(s, i) || ("fulfilled" === n && LO(s, i), "rejected" === n && NO(s, i)) } function MO(t, e) { var n; try { if (t === e) throw new TypeError("A promises callback cannot return that same promise."); if (e && ("function" == typeof e || "object" === oO(e))) { var i = e.then; if ("function" == typeof i) return i.call(e, (function (i) { n || (n = !0, e === i ? FO(t, i) : LO(t, i)) }), (function (e) { n || (n = !0, NO(t, e)) })), !0 } } catch (GM) { return n || NO(t, GM), !0 } return !1 } function LO(t, e) { t !== e && MO(t, e) || FO(t, e) } function FO(t, e) { "pending" === t._state && (t._state = "settled", t._data = e, IO(jO, t)) } function NO(t, e) { "pending" === t._state && (t._state = "settled", t._data = e, IO(BO, t)) } function VO(t) { t._then = t._then.forEach(RO) } function jO(t) { t._state = "fulfilled", VO(t) } function BO(t) { t._state = "rejected", VO(t), !t._handled && AO && global.process.emit("unhandledRejection", t._data, t) } function zO(t) { global.process.emit("rejectionHandled", t) } function HO(t) { if ("function" != typeof t) throw new TypeError("Promise resolver " + t + " is not a function"); if (this instanceof HO == 0) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."); this._then = [], function (t, e) { function n(t) { NO(e, t) } try { t((function (t) { LO(e, t) }), n) } catch (GM) { n(GM) } }(t, this) } HO.prototype = { constructor: HO, _state: "pending", _then: null, _data: void 0, _handled: !1, then: function (t, e) { var n = { owner: this, then: new this.constructor(OO), fulfilled: t, rejected: e }; return !e && !t || this._handled || (this._handled = !0, "rejected" === this._state && AO && IO(zO, this)), "fulfilled" === this._state || "rejected" === this._state ? IO(RO, n) : this._then.push(n), n.then }, catch: function (t) { return this.then(null, t) } }, HO.all = function (t) { if (!Array.isArray(t)) throw new TypeError("You must pass an array to Promise.all()."); return new HO((function (e, n) { var i = [], r = 0; function s(t) { return r++, function (n) { i[t] = n, --r || e(i) } } for (var o, a = 0; a < t.length; a++)(o = t[a]) && "function" == typeof o.then ? o.then(s(a), n) : i[a] = o; r || e(i) })) }, HO.race = function (t) { if (!Array.isArray(t)) throw new TypeError("You must pass an array to Promise.race()."); return new HO((function (e, n) { for (var i, r = 0; r < t.length; r++)(i = t[r]) && "function" == typeof i.then ? i.then(e, n) : e(i) })) }, HO.resolve = function (t) { return t && "object" === oO(t) && t.constructor === HO ? t : new HO((function (e) { e(t) })) }, HO.reject = function (t) { return new HO((function (e, n) { n(t) })) }; var UO = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 }; function $O() { for (var t = 12, e = ""; t-- > 0;)e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[62 * Math.random() | 0]; return e } function qO(t) { return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function WO(t) { return Object.keys(t || {}).reduce((function (e, n) { return e + "".concat(n, ": ").concat(t[n], ";") }), "") } function GO(t) { return t.size !== UO.size || t.x !== UO.x || t.y !== UO.y || t.rotate !== UO.rotate || t.flipX || t.flipY } function YO(t) { var e = t.transform, n = t.iconWidth, i = { transform: "translate(".concat(t.containerWidth / 2, " 256)") }, r = "translate(".concat(32 * e.x, ", ").concat(32 * e.y, ") "), s = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), o = "rotate(".concat(e.rotate, " 0 0)"); return { outer: i, inner: { transform: "".concat(r, " ").concat(s, " ").concat(o) }, path: { transform: "translate(".concat(n / 2 * -1, " -256)") } } } var XO = { x: 0, y: 0, width: "100%", height: "100%" }; function KO(t) { var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t } function QO(t) { var e = t.icons, n = e.main, i = e.mask, r = t.prefix, s = t.iconName, o = t.transform, a = t.symbol, l = t.title, c = t.maskId, h = t.titleId, u = t.extra, d = t.watchable, p = void 0 !== d && d, f = i.found ? i : n, m = f.width, g = f.height, y = "fa-w-".concat(Math.ceil(m / g * 16)), _ = [xO.replacementClass, s ? "".concat(xO.familyPrefix, "-").concat(s) : "", y].filter((function (t) { return -1 === u.classes.indexOf(t) })).concat(u.classes).join(" "), v = { children: [], attributes: lO({}, u.attributes, { "data-prefix": r, "data-icon": s, class: _, role: u.attributes.role || "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 ".concat(m, " ").concat(g) }) }; p && (v.attributes["data-fa-i2svg"] = ""), l && v.children.push({ tag: "title", attributes: { id: v.attributes["aria-labelledby"] || "title-".concat(h || $O()) }, children: [l] }); var b = lO({}, v, { prefix: r, iconName: s, main: n, mask: i, maskId: c, transform: o, symbol: a, styles: u.styles }), w = i.found && n.found ? function (t) { var e, n = t.children, i = t.attributes, r = t.main, s = t.mask, o = t.maskId, a = r.icon, l = s.icon, c = YO({ transform: t.transform, containerWidth: s.width, iconWidth: r.width }), h = { tag: "rect", attributes: lO({}, XO, { fill: "white" }) }, u = a.children ? { children: a.children.map(KO) } : {}, d = { tag: "g", attributes: lO({}, c.inner), children: [KO(lO({ tag: a.tag, attributes: lO({}, a.attributes, c.path) }, u))] }, p = { tag: "g", attributes: lO({}, c.outer), children: [d] }, f = "mask-".concat(o || $O()), m = "clip-".concat(o || $O()), g = { tag: "mask", attributes: lO({}, XO, { id: f, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [h, p] }, y = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: m }, children: (e = l, "g" === e.tag ? e.children : [e]) }, g] }; return n.push(y, { tag: "rect", attributes: lO({ fill: "currentColor", "clip-path": "url(#".concat(m, ")"), mask: "url(#".concat(f, ")") }, XO) }), { children: n, attributes: i } }(b) : function (t) { var e = t.children, n = t.attributes, i = t.main, r = t.transform, s = WO(t.styles); if (s.length > 0 && (n.style = s), GO(r)) { var o = YO({ transform: r, containerWidth: i.width, iconWidth: i.width }); e.push({ tag: "g", attributes: lO({}, o.outer), children: [{ tag: "g", attributes: lO({}, o.inner), children: [{ tag: i.icon.tag, children: i.icon.children, attributes: lO({}, i.icon.attributes, o.path) }] }] }) } else e.push(i.icon); return { children: e, attributes: n } }(b), x = w.attributes; return b.children = w.children, b.attributes = x, a ? function (t) { var e = t.iconName, n = t.children, i = t.symbol; return [{ tag: "svg", attributes: { style: "display: none;" }, children: [{ tag: "symbol", attributes: lO({}, t.attributes, { id: !0 === i ? "".concat(t.prefix, "-").concat(xO.familyPrefix, "-").concat(e) : i }), children: n }] }] }(b) : function (t) { var e = t.children, n = t.main, i = t.mask, r = t.attributes, s = t.styles, o = t.transform; if (GO(o) && n.found && !i.found) { var a = { x: n.width / n.height / 2, y: .5 }; r.style = WO(lO({}, s, { "transform-origin": "".concat(a.x + o.x / 16, "em ").concat(a.y + o.y / 16, "em") })) } return [{ tag: "svg", attributes: r, children: e }] }(b) } var ZO = function (t, e, n, i) { var r, s, o, a = Object.keys(t), l = a.length, c = void 0 !== i ? function (t, e) { return function (n, i, r, s) { return t.call(e, n, i, r, s) } }(e, i) : e; for (void 0 === n ? (r = 1, o = t[a[0]]) : (r = 0, o = n); r < l; r++)o = c(o, t[s = a[r]], s, t); return o }; function JO(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = n.skipHooks, r = void 0 !== i && i, s = Object.keys(e).reduce((function (t, n) { var i = e[n]; return i.icon ? t[i.iconName] = i.icon : t[n] = i, t }), {}); "function" != typeof SO.hooks.addPack || r ? SO.styles[t] = lO({}, SO.styles[t] || {}, s) : SO.hooks.addPack(t, s), "fas" === t && JO("fa", e) } var tA = SO.styles, eA = SO.shims, nA = function () { var t = function (t) { return ZO(tA, (function (e, n, i) { return e[i] = ZO(n, t, {}), e }), {}) }; t((function (t, e, n) { return e[3] && (t[e[3]] = n), t })), t((function (t, e, n) { var i = e[2]; return t[n] = n, i.forEach((function (e) { t[e] = n })), t })); var e = "far" in tA; ZO(eA, (function (t, n) { var i = n[1]; return "far" !== i || e || (i = "fas"), t[n[0]] = { prefix: i, iconName: n[2] }, t }), {}) }; function iA(t, e, n) { if (t && t[e] && t[e][n]) return { prefix: e, iconName: n, icon: t[e][n] } } function rA(t) { var e = t.tag, n = t.attributes, i = void 0 === n ? {} : n, r = t.children, s = void 0 === r ? [] : r; return "string" == typeof t ? qO(t) : "<".concat(e, " ").concat(function (t) { return Object.keys(t || {}).reduce((function (e, n) { return e + "".concat(n, '="').concat(qO(t[n]), '" ') }), "").trim() }(i), ">").concat(s.map(rA).join(""), "</").concat(e, ">") } function sA(t) { this.name = "MissingIcon", this.message = t || "Icon unavailable", this.stack = (new Error).stack } nA(), (sA.prototype = Object.create(Error.prototype)).constructor = sA; var oA = { fill: "currentColor" }, aA = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" }, lA = (lO({}, oA, { d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z" }), lO({}, aA, { attributeName: "opacity" })); function cA(t) { var e = t[0], n = t[1], i = cO(t.slice(4), 1)[0]; return { found: !0, width: e, height: n, icon: Array.isArray(i) ? { tag: "g", attributes: { class: "".concat(xO.familyPrefix, "-").concat(vO.GROUP) }, children: [{ tag: "path", attributes: { class: "".concat(xO.familyPrefix, "-").concat(vO.SECONDARY), fill: "currentColor", d: i[0] } }, { tag: "path", attributes: { class: "".concat(xO.familyPrefix, "-").concat(vO.PRIMARY), fill: "currentColor", d: i[1] } }] } : { tag: "path", attributes: { fill: "currentColor", d: i } } } } function hA() { xO.autoAddCss && !mA && (function (t) { if (t && gO) { var e = mO.createElement("style"); e.setAttribute("type", "text/css"), e.innerHTML = t; for (var n = mO.head.childNodes, i = null, r = n.length - 1; r > -1; r--) { var s = n[r], o = (s.tagName || "").toUpperCase();["STYLE", "LINK"].indexOf(o) > -1 && (i = s) } mO.head.insertBefore(e, i) } }(function () { var t = "svg-inline--fa", e = xO.familyPrefix, n = xO.replacementClass, i = 'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}'; if ("fa" !== e || n !== t) { var r = new RegExp("\\.".concat("fa", "\\-"), "g"), s = new RegExp("\\--".concat("fa", "\\-"), "g"), o = new RegExp("\\.".concat(t), "g"); i = i.replace(r, ".".concat(e, "-")).replace(s, "--".concat(e, "-")).replace(o, ".".concat(n)) } return i }()), mA = !0) } function uA(t, e) { return Object.defineProperty(t, "abstract", { get: e }), Object.defineProperty(t, "html", { get: function () { return t.abstract.map((function (t) { return rA(t) })) } }), Object.defineProperty(t, "node", { get: function () { if (gO) { var e = mO.createElement("div"); return e.innerHTML = t.html, e.children } } }), t } function dA(t) { var e = t.prefix, n = void 0 === e ? "fa" : e, i = t.iconName; if (i) return iA(fA.definitions, n, i) || iA(SO.styles, n, i) } lO({}, oA, { cx: "256", cy: "364", r: "28" }), lO({}, aA, { attributeName: "r", values: "28;14;28;28;14;28;" }), lO({}, lA, { values: "1;0;1;1;0;1;" }), lO({}, oA, { opacity: "1", d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z" }), lO({}, lA, { values: "1;0;0;0;0;1;" }), lO({}, oA, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z" }), lO({}, lA, { values: "0;0;1;1;0;0;" }); var pA, fA = new (function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.definitions = {} } var e; return (e = [{ key: "add", value: function () { for (var t = this, e = arguments.length, n = new Array(e), i = 0; i < e; i++)n[i] = arguments[i]; var r = n.reduce(this._pullDefinitions, {}); Object.keys(r).forEach((function (e) { t.definitions[e] = lO({}, t.definitions[e] || {}, r[e]), JO(e, r[e]), nA() })) } }, { key: "reset", value: function () { this.definitions = {} } }, { key: "_pullDefinitions", value: function (t, e) { var n = e.prefix && e.iconName && e.icon ? { 0: e } : e; return Object.keys(n).map((function (e) { var i = n[e], r = i.prefix, s = i.iconName, o = i.icon; t[r] || (t[r] = {}), t[r][s] = o })), t } }]) && function (t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } }(t.prototype, e), t }()), mA = !1, gA = (pA = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.transform, i = void 0 === n ? UO : n, r = e.symbol, s = void 0 !== r && r, o = e.mask, a = void 0 === o ? null : o, l = e.maskId, c = void 0 === l ? null : l, h = e.title, u = void 0 === h ? null : h, d = e.titleId, p = void 0 === d ? null : d, f = e.classes, m = void 0 === f ? [] : f, g = e.attributes, y = void 0 === g ? {} : g, _ = e.styles, v = void 0 === _ ? {} : _; if (t) { var b = t.prefix, w = t.iconName, x = t.icon; return uA(lO({ type: "icon" }, t), (function () { return hA(), xO.autoA11y && (u ? y["aria-labelledby"] = "".concat(xO.replacementClass, "-title-").concat(p || $O()) : (y["aria-hidden"] = "true", y.focusable = "false")), QO({ icons: { main: cA(x), mask: a ? cA(a.icon) : { found: !1, width: null, height: null, icon: {} } }, prefix: b, iconName: w, transform: lO({}, UO, i), symbol: s, title: u, maskId: c, titleId: p, extra: { attributes: y, styles: v, classes: m } }) })) } }, function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = (t || {}).icon ? t : dA(t || {}), i = e.mask; return i && (i = (i || {}).icon ? i : dA(i || {})), pA(n, lO({}, e, { mask: i })) }); const yA = [[["fa-icon"], ["fa-duotone-icon"], ["fa-layers-text"], ["fa-layers-counter"]]], _A = ["fa-icon, fa-duotone-icon, fa-layers-text, fa-layers-counter"]; let vA = (() => { let t = class { constructor() { this.defaultPrefix = "fas", this.fallbackIcon = null, this.globalLibrary = !1 } }; return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), bA = (() => { let t = class { constructor() { this.definitions = {} } addIcons(...t) { for (const e of t) e.prefix in this.definitions || (this.definitions[e.prefix] = {}), this.definitions[e.prefix][e.iconName] = e } addIconPacks(...t) { for (const e of t) { const t = Object.keys(e).map(t => e[t]); this.addIcons(...t) } } getIconDefinition(t, e) { return t in this.definitions && e in this.definitions[t] ? this.definitions[t][e] : null } }; return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const wA = t => { const e = { "fa-spin": t.spin, "fa-pulse": t.pulse, "fa-fw": t.fixedWidth, "fa-border": t.border, "fa-inverse": t.inverse, "fa-layers-counter": t.counter, "fa-flip-horizontal": "horizontal" === t.flip || "both" === t.flip, "fa-flip-vertical": "vertical" === t.flip || "both" === t.flip, [`fa-${t.size}`]: null !== t.size, [`fa-rotate-${t.rotate}`]: null !== t.rotate, [`fa-pull-${t.pull}`]: null !== t.pull, [`fa-stack-${t.stackItemSize}`]: null != t.stackItemSize }; return Object.keys(e).map(t => e[t] ? t : null).filter(t => t) }; let xA = (() => { let t = class { constructor() { this.stackItemSize = "1x" } ngOnChanges(t) { if ("size" in t) throw new Error('fa-icon is not allowed to customize size when used inside fa-stack. Set size on the enclosing fa-stack instead: <fa-stack size="4x">...</fa-stack>.') } }; return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["fa-icon", "stackItemSize", ""], ["fa-duotone-icon", "stackItemSize", ""]], inputs: { stackItemSize: "stackItemSize", size: "size" }, features: [Ta] }), t })(), CA = (() => { let t = class { constructor(t, e, n, i) { this.sanitizer = t, this.config = e, this.iconLibrary = n, this.stackItem = i, this.classes = [] } ngOnChanges(t) { if (null == this.icon && null == this.config.fallbackIcon) return (() => { throw new Error("Property `icon` is required for `fa-icon`/`fa-duotone-icon` components.") })(); let e = null; if (e = null == this.icon ? this.config.fallbackIcon : this.icon, t) { const t = this.findIconDefinition(e); if (null != t) { const e = this.buildParams(); this.renderIcon(t, e) } } } render() { this.ngOnChanges({}) } findIconDefinition(t) { const e = ((t, e) => { return void 0 !== (n = t).prefix && void 0 !== n.iconName ? t : Array.isArray(t) && 2 === t.length ? { prefix: t[0], iconName: t[1] } : "string" == typeof t ? { prefix: e, iconName: t } : void 0; var n })(t, this.config.defaultPrefix); if ("icon" in e) return e; const n = this.iconLibrary.getIconDefinition(e.prefix, e.iconName); if (null != n) return n; const i = dA(e); if (null != i) { const t = "Global icon library is deprecated. Consult https://github.com/FortAwesome/angular-fontawesome/blob/master/UPGRADING.md for the migration instructions."; if ("unset" === this.config.globalLibrary) console.error("FontAwesome: " + t); else if (!this.config.globalLibrary) throw new Error(t); return i } return (t => { throw new Error(`Could not find icon with iconName=${t.iconName} and prefix=${t.prefix} in the icon library.`) })(e), null } buildParams() { const t = { flip: this.flip, spin: this.spin, pulse: this.pulse, border: this.border, inverse: this.inverse, size: this.size || null, pull: this.pull || null, rotate: this.rotate || null, fixedWidth: "boolean" == typeof this.fixedWidth ? this.fixedWidth : this.config.fixedWidth, stackItemSize: null != this.stackItem ? this.stackItem.stackItemSize : null }, e = "string" == typeof this.transform ? function (t) { var e = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }; return t ? t.toLowerCase().split(" ").reduce((function (t, e) { var n = e.toLowerCase().split("-"), i = n[0], r = n.slice(1).join("-"); if (i && "h" === r) return t.flipX = !0, t; if (i && "v" === r) return t.flipY = !0, t; if (r = parseFloat(r), isNaN(r)) return t; switch (i) { case "grow": t.size = t.size + r; break; case "shrink": t.size = t.size - r; break; case "left": t.x = t.x - r; break; case "right": t.x = t.x + r; break; case "up": t.y = t.y - r; break; case "down": t.y = t.y + r; break; case "rotate": t.rotate = t.rotate + r }return t }), e) : e }(this.transform) : this.transform; return { title: this.title, transform: e, classes: [...wA(t), ...this.classes], mask: null != this.mask ? this.findIconDefinition(this.mask) : null, styles: null != this.styles ? this.styles : {}, symbol: this.symbol, attributes: { role: this.a11yRole } } } renderIcon(t, e) { const n = gA(t, e); this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(n.html.join("\n")) } }; return t.\u0275fac = function (e) { return new (e || t)(Ao(Nu), Ao(vA), Ao(bA), Ao(xA, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["fa-icon"]], hostAttrs: [1, "ng-fa-icon"], hostVars: 2, hostBindings: function (t, e) { 2 & t && (ba("innerHTML", e.renderedIconHTML, Zi), So("title", e.title)) }, inputs: { classes: "classes", icon: "icon", title: "title", spin: "spin", pulse: "pulse", mask: "mask", styles: "styles", flip: "flip", size: "size", pull: "pull", border: "border", inverse: "inverse", symbol: "symbol", rotate: "rotate", fixedWidth: "fixedWidth", transform: "transform", a11yRole: "a11yRole" }, features: [Ta], decls: 0, vars: 0, template: function (t, e) { }, encapsulation: 2 }), t })(), SA = (() => { let t = class { constructor(t, e, n) { this.renderer = t, this.elementRef = e, this.config = n } ngOnInit() { this.renderer.addClass(this.elementRef.nativeElement, "fa-layers"), this.fixedWidth = "boolean" == typeof this.fixedWidth ? this.fixedWidth : this.config.fixedWidth } ngOnChanges(t) { "size" in t && (null != t.size.currentValue && this.renderer.addClass(this.elementRef.nativeElement, `fa-${t.size.currentValue}`), null != t.size.previousValue && this.renderer.removeClass(this.elementRef.nativeElement, `fa-${t.size.previousValue}`)) } }; return t.\u0275fac = function (e) { return new (e || t)(Ao(Ga), Ao(Ua), Ao(vA)) }, t.\u0275cmp = me({ type: t, selectors: [["fa-layers"]], hostVars: 2, hostBindings: function (t, e) { 2 & t && sa("fa-fw", e.fixedWidth) }, inputs: { fixedWidth: "fixedWidth", size: "size" }, features: [Ta], ngContentSelectors: _A, decls: 1, vars: 0, template: function (t, e) { 1 & t && (Xo(yA), Ko(0)) }, encapsulation: 2 }), t })(), kA = (() => { let t = class { }; return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); function EA(t, e) { if (1 & t && (Ro(0, "mat-error"), ga(1), Mo()), 2 & t) { const t = Go(); yr(1), ya(t.err) } } function OA(t, e) { if (1 & t && (Ro(0, "mat-option", 19), ga(1), Mo()), 2 & t) { const t = e.$implicit; Do("value", t), yr(1), ya(t) } } let AA = (() => { class t { constructor(t, e, n, i, r, s) { this.formBuilder = t, this.router = e, this.accountService = n, this.searchService = i, this.chainData = r, this.title = s, this.faSearch = oS.faSearch, this.placeholders = ["Search by account name...", "Search by block number...", "Search by transaction id...", "Search by public key..."], this.err = "", this.currentPlaceholder = 0, this.searchForm = this.formBuilder.group({ search_field: ["", X_.required] }), this.filteredAccounts = [], this.searchPlaceholder = this.placeholders[0], setInterval(() => { this.currentPlaceholder++, this.placeholders[this.currentPlaceholder] || (this.currentPlaceholder = 0), this.searchPlaceholder = this.placeholders[this.currentPlaceholder] }, 2e3) } ngOnInit() { this.searchForm.get("search_field").valueChanges.pipe(rb(300)).subscribe(t => sS(this, void 0, void 0, (function* () { this.filteredAccounts = yield this.searchService.filterAccountNames(t) }))), this.chainData.chainInfoData.chain_name && this.title.setTitle(`${this.chainData.chainInfoData.chain_name} Hyperion Explorer`) } submit() { return sS(this, void 0, void 0, (function* () { if (!this.searchForm.valid) return; const t = this.searchForm.get("search_field").value; this.searchForm.reset(), this.searchService.submitSearch(t, this.filteredAccounts) || (this.err = "no results for " + t) })) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Kv), Ao(Oy), Ao(ck), Ao(hk), Ao(uk), Ao(Uu)) }, t.\u0275cmp = me({ type: t, selectors: [["app-home"]], decls: 29, vars: 11, consts: [["fxLayout", "column", "fxLayoutAlign", "space-between stretch", 2, "height", "100vh"], ["fxLayout", "column", "fxLayoutAlign", "end center", 1, "search-card"], ["fxLayout", "column", "fxLayoutAlign", "center center", "fxLayoutGap", "20px", 2, "text-align", "center"], ["src", "assets/logo.png", "alt", "logo", 1, "logo"], [3, "formGroup", "ngSubmit"], ["fxLayout", "row", "fxLayoutAlign", "center start"], ["appearance", "outline", 1, "home-search-input"], ["matInput", "", "formControlName", "search_field", 3, "matAutocomplete", "placeholder"], [4, "ngIf"], [3, "optionSelected"], ["auto", "matAutocomplete"], [3, "value", 4, "ngFor", "ngForOf"], ["mat-stroked-button", "", "matSuffix", "", "type", "submit", 1, "search-btn", 3, "keyup.enter"], [3, "icon"], ["fxLayout", "row", "fxLayoutAlign", "center center", "fxLayoutGap", "6px", 2, "margin-bottom", "10px"], ["fxLayout", "row", "fxLayoutAlign", "center center", "fxLayoutGap", "5px", 1, "outline"], ["alt", "logo", 2, "height", "28px", 3, "src"], ["target", "_blank", 3, "href"], [1, "faded", "footer-text"], [3, "value"]], template: function (t, e) { if (1 & t && (Ro(0, "div", 0), Ro(1, "mat-card", 1), Ro(2, "div", 2), Lo(3, "img", 3), Ro(4, "form", 4), Ho("ngSubmit", (function () { return e.submit() })), Ro(5, "div", 5), Ro(6, "mat-form-field", 6), Ro(7, "label"), Lo(8, "input", 7), Mo(), Eo(9, EA, 2, 1, "mat-error", 8), Mo(), Ro(10, "mat-autocomplete", 9, 10), Ho("optionSelected", (function () { return e.submit() })), Eo(12, OA, 2, 2, "mat-option", 11), Mo(), Ro(13, "button", 12), Ho("keyup.enter", (function () { return e.submit() })), Lo(14, "fa-icon", 13), Mo(), Mo(), Mo(), Ro(15, "div"), Ro(16, "div", 14), Ro(17, "span"), ga(18, "Connected to"), Mo(), Ro(19, "span", 15), Lo(20, "img", 16), Ro(21, "span"), ga(22), Mo(), Mo(), Mo(), Ro(23, "div"), ga(24, "Provided by "), Ro(25, "a", 17), ga(26), Mo(), Mo(), Mo(), Mo(), Mo(), Ro(27, "div", 18), ga(28, "Made with \u2764 by EOS Rio"), Mo(), Mo()), 2 & t) { const t = Oo(11); yr(4), Do("formGroup", e.searchForm), yr(4), Do("matAutocomplete", t)("placeholder", e.searchPlaceholder), yr(1), Do("ngIf", e.err), yr(3), Do("ngForOf", e.filteredAccounts), yr(1), So("aria-label", "search"), yr(1), Do("icon", e.faSearch), yr(6), Do("src", e.chainData.chainInfoData.logo, Ji), yr(2), ya(e.chainData.chainInfoData.chain_name), yr(3), Do("href", e.chainData.chainInfoData.provider_url, Ji), yr(1), ya(e.chainData.chainInfoData.provider) } }, directives: [rE, VE, QE, uE, Vv, $_, zv, wx, Fx, F_, nS, U_, Yv, $h, ZC, Hh, rO, mx, CA, ox, Iw], styles: [".search-card[_ngcontent-%COMP%]{height:50%;padding:50px 0 20px}.search-btn[_ngcontent-%COMP%]{height:60px;border-radius:0 5px 5px 0;border-left:0}  .home-search-input.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 0 0 0!important}  .home-search-input.mat-form-field-appearance-outline .mat-form-field-wrapper{margin:0 0 .25em}.outline[_ngcontent-%COMP%]{border:1px solid rgba(0,0,0,.12);padding:4px 7px;border-radius:3px}.faded[_ngcontent-%COMP%]{color:grey}.footer-text[_ngcontent-%COMP%]{text-align:center;padding-bottom:30px}@media screen and (max-width:576px){.logo[_ngcontent-%COMP%]{height:85px;margin-bottom:8px!important}.home-search-input[_ngcontent-%COMP%]{width:100%}.search-card[_ngcontent-%COMP%]{padding-top:10px}}@media (min-width:577px){.logo[_ngcontent-%COMP%]{height:130px}.home-search-input[_ngcontent-%COMP%]{width:330px}}"] }), t })(), TA = (() => { class t extends Sk { constructor(t, e, n, i, r, s, o) { super(t, null, e, n), this.ngClassInstance = o, this.DIRECTIVE_KEY = "ngClass", this.ngClassInstance || (this.ngClassInstance = new Bh(i, r, t, s)), this.init(), this.setValue("", "") } set klass(t) { this.ngClassInstance.klass = t, this.setValue(t, "") } updateWithValue(t) { this.ngClassInstance.ngClass = t, this.ngClassInstance.ngDoCheck() } ngDoCheck() { this.ngClassInstance.ngDoCheck() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao($k), Ao(Yk), Ao(ll), Ao(cl), Ao(Ga), Ao(Bh, 10)) }, t.\u0275dir = we({ type: t, inputs: { klass: ["class", "klass"] }, features: [Ca] }), t })(); const PA = ["ngClass", "ngClass.xs", "ngClass.sm", "ngClass.md", "ngClass.lg", "ngClass.xl", "ngClass.lt-sm", "ngClass.lt-md", "ngClass.lt-lg", "ngClass.lt-xl", "ngClass.gt-xs", "ngClass.gt-sm", "ngClass.gt-md", "ngClass.gt-lg"]; let DA = (() => { class t extends TA { constructor() { super(...arguments), this.inputs = PA } } return t.\u0275fac = function (e) { return IA(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "ngClass", ""], ["", "ngClass.xs", ""], ["", "ngClass.sm", ""], ["", "ngClass.md", ""], ["", "ngClass.lg", ""], ["", "ngClass.xl", ""], ["", "ngClass.lt-sm", ""], ["", "ngClass.lt-md", ""], ["", "ngClass.lt-lg", ""], ["", "ngClass.lt-xl", ""], ["", "ngClass.gt-xs", ""], ["", "ngClass.gt-sm", ""], ["", "ngClass.gt-md", ""], ["", "ngClass.gt-lg", ""]], inputs: { ngClass: "ngClass", "ngClass.xs": "ngClass.xs", "ngClass.sm": "ngClass.sm", "ngClass.md": "ngClass.md", "ngClass.lg": "ngClass.lg", "ngClass.xl": "ngClass.xl", "ngClass.lt-sm": "ngClass.lt-sm", "ngClass.lt-md": "ngClass.lt-md", "ngClass.lt-lg": "ngClass.lt-lg", "ngClass.lt-xl": "ngClass.lt-xl", "ngClass.gt-xs": "ngClass.gt-xs", "ngClass.gt-sm": "ngClass.gt-sm", "ngClass.gt-md": "ngClass.gt-md", "ngClass.gt-lg": "ngClass.gt-lg" }, features: [Ca] }), t })(); const IA = hi(DA); let RA = (() => { class t extends qk { buildStyles(t, e) { return { display: "true" === t ? e.display : "none" } } } return t.\u0275fac = function (e) { return MA(e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const MA = hi(RA); let LA = (() => { class t extends Sk { constructor(t, e, n, i, r, s, o) { super(t, e, n, i), this.layoutConfig = r, this.platformId = s, this.serverModuleLoaded = o, this.DIRECTIVE_KEY = "show-hide", this.display = "", this.hasLayout = !1, this.hasFlexChild = !1 } ngAfterViewInit() { this.trackExtraTriggers(); const t = Array.from(this.nativeElement.children); for (let n = 0; n < t.length; n++)if (this.marshal.hasValue(t[n], "flex")) { this.hasFlexChild = !0; break } FA.has(this.nativeElement) ? this.display = FA.get(this.nativeElement) : (this.display = this.getDisplayStyle(), FA.set(this.nativeElement, this.display)), this.init(); const e = this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY, ""); void 0 === e || "" === e ? this.setValue(!0, "") : this.triggerUpdate() } ngOnChanges(t) { Object.keys(t).forEach(e => { if (-1 !== this.inputs.indexOf(e)) { const n = e.split("."), i = n.slice(1).join("."), r = t[e].currentValue; let s = "" === r || 0 !== r && lb(r); "fxHide" === n[0] && (s = !s), this.setValue(s, i) } }) } trackExtraTriggers() { this.hasLayout = this.marshal.hasValue(this.nativeElement, "layout"), ["layout", "layout-align"].forEach(t => { this.marshal.trackValue(this.nativeElement, t).pipe(jw(this.destroySubject)).subscribe(this.triggerUpdate.bind(this)) }) } getDisplayStyle() { return this.hasLayout || this.hasFlexChild && this.layoutConfig.addFlexToParent ? "flex" : this.styler.lookupStyle(this.nativeElement, "display", !0) } updateWithValue(t = !0) { "" !== t && (this.addStyles(t ? "true" : "false", { display: this.display }), cu(this.platformId) && this.serverModuleLoaded && this.nativeElement.style.setProperty("display", ""), this.marshal.triggerUpdate(this.parentElement, "layout-gap")) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(RA), Ao($k), Ao(Yk), Ao(_k), Ao(vc), Ao(vk)) }, t.\u0275dir = we({ type: t, features: [Ca, Ta] }), t })(); const FA = new WeakMap, NA = ["fxShow", "fxShow.print", "fxShow.xs", "fxShow.sm", "fxShow.md", "fxShow.lg", "fxShow.xl", "fxShow.lt-sm", "fxShow.lt-md", "fxShow.lt-lg", "fxShow.lt-xl", "fxShow.gt-xs", "fxShow.gt-sm", "fxShow.gt-md", "fxShow.gt-lg", "fxHide", "fxHide.print", "fxHide.xs", "fxHide.sm", "fxHide.md", "fxHide.lg", "fxHide.xl", "fxHide.lt-sm", "fxHide.lt-md", "fxHide.lt-lg", "fxHide.lt-xl", "fxHide.gt-xs", "fxHide.gt-sm", "fxHide.gt-md", "fxHide.gt-lg"]; let VA = (() => { class t extends LA { constructor() { super(...arguments), this.inputs = NA } } return t.\u0275fac = function (e) { return jA(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "fxShow", ""], ["", "fxShow.print", ""], ["", "fxShow.xs", ""], ["", "fxShow.sm", ""], ["", "fxShow.md", ""], ["", "fxShow.lg", ""], ["", "fxShow.xl", ""], ["", "fxShow.lt-sm", ""], ["", "fxShow.lt-md", ""], ["", "fxShow.lt-lg", ""], ["", "fxShow.lt-xl", ""], ["", "fxShow.gt-xs", ""], ["", "fxShow.gt-sm", ""], ["", "fxShow.gt-md", ""], ["", "fxShow.gt-lg", ""], ["", "fxHide", ""], ["", "fxHide.print", ""], ["", "fxHide.xs", ""], ["", "fxHide.sm", ""], ["", "fxHide.md", ""], ["", "fxHide.lg", ""], ["", "fxHide.xl", ""], ["", "fxHide.lt-sm", ""], ["", "fxHide.lt-md", ""], ["", "fxHide.lt-lg", ""], ["", "fxHide.lt-xl", ""], ["", "fxHide.gt-xs", ""], ["", "fxHide.gt-sm", ""], ["", "fxHide.gt-md", ""], ["", "fxHide.gt-lg", ""]], inputs: { fxShow: "fxShow", "fxShow.print": "fxShow.print", "fxShow.xs": "fxShow.xs", "fxShow.sm": "fxShow.sm", "fxShow.md": "fxShow.md", "fxShow.lg": "fxShow.lg", "fxShow.xl": "fxShow.xl", "fxShow.lt-sm": "fxShow.lt-sm", "fxShow.lt-md": "fxShow.lt-md", "fxShow.lt-lg": "fxShow.lt-lg", "fxShow.lt-xl": "fxShow.lt-xl", "fxShow.gt-xs": "fxShow.gt-xs", "fxShow.gt-sm": "fxShow.gt-sm", "fxShow.gt-md": "fxShow.gt-md", "fxShow.gt-lg": "fxShow.gt-lg", fxHide: "fxHide", "fxHide.print": "fxHide.print", "fxHide.xs": "fxHide.xs", "fxHide.sm": "fxHide.sm", "fxHide.md": "fxHide.md", "fxHide.lg": "fxHide.lg", "fxHide.xl": "fxHide.xl", "fxHide.lt-sm": "fxHide.lt-sm", "fxHide.lt-md": "fxHide.lt-md", "fxHide.lt-lg": "fxHide.lt-lg", "fxHide.lt-xl": "fxHide.lt-xl", "fxHide.gt-xs": "fxHide.gt-xs", "fxHide.gt-sm": "fxHide.gt-sm", "fxHide.gt-md": "fxHide.gt-md", "fxHide.gt-lg": "fxHide.gt-lg" }, features: [Ca] }), t })(); const jA = hi(VA); class BA { constructor(t, e, n = !0) { this.key = t, this.value = e, this.key = n ? t.replace(/['"]/g, "").trim() : t.trim(), this.value = n ? e.replace(/['"]/g, "").trim() : e.trim(), this.value = this.value.replace(/;/, "") } } function zA(t) { let e = typeof t; return "object" === e ? t.constructor === Array ? "array" : t.constructor === Set ? "set" : "object" : e } function HA(t) { const [e, ...n] = t.split(":"); return new BA(e, n.join(":")) } function UA(t, e) { return e.key && (t[e.key] = e.value), t } let $A = (() => { class t extends Sk { constructor(t, e, n, i, r, s, o, a, l) { super(t, null, e, n), this.sanitizer = i, this.ngStyleInstance = o, this.DIRECTIVE_KEY = "ngStyle", this.ngStyleInstance || (this.ngStyleInstance = new Qh(t, r, s)), this.init(); const c = this.nativeElement.getAttribute("style") || ""; this.fallbackStyles = this.buildStyleMap(c), this.isServer = a && cu(l) } updateWithValue(t) { const e = this.buildStyleMap(t); this.ngStyleInstance.ngStyle = Object.assign(Object.assign({}, this.fallbackStyles), e), this.isServer && this.applyStyleToElement(e), this.ngStyleInstance.ngDoCheck() } clearStyles() { this.ngStyleInstance.ngStyle = this.fallbackStyles, this.ngStyleInstance.ngDoCheck() } buildStyleMap(t) { const e = t => this.sanitizer.sanitize(Xi.STYLE, t) || ""; if (t) switch (zA(t)) { case "string": return YA(function (t, e = ";") { return String(t).trim().split(e).map(t => t.trim()).filter(t => "" !== t) }(t), e); case "array": return YA(t, e); case "set": default: return function (t, e) { let n = []; return "set" === zA(t) ? t.forEach(t => n.push(t)) : Object.keys(t).forEach(e => { n.push(`${e}:${t[e]}`) }), function (t, e) { return t.map(HA).filter(t => !!t).map(t => (e && (t.value = e(t.value)), t)).reduce(UA, {}) }(n, e) }(t, e) }return {} } ngDoCheck() { this.ngStyleInstance.ngDoCheck() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao($k), Ao(Yk), Ao(Nu), Ao(cl), Ao(Ga), Ao(Qh, 10), Ao(vk), Ao(vc)) }, t.\u0275dir = we({ type: t, features: [Ca] }), t })(); const qA = ["ngStyle", "ngStyle.xs", "ngStyle.sm", "ngStyle.md", "ngStyle.lg", "ngStyle.xl", "ngStyle.lt-sm", "ngStyle.lt-md", "ngStyle.lt-lg", "ngStyle.lt-xl", "ngStyle.gt-xs", "ngStyle.gt-sm", "ngStyle.gt-md", "ngStyle.gt-lg"]; let WA = (() => { class t extends $A { constructor() { super(...arguments), this.inputs = qA } } return t.\u0275fac = function (e) { return GA(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "ngStyle", ""], ["", "ngStyle.xs", ""], ["", "ngStyle.sm", ""], ["", "ngStyle.md", ""], ["", "ngStyle.lg", ""], ["", "ngStyle.xl", ""], ["", "ngStyle.lt-sm", ""], ["", "ngStyle.lt-md", ""], ["", "ngStyle.lt-lg", ""], ["", "ngStyle.lt-xl", ""], ["", "ngStyle.gt-xs", ""], ["", "ngStyle.gt-sm", ""], ["", "ngStyle.gt-md", ""], ["", "ngStyle.gt-lg", ""]], inputs: { ngStyle: "ngStyle", "ngStyle.xs": "ngStyle.xs", "ngStyle.sm": "ngStyle.sm", "ngStyle.md": "ngStyle.md", "ngStyle.lg": "ngStyle.lg", "ngStyle.xl": "ngStyle.xl", "ngStyle.lt-sm": "ngStyle.lt-sm", "ngStyle.lt-md": "ngStyle.lt-md", "ngStyle.lt-lg": "ngStyle.lt-lg", "ngStyle.lt-xl": "ngStyle.lt-xl", "ngStyle.gt-xs": "ngStyle.gt-xs", "ngStyle.gt-sm": "ngStyle.gt-sm", "ngStyle.gt-md": "ngStyle.gt-md", "ngStyle.gt-lg": "ngStyle.gt-lg" }, features: [Ca] }), t })(); const GA = hi(WA); function YA(t, e) { return t.map(HA).filter(t => !!t).map(t => (e && (t.value = e(t.value)), t)).reduce(UA, {}) } let XA = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[fk]] }), t })(); function KA(t, e) { if (1 & t && (Ro(0, "mat-error"), ga(1), Mo()), 2 & t) { const t = Go(); yr(1), ya(t.err) } } function QA(t, e) { if (1 & t && (Ro(0, "mat-option", 22), ga(1), Mo()), 2 & t) { const t = e.$implicit; Do("value", t), yr(1), ya(t) } } let ZA = (() => { class t { constructor(t, e, n, i, r) { this.formBuilder = t, this.router = e, this.accountService = n, this.searchService = i, this.chainData = r, this.faSearch = oS.faSearch, this.placeholders = ["Search by account name...", "Search by block number...", "Search by transaction id...", "Search by public key..."], this.err = "", this.currentPlaceholder = 0, this.searchForm = this.formBuilder.group({ search_field: [""] }), this.filteredAccounts = [], this.searchPlaceholder = this.placeholders[0], setInterval(() => { this.currentPlaceholder++, this.placeholders[this.currentPlaceholder] || (this.currentPlaceholder = 0), this.searchPlaceholder = this.placeholders[this.currentPlaceholder] }, 3e3) } ngOnInit() { this.searchForm.get("search_field").valueChanges.pipe(rb(300)).subscribe(t => sS(this, void 0, void 0, (function* () { this.filteredAccounts = yield this.searchService.filterAccountNames(t) }))) } submit() { return sS(this, void 0, void 0, (function* () { if (!this.searchForm.valid) return !0; const t = this.searchForm.get("search_field").value; this.searchService.submitSearch(t, this.filteredAccounts) || (this.err = "no results for " + t) })) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Kv), Ao(Oy), Ao(ck), Ao(hk), Ao(uk)) }, t.\u0275cmp = me({ type: t, selectors: [["app-search-results"]], decls: 32, vars: 13, consts: [["fxLayout", "column", "fxLayoutAlign", "space-between center", "fxLayoutGap", "10px", 2, "height", "100vh"], [1, "search-card"], ["fxLayout", "row", "fxLayoutAlign", "space-between center", 1, "container", 2, "padding", "0", "width", "100%"], ["src", "assets/logo.png", "alt", "logo", "routerLink", "/", 1, "logo", 2, "height", "80px", 3, "fxHide.lt-sm"], ["src", "assets/logo_symbol.png", "alt", "logo", "routerLink", "/", 1, "logo", 2, "height", "80px", 3, "fxHide.gt-xs"], [1, "search-container"], ["fxLayout", "row", "fxLayoutAlign", "end center", "fxLayoutGap", "6px", 1, "chain"], ["fxLayout", "row", "fxLayoutAlign", "center center", "fxLayoutGap", "5px", 1, "outline"], ["alt", "logo", 2, "height", "23px", 3, "src"], [3, "formGroup", "ngSubmit"], ["fxLayout", "row", "fxLayoutAlign", "center start"], ["appearance", "outline", 1, "search-input"], ["matInput", "", "formControlName", "search_field", 3, "matAutocomplete", "placeholder"], [4, "ngIf"], [3, "optionSelected"], ["auto", "matAutocomplete"], [3, "value", 4, "ngFor", "ngForOf"], ["mat-stroked-button", "", "matSuffix", "", "type", "submit", 1, "search-btn", 3, "keyup.enter"], [3, "icon"], [1, "faded", "footer-text"], [2, "margin-bottom", "7px"], ["target", "_blank", 3, "href"], [3, "value"]], template: function (t, e) { if (1 & t && (Ro(0, "div", 0), Ro(1, "mat-card", 1), Ro(2, "div", 2), Lo(3, "img", 3), Lo(4, "img", 4), Ro(5, "div", 5), Ro(6, "div", 6), Ro(7, "span"), ga(8, "Connected to"), Mo(), Ro(9, "span", 7), Lo(10, "img", 8), Ro(11, "span"), ga(12), Mo(), Mo(), Mo(), Ro(13, "form", 9), Ho("ngSubmit", (function () { return e.submit() })), Ro(14, "div", 10), Ro(15, "mat-form-field", 11), Ro(16, "label"), Lo(17, "input", 12), Mo(), Eo(18, KA, 2, 1, "mat-error", 13), Mo(), Ro(19, "mat-autocomplete", 14, 15), Ho("optionSelected", (function () { return e.submit() })), Eo(21, QA, 2, 2, "mat-option", 16), Mo(), Ro(22, "button", 17), Ho("keyup.enter", (function () { return e.submit() })), Lo(23, "fa-icon", 18), Mo(), Mo(), Mo(), Mo(), Mo(), Mo(), Lo(24, "router-outlet"), Ro(25, "div", 19), Ro(26, "div", 20), ga(27, "Data provider "), Ro(28, "a", 21), ga(29), Mo(), Mo(), Ro(30, "div"), ga(31, "Made with \u2764 by EOS Rio"), Mo(), Mo(), Mo()), 2 & t) { const t = Oo(20); yr(3), Do("fxHide.lt-sm", !0), yr(1), Do("fxHide.gt-xs", !0), yr(6), Do("src", e.chainData.chainInfoData.logo, Ji), yr(2), ya(e.chainData.chainInfoData.chain_name), yr(1), Do("formGroup", e.searchForm), yr(4), Do("matAutocomplete", t)("placeholder", e.searchPlaceholder), yr(1), Do("ngIf", e.err), yr(3), Do("ngForOf", e.filteredAccounts), yr(1), So("aria-label", "search"), yr(1), Do("icon", e.faSearch), yr(5), Do("href", e.chainData.chainInfoData.provider_url, Ji), yr(1), ya(e.chainData.chainInfoData.provider) } }, directives: [rE, VE, uE, QE, Ay, VA, Vv, $_, zv, wx, Fx, F_, nS, U_, Yv, $h, ZC, Hh, rO, mx, CA, Ry, ox, Iw], styles: [".search-card[_ngcontent-%COMP%]{position:fixed;z-index:102;margin:0;width:100%}.search-btn[_ngcontent-%COMP%]{height:50px;border-radius:0 5px 5px 0;border-left:0}  .search-input.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 0 0 0!important}  .search-input.mat-form-field-appearance-outline .mat-form-field-wrapper{margin:0;padding-bottom:0}  .search-input.mat-form-field-appearance-outline .mat-form-field-infix{padding:.7em 0}.logo[_ngcontent-%COMP%]{cursor:pointer;outline:none}.chain[_ngcontent-%COMP%]{font-size:15px;margin-bottom:5px}.faded[_ngcontent-%COMP%]{color:grey}.footer-text[_ngcontent-%COMP%]{text-align:center;padding-bottom:30px}@media screen and (max-width:599px){.search-container[_ngcontent-%COMP%]{padding-right:10px}}@media (min-width:600px){.search-input[_ngcontent-%COMP%]{width:330px}}@media screen and (max-width:1049px){.search-container[_ngcontent-%COMP%]{padding-right:10px}.logo[_ngcontent-%COMP%]{margin-left:10px}}"] }), t })(); const JA = ["mat-sort-header", ""]; function tT(t, e) { if (1 & t) { const t = jo(); Ro(0, "div", 3), Ho("@arrowPosition.start", (function () { return Ze(t), Go()._disableViewStateAnimation = !0 }))("@arrowPosition.done", (function () { return Ze(t), Go()._disableViewStateAnimation = !1 })), Lo(1, "div", 4), Ro(2, "div", 5), Lo(3, "div", 6), Lo(4, "div", 7), Lo(5, "div", 8), Mo(), Mo() } if (2 & t) { const t = Go(); Do("@arrowOpacity", t._getArrowViewState())("@arrowPosition", t._getArrowViewState())("@allowChildren", t._getArrowDirectionState()), yr(2), Do("@indicator", t._getArrowDirectionState()), yr(1), Do("@leftPointer", t._getArrowDirectionState()), yr(1), Do("@rightPointer", t._getArrowDirectionState()) } } const eT = ["*"]; class nT { } const iT = uw(ow(nT)); let rT = (() => { class t extends iT { constructor() { super(...arguments), this.sortables = new Map, this._stateChanges = new k, this.start = "asc", this._direction = "", this.sortChange = new ql } get direction() { return this._direction } set direction(t) { if (Ei() && t && "asc" !== t && "desc" !== t) throw function (t) { return Error(`${t} is not a valid sort direction ('asc' or 'desc').`) }(t); this._direction = t } get disableClear() { return this._disableClear } set disableClear(t) { this._disableClear = lb(t) } register(t) { if (!t.id) throw Error("MatSortHeader must be provided with a unique id."); if (this.sortables.has(t.id)) throw Error(`Cannot have two MatSortables with the same id (${t.id}).`); this.sortables.set(t.id, t) } deregister(t) { this.sortables.delete(t.id) } sort(t) { this.active != t.id ? (this.active = t.id, this.direction = t.start ? t.start : this.start) : this.direction = this.getNextSortDirection(t), this.sortChange.emit({ active: this.active, direction: this.direction }) } getNextSortDirection(t) { if (!t) return ""; let e = function (t, e) { let n = ["asc", "desc"]; return "desc" == t && n.reverse(), e || n.push(""), n }(t.start || this.start, null != t.disableClear ? t.disableClear : this.disableClear), n = e.indexOf(this.direction) + 1; return n >= e.length && (n = 0), e[n] } ngOnInit() { this._markInitialized() } ngOnChanges() { this._stateChanges.next() } ngOnDestroy() { this._stateChanges.complete() } } return t.\u0275fac = function (e) { return sT(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matSort", ""]], hostAttrs: [1, "mat-sort"], inputs: { disabled: ["matSortDisabled", "disabled"], start: ["matSortStart", "start"], direction: ["matSortDirection", "direction"], disableClear: ["matSortDisableClear", "disableClear"], active: ["matSortActive", "active"] }, outputs: { sortChange: "matSortChange" }, exportAs: ["matSort"], features: [Ca, Ta] }), t })(); const sT = hi(rT), oT = ew.ENTERING + " " + tw.STANDARD_CURVE, aT = { indicator: qu("indicator", [Ku("active-asc, asc", Xu({ transform: "translateY(0px)" })), Ku("active-desc, desc", Xu({ transform: "translateY(10px)" })), Zu("active-asc <=> active-desc", Wu(oT))]), leftPointer: qu("leftPointer", [Ku("active-asc, asc", Xu({ transform: "rotate(-45deg)" })), Ku("active-desc, desc", Xu({ transform: "rotate(45deg)" })), Zu("active-asc <=> active-desc", Wu(oT))]), rightPointer: qu("rightPointer", [Ku("active-asc, asc", Xu({ transform: "rotate(45deg)" })), Ku("active-desc, desc", Xu({ transform: "rotate(-45deg)" })), Zu("active-asc <=> active-desc", Wu(oT))]), arrowOpacity: qu("arrowOpacity", [Ku("desc-to-active, asc-to-active, active", Xu({ opacity: 1 })), Ku("desc-to-hint, asc-to-hint, hint", Xu({ opacity: .54 })), Ku("hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void", Xu({ opacity: 0 })), Zu("* => asc, * => desc, * => active, * => hint, * => void", Wu("0ms")), Zu("* <=> *", Wu(oT))]), arrowPosition: qu("arrowPosition", [Zu("* => desc-to-hint, * => desc-to-active", Wu(oT, Qu([Xu({ transform: "translateY(-25%)" }), Xu({ transform: "translateY(0)" })]))), Zu("* => hint-to-desc, * => active-to-desc", Wu(oT, Qu([Xu({ transform: "translateY(0)" }), Xu({ transform: "translateY(25%)" })]))), Zu("* => asc-to-hint, * => asc-to-active", Wu(oT, Qu([Xu({ transform: "translateY(25%)" }), Xu({ transform: "translateY(0)" })]))), Zu("* => hint-to-asc, * => active-to-asc", Wu(oT, Qu([Xu({ transform: "translateY(0)" }), Xu({ transform: "translateY(-25%)" })]))), Ku("desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active", Xu({ transform: "translateY(0)" })), Ku("hint-to-desc, active-to-desc, desc", Xu({ transform: "translateY(-25%)" })), Ku("hint-to-asc, active-to-asc, asc", Xu({ transform: "translateY(25%)" }))]), allowChildren: qu("allowChildren", [Zu("* <=> *", [td("@*", Ju(), { optional: !0 })])]) }; let lT = (() => { class t { constructor() { this.changes = new k, this.sortButtonLabel = t => `Change sorting for ${t}` } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const cT = { provide: lT, deps: [[new ot, new lt, lT]], useFactory: function (t) { return t || new lT } }; class hT { } const uT = ow(hT); let dT = (() => { class t extends uT { constructor(t, e, n, i, r, s) { if (super(), this._intl = t, this._sort = n, this._columnDef = i, this._focusMonitor = r, this._elementRef = s, this._showIndicatorHint = !1, this._arrowDirection = "", this._disableViewStateAnimation = !1, this.arrowPosition = "after", !n) throw Error("MatSortHeader must be placed within a parent element with the MatSort directive."); this._rerenderSubscription = G(n.sortChange, n._stateChanges, t.changes).subscribe(() => { this._isSorted() && this._updateArrowDirection(), !this._isSorted() && this._viewState && "active" === this._viewState.toState && (this._disableViewStateAnimation = !1, this._setAnimationTransitionState({ fromState: "active", toState: this._arrowDirection })), e.markForCheck() }), r && s && r.monitor(s, !0).subscribe(t => this._setIndicatorHintVisible(!!t)) } get disableClear() { return this._disableClear } set disableClear(t) { this._disableClear = lb(t) } ngOnInit() { !this.id && this._columnDef && (this.id = this._columnDef.name), this._updateArrowDirection(), this._setAnimationTransitionState({ toState: this._isSorted() ? "active" : this._arrowDirection }), this._sort.register(this) } ngOnDestroy() { this._focusMonitor && this._elementRef && this._focusMonitor.stopMonitoring(this._elementRef), this._sort.deregister(this), this._rerenderSubscription.unsubscribe() } _setIndicatorHintVisible(t) { this._isDisabled() && t || (this._showIndicatorHint = t, this._isSorted() || (this._updateArrowDirection(), this._setAnimationTransitionState(this._showIndicatorHint ? { fromState: this._arrowDirection, toState: "hint" } : { fromState: "hint", toState: this._arrowDirection }))) } _setAnimationTransitionState(t) { this._viewState = t, this._disableViewStateAnimation && (this._viewState = { toState: t.toState }) } _handleClick() { if (this._isDisabled()) return; this._sort.sort(this), "hint" !== this._viewState.toState && "active" !== this._viewState.toState || (this._disableViewStateAnimation = !0); const t = this._isSorted() ? { fromState: this._arrowDirection, toState: "active" } : { fromState: "active", toState: this._arrowDirection }; this._setAnimationTransitionState(t), this._showIndicatorHint = !1 } _isSorted() { return this._sort.active == this.id && ("asc" === this._sort.direction || "desc" === this._sort.direction) } _getArrowDirectionState() { return `${this._isSorted() ? "active-" : ""}${this._arrowDirection}` } _getArrowViewState() { const t = this._viewState.fromState; return (t ? `${t}-to-` : "") + this._viewState.toState } _updateArrowDirection() { this._arrowDirection = this._isSorted() ? this._sort.direction : this.start || this._sort.start } _isDisabled() { return this._sort.disabled || this.disabled } _getAriaSortAttribute() { return this._isSorted() ? "asc" == this._sort.direction ? "ascending" : "descending" : null } _renderArrow() { return !this._isDisabled() || this._isSorted() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(lT), Ao(Ws), Ao(rT, 8), Ao("MAT_SORT_HEADER_COLUMN_DEF", 8), Ao(Hb), Ao(Ua)) }, t.\u0275cmp = me({ type: t, selectors: [["", "mat-sort-header", ""]], hostAttrs: [1, "mat-sort-header"], hostVars: 3, hostBindings: function (t, e) { 1 & t && Ho("click", (function () { return e._handleClick() }))("mouseenter", (function () { return e._setIndicatorHintVisible(!0) }))("mouseleave", (function () { return e._setIndicatorHintVisible(!1) })), 2 & t && (So("aria-sort", e._getAriaSortAttribute()), sa("mat-sort-header-disabled", e._isDisabled())) }, inputs: { disabled: "disabled", arrowPosition: "arrowPosition", disableClear: "disableClear", id: ["mat-sort-header", "id"], start: "start" }, exportAs: ["matSortHeader"], features: [Ca], attrs: JA, ngContentSelectors: eT, decls: 4, vars: 7, consts: [[1, "mat-sort-header-container"], ["type", "button", 1, "mat-sort-header-button", "mat-focus-indicator"], ["class", "mat-sort-header-arrow", 4, "ngIf"], [1, "mat-sort-header-arrow"], [1, "mat-sort-header-stem"], [1, "mat-sort-header-indicator"], [1, "mat-sort-header-pointer-left"], [1, "mat-sort-header-pointer-right"], [1, "mat-sort-header-pointer-middle"]], template: function (t, e) { 1 & t && (Xo(), Ro(0, "div", 0), Ro(1, "button", 1), Ko(2), Mo(), Eo(3, tT, 6, 6, "div", 2), Mo()), 2 & t && (sa("mat-sort-header-sorted", e._isSorted())("mat-sort-header-position-before", "before" == e.arrowPosition), yr(1), So("disabled", e._isDisabled() || null)("aria-label", e._intl.sortButtonLabel(e.id)), yr(2), Do("ngIf", e._renderArrow())) }, directives: [$h], styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:inherit;outline:0;font:inherit;color:currentColor;position:relative}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-button,[mat-sort-header].cdk-program-focused .mat-sort-header-button{border-bottom:solid 1px currentColor}.mat-sort-header-button::-moz-focus-inner{border:0}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n"], encapsulation: 2, data: { animation: [aT.indicator, aT.leftPointer, aT.rightPointer, aT.arrowOpacity, aT.arrowPosition, aT.allowChildren] }, changeDetection: 0 }), t })(), pT = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [cT], imports: [[au]] }), t })(); var fT = n("Xa4a"), mT = n("F/Mi"), gT = n("TFQ+"), yT = n("bAYg"), _T = n("xf7l"), vT = n("mT4a"); class bT extends class { constructor() { this.expansionModel = new Gx(!0) } toggle(t) { this.expansionModel.toggle(t) } expand(t) { this.expansionModel.select(t) } collapse(t) { this.expansionModel.deselect(t) } isExpanded(t) { return this.expansionModel.isSelected(t) } toggleDescendants(t) { this.expansionModel.isSelected(t) ? this.collapseDescendants(t) : this.expandDescendants(t) } collapseAll() { this.expansionModel.clear() } expandDescendants(t) { let e = [t]; e.push(...this.getDescendants(t)), this.expansionModel.select(...e) } collapseDescendants(t) { let e = [t]; e.push(...this.getDescendants(t)), this.expansionModel.deselect(...e) } }{ constructor(t, e) { super(), this.getLevel = t, this.isExpandable = e } getDescendants(t) { const e = []; for (let n = this.dataNodes.indexOf(t) + 1; n < this.dataNodes.length && this.getLevel(t) < this.getLevel(this.dataNodes[n]); n++)e.push(this.dataNodes[n]); return e } expandAll() { this.expansionModel.select(...this.dataNodes) } } const wT = new Bt("CDK_TREE_NODE_OUTLET_NODE"); let xT = (() => { class t { constructor(t, e) { this.viewContainer = t, this._node = e } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(wT, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkTreeNodeOutlet", ""]] }), t })(); class CT { constructor(t) { this.$implicit = t } } let ST = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkTreeNodeDef", ""]], inputs: { when: ["cdkTreeNodeDefWhen", "when"] } }), t })(), kT = (() => { class t { constructor(t, e) { this._differs = t, this._changeDetectorRef = e, this._onDestroy = new k, this._levels = new Map, this.viewChange = new yf({ start: 0, end: Number.MAX_VALUE }) } get dataSource() { return this._dataSource } set dataSource(t) { this._dataSource !== t && this._switchDataSource(t) } ngOnInit() { if (this._dataDiffer = this._differs.find([]).create(this.trackBy), !this.treeControl) throw Error("Could not find a tree control for the tree.") } ngOnDestroy() { this._nodeOutlet.viewContainer.clear(), this.viewChange.complete(), this._onDestroy.next(), this._onDestroy.complete(), this._dataSource && "function" == typeof this._dataSource.disconnect && this.dataSource.disconnect(this), this._dataSubscription && (this._dataSubscription.unsubscribe(), this._dataSubscription = null) } ngAfterContentChecked() { const t = this._nodeDefs.filter(t => !t.when); if (t.length > 1) throw Error("There can only be one default row without a when predicate function."); this._defaultNodeDef = t[0], this.dataSource && this._nodeDefs && !this._dataSubscription && this._observeRenderChanges() } _switchDataSource(t) { this._dataSource && "function" == typeof this._dataSource.disconnect && this.dataSource.disconnect(this), this._dataSubscription && (this._dataSubscription.unsubscribe(), this._dataSubscription = null), t || this._nodeOutlet.viewContainer.clear(), this._dataSource = t, this._nodeDefs && this._observeRenderChanges() } _observeRenderChanges() { let t; if (Wx(this._dataSource) ? t = this._dataSource.connect(this) : Vx(this._dataSource) ? t = this._dataSource : Array.isArray(this._dataSource) && (t = gf(this._dataSource)), !t) throw Error("A valid data source must be provided."); this._dataSubscription = t.pipe(jw(this._onDestroy)).subscribe(t => this.renderNodeChanges(t)) } renderNodeChanges(t, e = this._dataDiffer, n = this._nodeOutlet.viewContainer, i) { const r = e.diff(t); r && (r.forEachOperation((e, r, s) => { if (null == e.previousIndex) this.insertNode(t[s], s, n, i); else if (null == s) n.remove(r), this._levels.delete(e.item); else { const t = n.get(r); n.move(t, s) } }), this._changeDetectorRef.detectChanges()) } _getNodeDef(t, e) { if (1 === this._nodeDefs.length) return this._nodeDefs.first; const n = this._nodeDefs.find(n => n.when && n.when(e, t)) || this._defaultNodeDef; if (!n) throw Error("Could not find a matching node definition for the provided node data."); return n } insertNode(t, e, n, i) { const r = this._getNodeDef(t, e), s = new CT(t); s.level = this.treeControl.getLevel ? this.treeControl.getLevel(t) : void 0 !== i && this._levels.has(i) ? this._levels.get(i) + 1 : 0, this._levels.set(t, s.level), (n || this._nodeOutlet.viewContainer).createEmbeddedView(r.template, s, e), ET.mostRecentTreeNode && (ET.mostRecentTreeNode.data = t) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ll), Ao(Ws)) }, t.\u0275cmp = me({ type: t, selectors: [["cdk-tree"]], contentQueries: function (t, e, n) { var i; 1 & t && oc(n, ST, !0), 2 & t && nc(i = cc()) && (e._nodeDefs = i) }, viewQuery: function (t, e) { var n; 1 & t && ic(xT, !0), 2 & t && nc(n = cc()) && (e._nodeOutlet = n.first) }, hostAttrs: ["role", "tree", 1, "cdk-tree"], inputs: { dataSource: "dataSource", treeControl: "treeControl", trackBy: "trackBy" }, exportAs: ["cdkTree"], decls: 1, vars: 0, consts: [["cdkTreeNodeOutlet", ""]], template: function (t, e) { 1 & t && Vo(0, 0) }, directives: [xT], encapsulation: 2 }), t })(), ET = (() => { class t { constructor(e, n) { this._elementRef = e, this._tree = n, this._destroyed = new k, this._dataChanges = new k, this.role = "treeitem", t.mostRecentTreeNode = this } get data() { return this._data } set data(t) { t !== this._data && (this._data = t, this._setRoleFromData(), this._dataChanges.next()) } get isExpanded() { return this._tree.treeControl.isExpanded(this._data) } get level() { return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0 } ngOnDestroy() { t.mostRecentTreeNode === this && (t.mostRecentTreeNode = null), this._dataChanges.complete(), this._destroyed.next(), this._destroyed.complete() } focus() { this._elementRef.nativeElement.focus() } _setRoleFromData() { if (this._tree.treeControl.isExpandable) this.role = this._tree.treeControl.isExpandable(this._data) ? "group" : "treeitem"; else { if (!this._tree.treeControl.getChildren) throw Error("Could not find functions for nested/flat tree in tree control."); const t = this._tree.treeControl.getChildren(this._data); Array.isArray(t) ? this._setRoleFromChildren(t) : Vx(t) && t.pipe(jw(this._destroyed)).subscribe(t => this._setRoleFromChildren(t)) } } _setRoleFromChildren(t) { this.role = t && t.length ? "group" : "treeitem" } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(kT)) }, t.\u0275dir = we({ type: t, selectors: [["cdk-tree-node"]], hostAttrs: [1, "cdk-tree-node"], hostVars: 3, hostBindings: function (t, e) { 2 & t && So("aria-expanded", e.isExpanded)("aria-level", "treeitem" === e.role ? e.level : null)("role", e.role) }, inputs: { role: "role" }, exportAs: ["cdkTreeNode"] }), t.mostRecentTreeNode = null, t })(); const OT = /([A-Za-z%]+)$/; let AT = (() => { class t { constructor(t, e, n, i, r) { this._treeNode = t, this._tree = e, this._element = i, this._dir = r, this._destroyed = new k, this.indentUnits = "px", this._indent = 40, this._setPadding(), r && r.change.pipe(jw(this._destroyed)).subscribe(() => this._setPadding(!0)), t._dataChanges.subscribe(() => this._setPadding()) } get level() { return this._level } set level(t) { this._level = cb(t, null), this._setPadding() } get indent() { return this._indent } set indent(t) { let e = t, n = "px"; if ("string" == typeof t) { const i = t.split(OT); e = i[0], n = i[1] || n } this.indentUnits = n, this._indent = cb(e), this._setPadding() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _paddingIndent() { const t = this._treeNode.data && this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._treeNode.data) : null, e = null == this._level ? t : this._level; return "number" == typeof e ? `${e * this._indent}${this.indentUnits}` : null } _setPadding(t = !1) { const e = this._paddingIndent(); if (e !== this._currentPadding || t) { const t = this._element.nativeElement, n = this._dir && "rtl" === this._dir.value ? "paddingRight" : "paddingLeft", i = "paddingLeft" === n ? "paddingRight" : "paddingLeft"; t.style[n] = e || "", t.style[i] = "", this._currentPadding = e } } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ET), Ao(kT), Ao(Ga), Ao(Ua), Ao(Gb, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkTreeNodePadding", ""]], inputs: { level: ["cdkTreeNodePadding", "level"], indent: ["cdkTreeNodePaddingIndent", "indent"] } }), t })(), TT = (() => { class t { constructor(t, e) { this._tree = t, this._treeNode = e, this._recursive = !1 } get recursive() { return this._recursive } set recursive(t) { this._recursive = lb(t) } _toggle(t) { this.recursive ? this._tree.treeControl.toggleDescendants(this._treeNode.data) : this._tree.treeControl.toggle(this._treeNode.data), t.stopPropagation() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(kT), Ao(ET)) }, t.\u0275dir = we({ type: t, selectors: [["", "cdkTreeNodeToggle", ""]], hostBindings: function (t, e) { 1 & t && Ho("click", (function (t) { return e._toggle(t) })) }, inputs: { recursive: ["cdkTreeNodeToggleRecursive", "recursive"] } }), t })(), PT = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [Hb, ST] }), t })(); const DT = cw(ow(ET)); let IT = (() => { class t extends DT { constructor(t, e, n) { super(t, e), this._elementRef = t, this._tree = e, this.role = "treeitem", this.tabIndex = Number(n) || 0 } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(kT), To("tabindex")) }, t.\u0275dir = we({ type: t, selectors: [["mat-tree-node"]], hostAttrs: [1, "mat-tree-node"], hostVars: 3, hostBindings: function (t, e) { 2 & t && So("aria-expanded", e.isExpanded)("aria-level", "treeitem" === e.role ? e.level : null)("role", e.role) }, inputs: { disabled: "disabled", tabIndex: "tabIndex", role: "role" }, exportAs: ["matTreeNode"], features: [ja([{ provide: ET, useExisting: t }]), Ca] }), t })(), RT = (() => { class t extends ST { } return t.\u0275fac = function (e) { return MT(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matTreeNodeDef", ""]], inputs: { when: ["matTreeNodeDefWhen", "when"], data: ["matTreeNode", "data"] }, features: [ja([{ provide: ST, useExisting: t }]), Ca] }), t })(); const MT = hi(RT); let LT = (() => { class t extends AT { } return t.\u0275fac = function (e) { return FT(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matTreeNodePadding", ""]], inputs: { level: ["matTreeNodePadding", "level"], indent: ["matTreeNodePaddingIndent", "indent"] }, features: [ja([{ provide: AT, useExisting: t }]), Ca] }), t })(); const FT = hi(LT); let NT = (() => { class t { constructor(t, e) { this.viewContainer = t, this._node = e } } return t.\u0275fac = function (e) { return new (e || t)(Ao(ml), Ao(wT, 8)) }, t.\u0275dir = we({ type: t, selectors: [["", "matTreeNodeOutlet", ""]], features: [ja([{ provide: xT, useExisting: t }])] }), t })(), VT = (() => { class t extends kT { } return t.\u0275fac = function (e) { return jT(e || t) }, t.\u0275cmp = me({ type: t, selectors: [["mat-tree"]], viewQuery: function (t, e) { var n; 1 & t && ic(NT, !0), 2 & t && nc(n = cc()) && (e._nodeOutlet = n.first) }, hostAttrs: ["role", "tree", 1, "mat-tree"], exportAs: ["matTree"], features: [ja([{ provide: kT, useExisting: t }]), Ca], decls: 1, vars: 0, consts: [["matTreeNodeOutlet", ""]], template: function (t, e) { 1 & t && Vo(0, 0) }, directives: [NT], styles: [".mat-tree{display:block}.mat-tree-node{display:flex;align-items:center;min-height:48px;flex:1;word-wrap:break-word}.mat-nested-tree-node{border-bottom-width:0}\n"], encapsulation: 2 }), t })(); const jT = hi(VT); let BT = (() => { class t extends TT { constructor() { super(...arguments), this.recursive = !1 } } return t.\u0275fac = function (e) { return zT(e || t) }, t.\u0275dir = we({ type: t, selectors: [["", "matTreeNodeToggle", ""]], inputs: { recursive: ["matTreeNodeToggleRecursive", "recursive"] }, features: [ja([{ provide: TT, useExisting: t }]), Ca] }), t })(); const zT = hi(BT); let HT = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[PT, sw], sw] }), t })(); class UT { constructor(t, e, n, i) { this.transformFunction = t, this.getLevel = e, this.isExpandable = n, this.getChildren = i } _flattenNode(t, e, n, i) { const r = this.transformFunction(t, e); if (n.push(r), this.isExpandable(r)) { const r = this.getChildren(t); r && (Array.isArray(r) ? this._flattenChildren(r, e, n, i) : r.pipe(qf(1)).subscribe(t => { this._flattenChildren(t, e, n, i) })) } return n } _flattenChildren(t, e, n, i) { t.forEach((r, s) => { let o = i.slice(); o.push(s != t.length - 1), this._flattenNode(r, e + 1, n, o) }) } flattenNodes(t) { let e = []; return t.forEach(t => this._flattenNode(t, 0, e, [])), e } expandFlattenedNodes(t, e) { let n = [], i = []; return i[0] = !0, t.forEach(t => { let r = !0; for (let e = 0; e <= this.getLevel(t); e++)r = r && i[e]; r && n.push(t), this.isExpandable(t) && (i[this.getLevel(t) + 1] = e.isExpanded(t)) }), n } } class $T extends qx { constructor(t, e, n = []) { super(), this._treeControl = t, this._treeFlattener = e, this._flattenedData = new yf([]), this._expandedData = new yf([]), this._data = new yf(n) } get data() { return this._data.value } set data(t) { this._data.next(t), this._flattenedData.next(this._treeFlattener.flattenNodes(this.data)), this._treeControl.dataNodes = this._flattenedData.value } connect(t) { return G(t.viewChange, this._treeControl.expansionModel.changed, this._flattenedData).pipe(N(() => (this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this._treeControl)), this._expandedData.value))) } disconnect() { } } var qT = n("muhD"), WT = n("hmj/"), GT = n("4MzN"), YT = n("fxjp"), XT = n("hRW6"); const KT = ["trigger"], QT = ["panel"]; function ZT(t, e) { if (1 & t && (Ro(0, "span", 8), ga(1), Mo()), 2 & t) { const t = Go(); yr(1), ya(t.placeholder || "\xa0") } } function JT(t, e) { if (1 & t && (Ro(0, "span"), ga(1), Mo()), 2 & t) { const t = Go(2); yr(1), ya(t.triggerValue || "\xa0") } } function tP(t, e) { 1 & t && Ko(0, 0, ["*ngSwitchCase", "true"]) } function eP(t, e) { 1 & t && (Ro(0, "span", 9), Eo(1, JT, 2, 1, "span", 10), Eo(2, tP, 1, 0, void 0, 11), Mo()), 2 & t && (Do("ngSwitch", !!Go().customTrigger), yr(2), Do("ngSwitchCase", !0)) } function nP(t, e) { if (1 & t) { const t = jo(); Ro(0, "div", 12), Ro(1, "div", 13, 14), Ho("@transformPanel.done", (function (e) { return Ze(t), Go()._panelDoneAnimatingStream.next(e.toState) }))("keydown", (function (e) { return Ze(t), Go()._handleKeydown(e) })), Ko(3, 1), Mo(), Mo() } if (2 & t) { const t = Go(); Do("@transformPanelWrap", void 0), yr(1), n = "mat-select-panel ", i = t._getPanelTheme(), r = "", function (t, e, n, i) { const r = Qe(), s = cn(2); r.firstUpdatePass && ca(r, null, s, !0); const o = Ke(); if (n !== mr && xo(o, s, n)) { const i = r.data[xn() + 19]; if (ma(i, !0) && !la(r, s)) { let t = i.classes; null !== t && (n = Ct(t, n || "")), Io(r, i, o, n, !0) } else !function (t, e, n, i, r, s, o, a) { r === mr && (r = Qo); let l = 0, c = 0, h = 0 < r.length ? r[0] : null, u = 0 < s.length ? s[0] : null; for (; null !== h || null !== u;) { const o = l < r.length ? r[l + 1] : void 0, d = c < s.length ? s[c + 1] : void 0; let p = null, f = void 0; h === u ? (l += 2, c += 2, o !== d && (p = u, f = d)) : null === u || null !== h && h < u ? (l += 2, p = h) : (c += 2, p = u, f = d), null !== p && da(t, e, n, i, p, f, !0, a), h = l < r.length ? r[l] : null, u = c < s.length ? s[c] : null } }(r, i, o, o[11], o[s + 1], o[s + 1] = function (t, e, n) { if (null == n || "" === n) return Qo; const i = [], r = wi(n); if (Array.isArray(r)) for (let s = 0; s < r.length; s++)t(i, r[s], !0); else if ("object" == typeof r) for (const s in r) r.hasOwnProperty(s) && t(i, s, r[s]); else "string" == typeof r && e(i, r); return i }(t, e, n), 0, s) } }(ae, oa, ko(Ke(), n, i, r)), ra("transform-origin", t._transformOrigin)("font-size", t._triggerFontSize, "px"), Do("ngClass", t.panelClass)("@transformPanel", t.multiple ? "showing-multiple" : "showing"), So("id", t.id + "-panel") } var n, i, r } const iP = [[["mat-select-trigger"]], "*"], rP = ["mat-select-trigger", "*"], sP = { transformPanelWrap: qu("transformPanelWrap", [Zu("* => void", td("@transformPanel", [Ju()], { optional: !0 }))]), transformPanel: qu("transformPanel", [Ku("void", Xu({ transform: "scaleY(0.8)", minWidth: "100%", opacity: 0 })), Ku("showing", Xu({ opacity: 1, minWidth: "calc(100% + 32px)", transform: "scaleY(1)" })), Ku("showing-multiple", Xu({ opacity: 1, minWidth: "calc(100% + 64px)", transform: "scaleY(1)" })), Zu("void => *", Wu("120ms cubic-bezier(0, 0, 0.2, 1)")), Zu("* => void", Wu("100ms 25ms linear", Xu({ opacity: 0 })))]) }; let oP = 0; const aP = new Bt("mat-select-scroll-strategy"), lP = new Bt("MAT_SELECT_CONFIG"), cP = { provide: aP, deps: [RC], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; class hP { constructor(t, e) { this.source = t, this.value = e } } class uP { constructor(t, e, n, i, r) { this._elementRef = t, this._defaultErrorStateMatcher = e, this._parentForm = n, this._parentFormGroup = i, this.ngControl = r } } const dP = lw(cw(ow(hw(uP)))); let pP = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-select-trigger"]] }), t })(), fP = (() => { class t extends dP { constructor(t, e, n, i, r, s, o, a, l, c, h, u, d, p) { super(r, i, o, a, c), this._viewportRuler = t, this._changeDetectorRef = e, this._ngZone = n, this._dir = s, this._parentFormField = l, this.ngControl = c, this._liveAnnouncer = d, this._panelOpen = !1, this._required = !1, this._scrollTop = 0, this._multiple = !1, this._compareWith = (t, e) => t === e, this._uid = `mat-select-${oP++}`, this._destroy = new k, this._triggerFontSize = 0, this._onChange = () => { }, this._onTouched = () => { }, this._optionIds = "", this._transformOrigin = "top", this._panelDoneAnimatingStream = new k, this._offsetY = 0, this._positions = [{ originX: "start", originY: "top", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "bottom", overlayX: "start", overlayY: "bottom" }], this._disableOptionCentering = !1, this._focused = !1, this.controlType = "mat-select", this.ariaLabel = "", this.optionSelectionChanges = kf(() => { const t = this.options; return t ? t.changes.pipe(em(t), Qf(() => G(...t.map(t => t.onSelectionChange)))) : this._ngZone.onStable.asObservable().pipe(qf(1), Qf(() => this.optionSelectionChanges)) }), this.openedChange = new ql, this._openedStream = this.openedChange.pipe(Of(t => t), N(() => { })), this._closedStream = this.openedChange.pipe(Of(t => !t), N(() => { })), this.selectionChange = new ql, this.valueChange = new ql, this.ngControl && (this.ngControl.valueAccessor = this), this._scrollStrategyFactory = u, this._scrollStrategy = this._scrollStrategyFactory(), this.tabIndex = parseInt(h) || 0, this.id = this.id, p && (null != p.disableOptionCentering && (this.disableOptionCentering = p.disableOptionCentering), null != p.typeaheadDebounceInterval && (this.typeaheadDebounceInterval = p.typeaheadDebounceInterval)) } get focused() { return this._focused || this._panelOpen } get placeholder() { return this._placeholder } set placeholder(t) { this._placeholder = t, this.stateChanges.next() } get required() { return this._required } set required(t) { this._required = lb(t), this.stateChanges.next() } get multiple() { return this._multiple } set multiple(t) { if (this._selectionModel) throw Error("Cannot change `multiple` mode of select after initialization."); this._multiple = lb(t) } get disableOptionCentering() { return this._disableOptionCentering } set disableOptionCentering(t) { this._disableOptionCentering = lb(t) } get compareWith() { return this._compareWith } set compareWith(t) { if ("function" != typeof t) throw Error("`compareWith` must be a function."); this._compareWith = t, this._selectionModel && this._initializeSelection() } get value() { return this._value } set value(t) { t !== this._value && (this.writeValue(t), this._value = t) } get typeaheadDebounceInterval() { return this._typeaheadDebounceInterval } set typeaheadDebounceInterval(t) { this._typeaheadDebounceInterval = cb(t) } get id() { return this._id } set id(t) { this._id = t || this._uid, this.stateChanges.next() } ngOnInit() { this._selectionModel = new Gx(this.multiple), this.stateChanges.next(), this._panelDoneAnimatingStream.pipe(jx(), jw(this._destroy)).subscribe(() => { this.panelOpen ? (this._scrollTop = 0, this.openedChange.emit(!0)) : (this.openedChange.emit(!1), this.overlayDir.offsetX = 0, this._changeDetectorRef.markForCheck()) }), this._viewportRuler.change().pipe(jw(this._destroy)).subscribe(() => { this._panelOpen && (this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._changeDetectorRef.markForCheck()) }) } ngAfterContentInit() { this._initKeyManager(), this._selectionModel.changed.pipe(jw(this._destroy)).subscribe(t => { t.added.forEach(t => t.select()), t.removed.forEach(t => t.deselect()) }), this.options.changes.pipe(em(null), jw(this._destroy)).subscribe(() => { this._resetOptions(), this._initializeSelection() }) } ngDoCheck() { this.ngControl && this.updateErrorState() } ngOnChanges(t) { t.disabled && this.stateChanges.next(), t.typeaheadDebounceInterval && this._keyManager && this._keyManager.withTypeAhead(this._typeaheadDebounceInterval) } ngOnDestroy() { this._destroy.next(), this._destroy.complete(), this.stateChanges.complete() } toggle() { this.panelOpen ? this.close() : this.open() } open() { !this.disabled && this.options && this.options.length && !this._panelOpen && (this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || "0"), this._panelOpen = !0, this._keyManager.withHorizontalOrientation(null), this._calculateOverlayPosition(), this._highlightCorrectOption(), this._changeDetectorRef.markForCheck(), this._ngZone.onStable.asObservable().pipe(qf(1)).subscribe(() => { this._triggerFontSize && this.overlayDir.overlayRef && this.overlayDir.overlayRef.overlayElement && (this.overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`) })) } close() { this._panelOpen && (this._panelOpen = !1, this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr"), this._changeDetectorRef.markForCheck(), this._onTouched()) } writeValue(t) { this.options && this._setSelectionByValue(t) } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this._changeDetectorRef.markForCheck(), this.stateChanges.next() } get panelOpen() { return this._panelOpen } get selected() { return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0] } get triggerValue() { if (this.empty) return ""; if (this._multiple) { const t = this._selectionModel.selected.map(t => t.viewValue); return this._isRtl() && t.reverse(), t.join(", ") } return this._selectionModel.selected[0].viewValue } _isRtl() { return !!this._dir && "rtl" === this._dir.value } _handleKeydown(t) { this.disabled || (this.panelOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)) } _handleClosedKeydown(t) { const e = t.keyCode, n = 40 === e || 38 === e || 37 === e || 39 === e, i = 13 === e || 32 === e, r = this._keyManager; if (!r.isTyping() && i && !Zv(t) || (this.multiple || t.altKey) && n) t.preventDefault(), this.open(); else if (!this.multiple) { const n = this.selected; 36 === e || 35 === e ? (36 === e ? r.setFirstItemActive() : r.setLastItemActive(), t.preventDefault()) : r.onKeydown(t); const i = this.selected; i && n !== i && this._liveAnnouncer.announce(i.viewValue, 1e4) } } _handleOpenKeydown(t) { const e = this._keyManager, n = t.keyCode, i = 40 === n || 38 === n, r = e.isTyping(); if (36 === n || 35 === n) t.preventDefault(), 36 === n ? e.setFirstItemActive() : e.setLastItemActive(); else if (i && t.altKey) t.preventDefault(), this.close(); else if (r || 13 !== n && 32 !== n || !e.activeItem || Zv(t)) if (!r && this._multiple && 65 === n && t.ctrlKey) { t.preventDefault(); const e = this.options.some(t => !t.disabled && !t.selected); this.options.forEach(t => { t.disabled || (e ? t.select() : t.deselect()) }) } else { const n = e.activeItemIndex; e.onKeydown(t), this._multiple && i && t.shiftKey && e.activeItem && e.activeItemIndex !== n && e.activeItem._selectViaInteraction() } else t.preventDefault(), e.activeItem._selectViaInteraction() } _onFocus() { this.disabled || (this._focused = !0, this.stateChanges.next()) } _onBlur() { this._focused = !1, this.disabled || this.panelOpen || (this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next()) } _onAttached() { this.overlayDir.positionChange.pipe(qf(1)).subscribe(() => { this._changeDetectorRef.detectChanges(), this._calculateOverlayOffsetX(), this.panel.nativeElement.scrollTop = this._scrollTop }) } _getPanelTheme() { return this._parentFormField ? `mat-${this._parentFormField.color}` : "" } get empty() { return !this._selectionModel || this._selectionModel.isEmpty() } _initializeSelection() { Promise.resolve().then(() => { this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value), this.stateChanges.next() }) } _setSelectionByValue(t) { if (this.multiple && t) { if (!Array.isArray(t)) throw Error("Value must be an array in multiple-selection mode."); this._selectionModel.clear(), t.forEach(t => this._selectValue(t)), this._sortValues() } else { this._selectionModel.clear(); const e = this._selectValue(t); e ? this._keyManager.setActiveItem(e) : this.panelOpen || this._keyManager.setActiveItem(-1) } this._changeDetectorRef.markForCheck() } _selectValue(t) { const e = this.options.find(e => { try { return null != e.value && this._compareWith(e.value, t) } catch (n) { return Ei() && console.warn(n), !1 } }); return e && this._selectionModel.select(e), e } _initKeyManager() { this._keyManager = new Mb(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr").withAllowedModifierKeys(["shiftKey"]), this._keyManager.tabOut.pipe(jw(this._destroy)).subscribe(() => { this.panelOpen && (!this.multiple && this._keyManager.activeItem && this._keyManager.activeItem._selectViaInteraction(), this.focus(), this.close()) }), this._keyManager.change.pipe(jw(this._destroy)).subscribe(() => { this._panelOpen && this.panel ? this._scrollActiveOptionIntoView() : this._panelOpen || this.multiple || !this._keyManager.activeItem || this._keyManager.activeItem._selectViaInteraction() }) } _resetOptions() { const t = G(this.options.changes, this._destroy); this.optionSelectionChanges.pipe(jw(t)).subscribe(t => { this._onSelect(t.source, t.isUserInput), t.isUserInput && !this.multiple && this._panelOpen && (this.close(), this.focus()) }), G(...this.options.map(t => t._stateChanges)).pipe(jw(t)).subscribe(() => { this._changeDetectorRef.markForCheck(), this.stateChanges.next() }), this._setOptionIds() } _onSelect(t, e) { const n = this._selectionModel.isSelected(t); null != t.value || this._multiple ? (n !== t.selected && (t.selected ? this._selectionModel.select(t) : this._selectionModel.deselect(t)), e && this._keyManager.setActiveItem(t), this.multiple && (this._sortValues(), e && this.focus())) : (t.deselect(), this._selectionModel.clear(), this._propagateChanges(t.value)), n !== this._selectionModel.isSelected(t) && this._propagateChanges(), this.stateChanges.next() } _sortValues() { if (this.multiple) { const t = this.options.toArray(); this._selectionModel.sort((e, n) => this.sortComparator ? this.sortComparator(e, n, t) : t.indexOf(e) - t.indexOf(n)), this.stateChanges.next() } } _propagateChanges(t) { let e = null; e = this.multiple ? this.selected.map(t => t.value) : this.selected ? this.selected.value : t, this._value = e, this.valueChange.emit(e), this._onChange(e), this.selectionChange.emit(new hP(this, e)), this._changeDetectorRef.markForCheck() } _setOptionIds() { this._optionIds = this.options.map(t => t.id).join(" ") } _highlightCorrectOption() { this._keyManager && (this.empty ? this._keyManager.setFirstItemActive() : this._keyManager.setActiveItem(this._selectionModel.selected[0])) } _scrollActiveOptionIntoView() { const t = this._keyManager.activeItemIndex || 0, e = Rw(t, this.options, this.optionGroups); this.panel.nativeElement.scrollTop = Mw(t + e, this._getItemHeight(), this.panel.nativeElement.scrollTop, 256) } focus(t) { this._elementRef.nativeElement.focus(t) } _getOptionIndex(t) { return this.options.reduce((e, n, i) => void 0 !== e ? e : t === n ? i : void 0, void 0) } _calculateOverlayPosition() { const t = this._getItemHeight(), e = this._getItemCount(), n = Math.min(e * t, 256), i = e * t - n; let r = this.empty ? 0 : this._getOptionIndex(this._selectionModel.selected[0]); r += Rw(r, this.options, this.optionGroups); const s = n / 2; this._scrollTop = this._calculateOverlayScroll(r, s, i), this._offsetY = this._calculateOverlayOffsetY(r, s, i), this._checkOverlayWithinViewport(i) } _calculateOverlayScroll(t, e, n) { const i = this._getItemHeight(); return Math.min(Math.max(0, i * t - e + i / 2), n) } _getAriaLabel() { return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder } _getAriaLabelledby() { return this.ariaLabelledby ? this.ariaLabelledby : this._parentFormField && this._parentFormField._hasFloatingLabel() && !this._getAriaLabel() && this._parentFormField._labelId || null } _getAriaActiveDescendant() { return this.panelOpen && this._keyManager && this._keyManager.activeItem ? this._keyManager.activeItem.id : null } _calculateOverlayOffsetX() { const t = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect(), e = this._viewportRuler.getViewportSize(), n = this._isRtl(), i = this.multiple ? 56 : 32; let r; if (this.multiple) r = 40; else { let t = this._selectionModel.selected[0] || this.options.first; r = t && t.group ? 32 : 16 } n || (r *= -1); const s = 0 - (t.left + r - (n ? i : 0)), o = t.right + r - e.width + (n ? 0 : i); s > 0 ? r += s + 8 : o > 0 && (r -= o + 8), this.overlayDir.offsetX = Math.round(r), this.overlayDir.overlayRef.updatePosition() } _calculateOverlayOffsetY(t, e, n) { const i = this._getItemHeight(), r = (i - this._triggerRect.height) / 2, s = Math.floor(256 / i); let o; return this._disableOptionCentering ? 0 : (o = 0 === this._scrollTop ? t * i : this._scrollTop === n ? (t - (this._getItemCount() - s)) * i + (i - (this._getItemCount() * i - 256) % i) : e - i / 2, Math.round(-1 * o - r)) } _checkOverlayWithinViewport(t) { const e = this._getItemHeight(), n = this._viewportRuler.getViewportSize(), i = this._triggerRect.top - 8, r = n.height - this._triggerRect.bottom - 8, s = Math.abs(this._offsetY), o = Math.min(this._getItemCount() * e, 256) - s - this._triggerRect.height; o > r ? this._adjustPanelUp(o, r) : s > i ? this._adjustPanelDown(s, i, t) : this._transformOrigin = this._getOriginBasedOnOption() } _adjustPanelUp(t, e) { const n = Math.round(t - e); this._scrollTop -= n, this._offsetY -= n, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop <= 0 && (this._scrollTop = 0, this._offsetY = 0, this._transformOrigin = "50% bottom 0px") } _adjustPanelDown(t, e, n) { const i = Math.round(t - e); if (this._scrollTop += i, this._offsetY += i, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop >= n) return this._scrollTop = n, this._offsetY = 0, void (this._transformOrigin = "50% top 0px") } _getOriginBasedOnOption() { const t = this._getItemHeight(), e = (t - this._triggerRect.height) / 2; return `50% ${Math.abs(this._offsetY) - e + t / 2}px 0px` } _getItemCount() { return this.options.length + this.optionGroups.length } _getItemHeight() { return 3 * this._triggerFontSize } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } onContainerClick() { this.focus(), this.open() } get shouldLabelFloat() { return this._panelOpen || !this.empty } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Kx), Ao(Ws), Ao(Lc), Ao(dw), Ao(Ua), Ao(Gb, 8), Ao(Lv, 8), Ao(zv, 8), Ao(bx, 8), Ao(z_, 10), To("tabindex"), Ao(aP), Ao(Vb), Ao(lP, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-select"]], contentQueries: function (t, e, n) { var i; 1 & t && (oc(n, pP, !0), oc(n, Iw, !0), oc(n, Ow, !0)), 2 & t && (nc(i = cc()) && (e.customTrigger = i.first), nc(i = cc()) && (e.options = i), nc(i = cc()) && (e.optionGroups = i)) }, viewQuery: function (t, e) { var n; 1 & t && (rc(KT, !0), rc(QT, !0), rc(NC, !0)), 2 & t && (nc(n = cc()) && (e.trigger = n.first), nc(n = cc()) && (e.panel = n.first), nc(n = cc()) && (e.overlayDir = n.first)) }, hostAttrs: ["role", "listbox", 1, "mat-select"], hostVars: 19, hostBindings: function (t, e) { 1 & t && Ho("keydown", (function (t) { return e._handleKeydown(t) }))("focus", (function () { return e._onFocus() }))("blur", (function () { return e._onBlur() })), 2 & t && (So("id", e.id)("tabindex", e.tabIndex)("aria-label", e._getAriaLabel())("aria-labelledby", e._getAriaLabelledby())("aria-required", e.required.toString())("aria-disabled", e.disabled.toString())("aria-invalid", e.errorState)("aria-owns", e.panelOpen ? e._optionIds : null)("aria-multiselectable", e.multiple)("aria-describedby", e._ariaDescribedby || null)("aria-activedescendant", e._getAriaActiveDescendant()), sa("mat-select-disabled", e.disabled)("mat-select-invalid", e.errorState)("mat-select-required", e.required)("mat-select-empty", e.empty)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex", ariaLabel: ["aria-label", "ariaLabel"], id: "id", disableOptionCentering: "disableOptionCentering", typeaheadDebounceInterval: "typeaheadDebounceInterval", placeholder: "placeholder", required: "required", multiple: "multiple", compareWith: "compareWith", value: "value", panelClass: "panelClass", ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], errorStateMatcher: "errorStateMatcher", sortComparator: "sortComparator" }, outputs: { openedChange: "openedChange", _openedStream: "opened", _closedStream: "closed", selectionChange: "selectionChange", valueChange: "valueChange" }, exportAs: ["matSelect"], features: [ja([{ provide: lx, useExisting: t }, { provide: Dw, useExisting: t }]), Ca, Ta], ngContentSelectors: rP, decls: 9, vars: 9, consts: [["cdk-overlay-origin", "", "aria-hidden", "true", 1, "mat-select-trigger", 3, "click"], ["origin", "cdkOverlayOrigin", "trigger", ""], [1, "mat-select-value", 3, "ngSwitch"], ["class", "mat-select-placeholder", 4, "ngSwitchCase"], ["class", "mat-select-value-text", 3, "ngSwitch", 4, "ngSwitchCase"], [1, "mat-select-arrow-wrapper"], [1, "mat-select-arrow"], ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOffsetY", "backdropClick", "attach", "detach"], [1, "mat-select-placeholder"], [1, "mat-select-value-text", 3, "ngSwitch"], [4, "ngSwitchDefault"], [4, "ngSwitchCase"], [1, "mat-select-panel-wrap"], [3, "ngClass", "keydown"], ["panel", ""]], template: function (t, e) { if (1 & t && (Xo(iP), Ro(0, "div", 0, 1), Ho("click", (function () { return e.toggle() })), Ro(3, "div", 2), Eo(4, ZT, 2, 1, "span", 3), Eo(5, eP, 3, 2, "span", 4), Mo(), Ro(6, "div", 5), Lo(7, "div", 6), Mo(), Mo(), Eo(8, nP, 4, 11, "ng-template", 7), Ho("backdropClick", (function () { return e.close() }))("attach", (function () { return e._onAttached() }))("detach", (function () { return e.close() }))), 2 & t) { const t = Oo(1); yr(3), Do("ngSwitch", e.empty), yr(1), Do("ngSwitchCase", !0), yr(1), Do("ngSwitchCase", !1), yr(3), Do("cdkConnectedOverlayScrollStrategy", e._scrollStrategy)("cdkConnectedOverlayOrigin", t)("cdkConnectedOverlayOpen", e.panelOpen)("cdkConnectedOverlayPositions", e._positions)("cdkConnectedOverlayMinWidth", null == e._triggerRect ? null : e._triggerRect.width)("cdkConnectedOverlayOffsetY", e._offsetY) } }, directives: [FC, Yh, Xh, NC, Kh, Bh], styles: [".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}\n"], encapsulation: 2, data: { animation: [sP.transformPanelWrap, sP.transformPanel] }, changeDetection: 0 }), t })(), mP = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [cP], imports: [[au, jC, Lw, sw], Qx, xx, Lw, sw] }), t })(); class gP { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new yP(t, this.total)) } } class yP extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } const _P = new Set; let vP, bP = (() => { class t { constructor(t) { this._platform = t, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : wP } matchMedia(t) { return this._platform.WEBKIT && function (t) { if (!_P.has(t)) try { vP || (vP = document.createElement("style"), vP.setAttribute("type", "text/css"), document.head.appendChild(vP)), vP.sheet && (vP.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`, 0), _P.add(t)) } catch (GM) { console.error(GM) } }(t), this._matchMedia(t) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(gb)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(gb)) }, token: t, providedIn: "root" }), t })(); function wP(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } } let xP = (() => { class t { constructor(t, e) { this._mediaMatcher = t, this._zone = e, this._queries = new Map, this._destroySubject = new k } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(t) { return CP(ub(t)).some(t => this._registerQuery(t).mql.matches) } observe(t) { let e = bf(CP(ub(t)).map(t => this._registerQuery(t).observable)); return e = tm(e.pipe(qf(1)), e.pipe(t => t.lift(new gP(1)), rb(0))), e.pipe(N(t => { const e = { matches: !1, breakpoints: {} }; return t.forEach(t => { e.matches = e.matches || t.matches, e.breakpoints[t.query] = t.matches }), e })) } _registerQuery(t) { if (this._queries.has(t)) return this._queries.get(t); const e = this._mediaMatcher.matchMedia(t), n = { observable: new b(t => { const n = e => this._zone.run(() => t.next(e)); return e.addListener(n), () => { e.removeListener(n) } }).pipe(em(e), N(e => ({ query: t, matches: e.matches })), jw(this._destroySubject)), mql: e }; return this._queries.set(t, n), n } } return t.\u0275fac = function (e) { return new (e || t)(Kt(bP), Kt(Lc)) }, t.\u0275prov = dt({ factory: function () { return new t(Kt(bP), Kt(Lc)) }, token: t, providedIn: "root" }), t })(); function CP(t) { return t.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim()) } const SP = { tooltipState: qu("state", [Ku("initial, void, hidden", Xu({ opacity: 0, transform: "scale(0)" })), Ku("visible", Xu({ transform: "scale(1)" })), Zu("* => visible", Wu("200ms cubic-bezier(0, 0, 0.2, 1)", Qu([Xu({ opacity: 0, transform: "scale(0)", offset: 0 }), Xu({ opacity: .5, transform: "scale(0.99)", offset: .5 }), Xu({ opacity: 1, transform: "scale(1)", offset: 1 })]))), Zu("* => hidden", Wu("100ms cubic-bezier(0, 0, 0.2, 1)", Xu({ opacity: 0 })))]) }, kP = xb({ passive: !0 }); function EP(t) { return Error(`Tooltip position "${t}" is invalid.`) } const OP = new Bt("mat-tooltip-scroll-strategy"), AP = { provide: OP, deps: [RC], useFactory: function (t) { return () => t.scrollStrategies.reposition({ scrollThrottle: 20 }) } }, TP = new Bt("mat-tooltip-default-options", { providedIn: "root", factory: function () { return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 } } }); let PP = (() => { class t { constructor(t, e, n, i, r, s, o, a, l, c, h, u) { this._overlay = t, this._elementRef = e, this._scrollDispatcher = n, this._viewContainerRef = i, this._ngZone = r, this._platform = s, this._ariaDescriber = o, this._focusMonitor = a, this._dir = c, this._defaultOptions = h, this._position = "below", this._disabled = !1, this.showDelay = this._defaultOptions.showDelay, this.hideDelay = this._defaultOptions.hideDelay, this.touchGestures = "auto", this._message = "", this._passiveListeners = new Map, this._destroyed = new k, this._handleKeydown = t => { this._isTooltipVisible() && 27 === t.keyCode && !Zv(t) && (t.preventDefault(), t.stopPropagation(), this._ngZone.run(() => this.hide(0))) }, this._scrollStrategy = l, h && (h.position && (this.position = h.position), h.touchGestures && (this.touchGestures = h.touchGestures)), a.monitor(e).pipe(jw(this._destroyed)).subscribe(t => { t ? "keyboard" === t && r.run(() => this.show()) : r.run(() => this.hide(0)) }), r.runOutsideAngular(() => { e.nativeElement.addEventListener("keydown", this._handleKeydown) }) } get position() { return this._position } set position(t) { t !== this._position && (this._position = t, this._overlayRef && (this._updatePosition(), this._tooltipInstance && this._tooltipInstance.show(0), this._overlayRef.updatePosition())) } get disabled() { return this._disabled } set disabled(t) { this._disabled = lb(t), this._disabled && this.hide(0) } get message() { return this._message } set message(t) { this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message), this._message = null != t ? `${t}`.trim() : "", !this._message && this._isTooltipVisible() ? this.hide(0) : (this._updateTooltipMessage(), this._ngZone.runOutsideAngular(() => { Promise.resolve().then(() => { this._ariaDescriber.describe(this._elementRef.nativeElement, this.message) }) })) } get tooltipClass() { return this._tooltipClass } set tooltipClass(t) { this._tooltipClass = t, this._tooltipInstance && this._setTooltipClass(this._tooltipClass) } ngOnInit() { this._setupPointerEvents() } ngOnDestroy() { const t = this._elementRef.nativeElement; clearTimeout(this._touchstartTimeout), this._overlayRef && (this._overlayRef.dispose(), this._tooltipInstance = null), t.removeEventListener("keydown", this._handleKeydown), this._passiveListeners.forEach((e, n) => { t.removeEventListener(n, e, kP) }), this._passiveListeners.clear(), this._destroyed.next(), this._destroyed.complete(), this._ariaDescriber.removeDescription(t, this.message), this._focusMonitor.stopMonitoring(t) } show(t = this.showDelay) { if (this.disabled || !this.message || this._isTooltipVisible() && !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId) return; const e = this._createOverlay(); this._detach(), this._portal = this._portal || new eC(DP, this._viewContainerRef), this._tooltipInstance = e.attach(this._portal).instance, this._tooltipInstance.afterHidden().pipe(jw(this._destroyed)).subscribe(() => this._detach()), this._setTooltipClass(this._tooltipClass), this._updateTooltipMessage(), this._tooltipInstance.show(t) } hide(t = this.hideDelay) { this._tooltipInstance && this._tooltipInstance.hide(t) } toggle() { this._isTooltipVisible() ? this.hide() : this.show() } _isTooltipVisible() { return !!this._tooltipInstance && this._tooltipInstance.isVisible() } _createOverlay() { if (this._overlayRef) return this._overlayRef; const t = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef), e = this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(".mat-tooltip").withFlexibleDimensions(!1).withViewportMargin(8).withScrollableContainers(t); return e.positionChanges.pipe(jw(this._destroyed)).subscribe(t => { this._tooltipInstance && t.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible() && this._ngZone.run(() => this.hide(0)) }), this._overlayRef = this._overlay.create({ direction: this._dir, positionStrategy: e, panelClass: "mat-tooltip-panel", scrollStrategy: this._scrollStrategy() }), this._updatePosition(), this._overlayRef.detachments().pipe(jw(this._destroyed)).subscribe(() => this._detach()), this._overlayRef } _detach() { this._overlayRef && this._overlayRef.hasAttached() && this._overlayRef.detach(), this._tooltipInstance = null } _updatePosition() { const t = this._overlayRef.getConfig().positionStrategy, e = this._getOrigin(), n = this._getOverlayPosition(); t.withPositions([Object.assign(Object.assign({}, e.main), n.main), Object.assign(Object.assign({}, e.fallback), n.fallback)]) } _getOrigin() { const t = !this._dir || "ltr" == this._dir.value, e = this.position; let n; if ("above" == e || "below" == e) n = { originX: "center", originY: "above" == e ? "top" : "bottom" }; else if ("before" == e || "left" == e && t || "right" == e && !t) n = { originX: "start", originY: "center" }; else { if (!("after" == e || "right" == e && t || "left" == e && !t)) throw EP(e); n = { originX: "end", originY: "center" } } const { x: i, y: r } = this._invertPosition(n.originX, n.originY); return { main: n, fallback: { originX: i, originY: r } } } _getOverlayPosition() { const t = !this._dir || "ltr" == this._dir.value, e = this.position; let n; if ("above" == e) n = { overlayX: "center", overlayY: "bottom" }; else if ("below" == e) n = { overlayX: "center", overlayY: "top" }; else if ("before" == e || "left" == e && t || "right" == e && !t) n = { overlayX: "end", overlayY: "center" }; else { if (!("after" == e || "right" == e && t || "left" == e && !t)) throw EP(e); n = { overlayX: "start", overlayY: "center" } } const { x: i, y: r } = this._invertPosition(n.overlayX, n.overlayY); return { main: n, fallback: { overlayX: i, overlayY: r } } } _updateTooltipMessage() { this._tooltipInstance && (this._tooltipInstance.message = this.message, this._tooltipInstance._markForCheck(), this._ngZone.onMicrotaskEmpty.asObservable().pipe(qf(1), jw(this._destroyed)).subscribe(() => { this._tooltipInstance && this._overlayRef.updatePosition() })) } _setTooltipClass(t) { this._tooltipInstance && (this._tooltipInstance.tooltipClass = t, this._tooltipInstance._markForCheck()) } _invertPosition(t, e) { return "above" === this.position || "below" === this.position ? "top" === e ? e = "bottom" : "bottom" === e && (e = "top") : "end" === t ? t = "start" : "start" === t && (t = "end"), { x: t, y: e } } _setupPointerEvents() { if (this._platform.IOS || this._platform.ANDROID) { if ("off" !== this.touchGestures) { this._disableNativeGesturesIfNecessary(); const t = () => { clearTimeout(this._touchstartTimeout), this.hide(this._defaultOptions.touchendHideDelay) }; this._passiveListeners.set("touchend", t).set("touchcancel", t).set("touchstart", () => { clearTimeout(this._touchstartTimeout), this._touchstartTimeout = setTimeout(() => this.show(), 500) }) } } else this._passiveListeners.set("mouseenter", () => this.show()).set("mouseleave", () => this.hide()); this._passiveListeners.forEach((t, e) => { this._elementRef.nativeElement.addEventListener(e, t, kP) }) } _disableNativeGesturesIfNecessary() { const t = this._elementRef.nativeElement, e = t.style, n = this.touchGestures; "off" !== n && (("on" === n || "INPUT" !== t.nodeName && "TEXTAREA" !== t.nodeName) && (e.userSelect = e.msUserSelect = e.webkitUserSelect = e.MozUserSelect = "none"), "on" !== n && t.draggable || (e.webkitUserDrag = "none"), e.touchAction = "none", e.webkitTapHighlightColor = "transparent") } } return t.\u0275fac = function (e) { return new (e || t)(Ao(RC), Ao(Ua), Ao(Xx), Ao(ml), Ao(Lc), Ao(gb), Ao(Ib), Ao(Hb), Ao(OP), Ao(Gb, 8), Ao(TP, 8), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "matTooltip", ""]], inputs: { showDelay: ["matTooltipShowDelay", "showDelay"], hideDelay: ["matTooltipHideDelay", "hideDelay"], touchGestures: ["matTooltipTouchGestures", "touchGestures"], position: ["matTooltipPosition", "position"], disabled: ["matTooltipDisabled", "disabled"], message: ["matTooltip", "message"], tooltipClass: ["matTooltipClass", "tooltipClass"] }, exportAs: ["matTooltip"] }), t })(), DP = (() => { class t { constructor(t, e) { this._changeDetectorRef = t, this._breakpointObserver = e, this._visibility = "initial", this._closeOnInteraction = !1, this._onHide = new k, this._isHandset = this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait), (max-width: 959.99px) and (orientation: landscape)") } show(t) { this._hideTimeoutId && (clearTimeout(this._hideTimeoutId), this._hideTimeoutId = null), this._closeOnInteraction = !0, this._showTimeoutId = setTimeout(() => { this._visibility = "visible", this._showTimeoutId = null, this._markForCheck() }, t) } hide(t) { this._showTimeoutId && (clearTimeout(this._showTimeoutId), this._showTimeoutId = null), this._hideTimeoutId = setTimeout(() => { this._visibility = "hidden", this._hideTimeoutId = null, this._markForCheck() }, t) } afterHidden() { return this._onHide.asObservable() } isVisible() { return "visible" === this._visibility } ngOnDestroy() { this._onHide.complete() } _animationStart() { this._closeOnInteraction = !1 } _animationDone(t) { const e = t.toState; "hidden" !== e || this.isVisible() || this._onHide.next(), "visible" !== e && "hidden" !== e || (this._closeOnInteraction = !0) } _handleBodyInteraction() { this._closeOnInteraction && this.hide(0) } _markForCheck() { this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ws), Ao(xP)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-tooltip-component"]], hostAttrs: ["aria-hidden", "true"], hostVars: 2, hostBindings: function (t, e) { 1 & t && Ho("click", (function () { return e._handleBodyInteraction() }), !1, Wn), 2 & t && ra("zoom", "visible" === e._visibility ? 1 : null) }, decls: 3, vars: 7, consts: [[1, "mat-tooltip", 3, "ngClass"]], template: function (t, e) { var n; 1 & t && (Ro(0, "div", 0), Ho("@state.start", (function () { return e._animationStart() }))("@state.done", (function (t) { return e._animationDone(t) })), Bl(1, "async"), ga(2), Mo()), 2 & t && (sa("mat-tooltip-handset", null == (n = zl(1, 5, e._isHandset)) ? null : n.matches), Do("ngClass", e.tooltipClass)("@state", e._visibility), yr(2), ya(e.message)) }, directives: [Bh], pipes: [iu], styles: [".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"], encapsulation: 2, data: { animation: [SP.tooltipState] }, changeDetection: 0 }), t })(), IP = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [AP], imports: [[qb, au, jC, sw], sw, Qx] }), t })(); function RP(t, e) { if (1 & t && (Ro(0, "mat-option", 19), ga(1), Mo()), 2 & t) { const t = e.$implicit; Do("value", t), yr(1), _a(" ", t, " ") } } function MP(t, e) { if (1 & t) { const t = jo(); Ro(0, "mat-form-field", 16), Ro(1, "mat-select", 17), Ho("selectionChange", (function (e) { return Ze(t), Go(2)._changePageSize(e.value) })), Eo(2, RP, 2, 2, "mat-option", 18), Mo(), Mo() } if (2 & t) { const t = Go(2); Do("color", t.color), yr(1), Do("value", t.pageSize)("disabled", t.disabled)("aria-label", t._intl.itemsPerPageLabel), yr(1), Do("ngForOf", t._displayedPageSizeOptions) } } function LP(t, e) { if (1 & t && (Ro(0, "div", 20), ga(1), Mo()), 2 & t) { const t = Go(2); yr(1), ya(t.pageSize) } } function FP(t, e) { if (1 & t && (Ro(0, "div", 12), Ro(1, "div", 13), ga(2), Mo(), Eo(3, MP, 3, 5, "mat-form-field", 14), Eo(4, LP, 2, 1, "div", 15), Mo()), 2 & t) { const t = Go(); yr(2), _a(" ", t._intl.itemsPerPageLabel, " "), yr(1), Do("ngIf", t._displayedPageSizeOptions.length > 1), yr(1), Do("ngIf", t._displayedPageSizeOptions.length <= 1) } } function NP(t, e) { if (1 & t) { const t = jo(); Ro(0, "button", 21), Ho("click", (function () { return Ze(t), Go().firstPage() })), kn(), Ro(1, "svg", 7), Lo(2, "path", 22), Mo(), Mo() } if (2 & t) { const t = Go(); Do("matTooltip", t._intl.firstPageLabel)("matTooltipDisabled", t._previousButtonsDisabled())("matTooltipPosition", "above")("disabled", t._previousButtonsDisabled()), So("aria-label", t._intl.firstPageLabel) } } function VP(t, e) { if (1 & t) { const t = jo(); kn(), En(), Ro(0, "button", 23), Ho("click", (function () { return Ze(t), Go().lastPage() })), kn(), Ro(1, "svg", 7), Lo(2, "path", 24), Mo(), Mo() } if (2 & t) { const t = Go(); Do("matTooltip", t._intl.lastPageLabel)("matTooltipDisabled", t._nextButtonsDisabled())("matTooltipPosition", "above")("disabled", t._nextButtonsDisabled()), So("aria-label", t._intl.lastPageLabel) } } let jP = (() => { class t { constructor() { this.changes = new k, this.itemsPerPageLabel = "Items per page:", this.nextPageLabel = "Next page", this.previousPageLabel = "Previous page", this.firstPageLabel = "First page", this.lastPageLabel = "Last page", this.getRangeLabel = (t, e, n) => { if (0 == n || 0 == e) return `0 of ${n}`; const i = t * e; return `${i + 1} \u2013 ${i < (n = Math.max(n, 0)) ? Math.min(i + e, n) : i + e} of ${n}` } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const BP = { provide: jP, deps: [[new ot, new lt, jP]], useFactory: function (t) { return t || new jP } }, zP = new Bt("MAT_PAGINATOR_DEFAULT_OPTIONS"); class HP { } const UP = ow(uw(HP)); let $P = (() => { class t extends UP { constructor(t, e, n) { if (super(), this._intl = t, this._changeDetectorRef = e, this._pageIndex = 0, this._length = 0, this._pageSizeOptions = [], this._hidePageSize = !1, this._showFirstLastButtons = !1, this.page = new ql, this._intlChanges = t.changes.subscribe(() => this._changeDetectorRef.markForCheck()), n) { const { pageSize: t, pageSizeOptions: e, hidePageSize: i, showFirstLastButtons: r } = n; null != t && (this._pageSize = t), null != e && (this._pageSizeOptions = e), null != i && (this._hidePageSize = i), null != r && (this._showFirstLastButtons = r) } } get pageIndex() { return this._pageIndex } set pageIndex(t) { this._pageIndex = Math.max(cb(t), 0), this._changeDetectorRef.markForCheck() } get length() { return this._length } set length(t) { this._length = cb(t), this._changeDetectorRef.markForCheck() } get pageSize() { return this._pageSize } set pageSize(t) { this._pageSize = Math.max(cb(t), 0), this._updateDisplayedPageSizeOptions() } get pageSizeOptions() { return this._pageSizeOptions } set pageSizeOptions(t) { this._pageSizeOptions = (t || []).map(t => cb(t)), this._updateDisplayedPageSizeOptions() } get hidePageSize() { return this._hidePageSize } set hidePageSize(t) { this._hidePageSize = lb(t) } get showFirstLastButtons() { return this._showFirstLastButtons } set showFirstLastButtons(t) { this._showFirstLastButtons = lb(t) } ngOnInit() { this._initialized = !0, this._updateDisplayedPageSizeOptions(), this._markInitialized() } ngOnDestroy() { this._intlChanges.unsubscribe() } nextPage() { if (!this.hasNextPage()) return; const t = this.pageIndex; this.pageIndex++, this._emitPageEvent(t) } previousPage() { if (!this.hasPreviousPage()) return; const t = this.pageIndex; this.pageIndex--, this._emitPageEvent(t) } firstPage() { if (!this.hasPreviousPage()) return; const t = this.pageIndex; this.pageIndex = 0, this._emitPageEvent(t) } lastPage() { if (!this.hasNextPage()) return; const t = this.pageIndex; this.pageIndex = this.getNumberOfPages() - 1, this._emitPageEvent(t) } hasPreviousPage() { return this.pageIndex >= 1 && 0 != this.pageSize } hasNextPage() { const t = this.getNumberOfPages() - 1; return this.pageIndex < t && 0 != this.pageSize } getNumberOfPages() { return this.pageSize ? Math.ceil(this.length / this.pageSize) : 0 } _changePageSize(t) { const e = this.pageIndex; this.pageIndex = Math.floor(this.pageIndex * this.pageSize / t) || 0, this.pageSize = t, this._emitPageEvent(e) } _nextButtonsDisabled() { return this.disabled || !this.hasNextPage() } _previousButtonsDisabled() { return this.disabled || !this.hasPreviousPage() } _updateDisplayedPageSizeOptions() { this._initialized && (this.pageSize || (this._pageSize = 0 != this.pageSizeOptions.length ? this.pageSizeOptions[0] : 50), this._displayedPageSizeOptions = this.pageSizeOptions.slice(), -1 === this._displayedPageSizeOptions.indexOf(this.pageSize) && this._displayedPageSizeOptions.push(this.pageSize), this._displayedPageSizeOptions.sort((t, e) => t - e), this._changeDetectorRef.markForCheck()) } _emitPageEvent(t) { this.page.emit({ previousPageIndex: t, pageIndex: this.pageIndex, pageSize: this.pageSize, length: this.length }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(jP), Ao(Ws), Ao(zP, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-paginator"]], hostAttrs: [1, "mat-paginator"], inputs: { disabled: "disabled", pageIndex: "pageIndex", length: "length", pageSize: "pageSize", pageSizeOptions: "pageSizeOptions", hidePageSize: "hidePageSize", showFirstLastButtons: "showFirstLastButtons", color: "color" }, outputs: { page: "page" }, exportAs: ["matPaginator"], features: [Ca], decls: 14, vars: 14, consts: [[1, "mat-paginator-outer-container"], [1, "mat-paginator-container"], ["class", "mat-paginator-page-size", 4, "ngIf"], [1, "mat-paginator-range-actions"], [1, "mat-paginator-range-label"], ["mat-icon-button", "", "type", "button", "class", "mat-paginator-navigation-first", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click", 4, "ngIf"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-previous", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"], ["viewBox", "0 0 24 24", "focusable", "false", 1, "mat-paginator-icon"], ["d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-next", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"], ["d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"], ["mat-icon-button", "", "type", "button", "class", "mat-paginator-navigation-last", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click", 4, "ngIf"], [1, "mat-paginator-page-size"], [1, "mat-paginator-page-size-label"], ["class", "mat-paginator-page-size-select", 3, "color", 4, "ngIf"], ["class", "mat-paginator-page-size-value", 4, "ngIf"], [1, "mat-paginator-page-size-select", 3, "color"], [3, "value", "disabled", "aria-label", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "mat-paginator-page-size-value"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-first", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"], ["d", "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-last", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"], ["d", "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"]], template: function (t, e) { 1 & t && (Ro(0, "div", 0), Ro(1, "div", 1), Eo(2, FP, 5, 3, "div", 2), Ro(3, "div", 3), Ro(4, "div", 4), ga(5), Mo(), Eo(6, NP, 3, 5, "button", 5), Ro(7, "button", 6), Ho("click", (function () { return e.previousPage() })), kn(), Ro(8, "svg", 7), Lo(9, "path", 8), Mo(), Mo(), En(), Ro(10, "button", 9), Ho("click", (function () { return e.nextPage() })), kn(), Ro(11, "svg", 7), Lo(12, "path", 10), Mo(), Mo(), Eo(13, VP, 3, 5, "button", 11), Mo(), Mo(), Mo()), 2 & t && (yr(2), Do("ngIf", !e.hidePageSize), yr(3), _a(" ", e._intl.getRangeLabel(e.pageIndex, e.pageSize, e.length), " "), yr(1), Do("ngIf", e.showFirstLastButtons), yr(1), Do("matTooltip", e._intl.previousPageLabel)("matTooltipDisabled", e._previousButtonsDisabled())("matTooltipPosition", "above")("disabled", e._previousButtonsDisabled()), So("aria-label", e._intl.previousPageLabel), yr(3), Do("matTooltip", e._intl.nextPageLabel)("matTooltipDisabled", e._nextButtonsDisabled())("matTooltipPosition", "above")("disabled", e._nextButtonsDisabled()), So("aria-label", e._intl.nextPageLabel), yr(3), Do("ngIf", e.showFirstLastButtons)) }, directives: [$h, rO, PP, wx, fP, Hh, Iw], styles: [".mat-paginator{display:block}.mat-paginator-outer-container{display:flex}.mat-paginator-container{display:flex;align-items:center;justify-content:flex-end;min-height:56px;padding:0 8px;flex-wrap:wrap-reverse;width:100%}.mat-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-paginator-page-size{margin-right:0;margin-left:8px}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:6px 4px 0 4px;width:56px}.mat-paginator-page-size-select.mat-form-field-appearance-outline{width:64px}.mat-paginator-page-size-select.mat-form-field-appearance-fill{width:64px}.mat-paginator-range-label{margin:0 32px 0 24px}.mat-paginator-range-actions{display:flex;align-items:center}.mat-paginator-icon{width:28px;fill:currentColor}[dir=rtl] .mat-paginator-icon{transform:rotate(180deg)}\n"], encapsulation: 2, changeDetection: 0 }), t })(), qP = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [BP], imports: [[au, sO, mP, IP]] }), t })(); var WP = n("dCbE"), GP = n("WiE2"); function YP(t, e) { if (1 & t && (kn(), Lo(0, "circle", 3)), 2 & t) { const t = Go(); ra("animation-name", "mat-progress-spinner-stroke-rotate-" + t.diameter)("stroke-dashoffset", t._strokeDashOffset, "px")("stroke-dasharray", t._strokeCircumference, "px")("stroke-width", t._circleStrokeWidth, "%"), So("r", t._circleRadius) } } function XP(t, e) { if (1 & t && (kn(), Lo(0, "circle", 3)), 2 & t) { const t = Go(); ra("stroke-dashoffset", t._strokeDashOffset, "px")("stroke-dasharray", t._strokeCircumference, "px")("stroke-width", t._circleStrokeWidth, "%"), So("r", t._circleRadius) } } class KP { constructor(t) { this._elementRef = t } } const QP = aw(KP, "primary"), ZP = new Bt("mat-progress-spinner-default-options", { providedIn: "root", factory: function () { return { diameter: 100 } } }); let JP = (() => { class t extends QP { constructor(e, n, i, r, s) { super(e), this._elementRef = e, this._document = i, this._diameter = 100, this._value = 0, this._fallbackAnimation = !1, this.mode = "determinate"; const o = t._diameters; o.has(i.head) || o.set(i.head, new Set([100])), this._fallbackAnimation = n.EDGE || n.TRIDENT, this._noopAnimations = "NoopAnimations" === r && !!s && !s._forceAnimations, s && (s.diameter && (this.diameter = s.diameter), s.strokeWidth && (this.strokeWidth = s.strokeWidth)) } get diameter() { return this._diameter } set diameter(t) { this._diameter = cb(t), !this._fallbackAnimation && this._styleRoot && this._attachStyleNode() } get strokeWidth() { return this._strokeWidth || this.diameter / 10 } set strokeWidth(t) { this._strokeWidth = cb(t) } get value() { return "determinate" === this.mode ? this._value : 0 } set value(t) { this._value = Math.max(0, Math.min(100, cb(t))) } ngOnInit() { const t = this._elementRef.nativeElement; this._styleRoot = Cb(t) || this._document.head, this._attachStyleNode(), t.classList.add(`mat-progress-spinner-indeterminate${this._fallbackAnimation ? "-fallback" : ""}-animation`) } get _circleRadius() { return (this.diameter - 10) / 2 } get _viewBox() { const t = 2 * this._circleRadius + this.strokeWidth; return `0 0 ${t} ${t}` } get _strokeCircumference() { return 2 * Math.PI * this._circleRadius } get _strokeDashOffset() { return "determinate" === this.mode ? this._strokeCircumference * (100 - this._value) / 100 : this._fallbackAnimation && "indeterminate" === this.mode ? .2 * this._strokeCircumference : null } get _circleStrokeWidth() { return this.strokeWidth / this.diameter * 100 } _attachStyleNode() { const e = this._styleRoot, n = this._diameter, i = t._diameters; let r = i.get(e); if (!r || !r.has(n)) { const t = this._document.createElement("style"); t.setAttribute("mat-spinner-animation", n + ""), t.textContent = this._getAnimationText(), e.appendChild(t), r || (r = new Set, i.set(e, r)), r.add(n) } } _getAnimationText() { return "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g, `${.95 * this._strokeCircumference}`).replace(/END_VALUE/g, `${.2 * this._strokeCircumference}`).replace(/DIAMETER/g, `${this.diameter}`) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(gb), Ao(ph, 8), Ao(pf, 8), Ao(ZP)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-progress-spinner"]], hostAttrs: ["role", "progressbar", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function (t, e) { 2 & t && (So("aria-valuemin", "determinate" === e.mode ? 0 : null)("aria-valuemax", "determinate" === e.mode ? 100 : null)("aria-valuenow", "determinate" === e.mode ? e.value : null)("mode", e.mode), ra("width", e.diameter, "px")("height", e.diameter, "px"), sa("_mat-animation-noopable", e._noopAnimations)) }, inputs: { color: "color", mode: "mode", diameter: "diameter", strokeWidth: "strokeWidth", value: "value" }, exportAs: ["matProgressSpinner"], features: [Ca], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function (t, e) { 1 & t && (kn(), Ro(0, "svg", 0), Eo(1, YP, 1, 9, "circle", 1), Eo(2, XP, 1, 7, "circle", 2), Mo()), 2 & t && (ra("width", e.diameter, "px")("height", e.diameter, "px"), Do("ngSwitch", "indeterminate" === e.mode), So("viewBox", e._viewBox), yr(1), Do("ngSwitchCase", !0), yr(1), Do("ngSwitchCase", !1)) }, directives: [Yh, Xh], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 }), t._diameters = new WeakMap, t })(), tD = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[sw, au], sw] }), t })(); const eD = ["primaryValueBar"]; class nD { constructor(t) { this._elementRef = t } } const iD = aw(nD, "primary"), rD = new Bt("mat-progress-bar-location", { providedIn: "root", factory: function () { const t = Qt(ph), e = t ? t.location : null; return { getPathname: () => e ? e.pathname + e.search : "" } } }); let sD = 0, oD = (() => { class t extends iD { constructor(t, e, n, i) { super(t), this._elementRef = t, this._ngZone = e, this._animationMode = n, this._isNoopAnimation = !1, this._value = 0, this._bufferValue = 0, this.animationEnd = new ql, this._animationEndSubscription = u.EMPTY, this.mode = "determinate", this.progressbarId = `mat-progress-bar-${sD++}`; const r = i ? i.getPathname().split("#")[0] : ""; this._rectangleFillValue = `url('${r}#${this.progressbarId}')`, this._isNoopAnimation = "NoopAnimations" === n } get value() { return this._value } set value(t) { this._value = aD(cb(t) || 0) } get bufferValue() { return this._bufferValue } set bufferValue(t) { this._bufferValue = aD(t || 0) } _primaryTransform() { return { transform: `scaleX(${this.value / 100})` } } _bufferTransform() { return "buffer" === this.mode ? { transform: `scaleX(${this.bufferValue / 100})` } : null } ngAfterViewInit() { this._ngZone.runOutsideAngular(() => { const t = this._primaryValueBar.nativeElement; this._animationEndSubscription = Vw(t, "transitionend").pipe(Of(e => e.target === t)).subscribe(() => { "determinate" !== this.mode && "buffer" !== this.mode || this._ngZone.run(() => this.animationEnd.next({ value: this.value })) }) }) } ngOnDestroy() { this._animationEndSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Lc), Ao(pf, 8), Ao(rD, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-progress-bar"]], viewQuery: function (t, e) { var n; 1 & t && rc(eD, !0), 2 & t && nc(n = cc()) && (e._primaryValueBar = n.first) }, hostAttrs: ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "mat-progress-bar"], hostVars: 4, hostBindings: function (t, e) { 2 & t && (So("aria-valuenow", "indeterminate" === e.mode || "query" === e.mode ? null : e.value)("mode", e.mode), sa("_mat-animation-noopable", e._isNoopAnimation)) }, inputs: { color: "color", mode: "mode", value: "value", bufferValue: "bufferValue" }, outputs: { animationEnd: "animationEnd" }, exportAs: ["matProgressBar"], features: [Ca], decls: 9, vars: 4, consts: [["width", "100%", "height", "4", "focusable", "false", 1, "mat-progress-bar-background", "mat-progress-bar-element"], ["x", "4", "y", "0", "width", "8", "height", "4", "patternUnits", "userSpaceOnUse", 3, "id"], ["cx", "2", "cy", "2", "r", "2"], ["width", "100%", "height", "100%"], [1, "mat-progress-bar-buffer", "mat-progress-bar-element", 3, "ngStyle"], [1, "mat-progress-bar-primary", "mat-progress-bar-fill", "mat-progress-bar-element", 3, "ngStyle"], ["primaryValueBar", ""], [1, "mat-progress-bar-secondary", "mat-progress-bar-fill", "mat-progress-bar-element"]], template: function (t, e) { 1 & t && (kn(), Ro(0, "svg", 0), Ro(1, "defs"), Ro(2, "pattern", 1), Lo(3, "circle", 2), Mo(), Mo(), Lo(4, "rect", 3), Mo(), En(), Lo(5, "div", 4), Lo(6, "div", 5, 6), Lo(8, "div", 7)), 2 & t && (yr(2), Do("id", e.progressbarId), yr(2), So("fill", e._rectangleFillValue), yr(1), Do("ngStyle", e._bufferTransform()), yr(1), Do("ngStyle", e._primaryTransform())) }, directives: [Qh], styles: ['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'], encapsulation: 2, changeDetection: 0 }), t })(); function aD(t, e = 0, n = 100) { return Math.max(e, Math.min(n, t)) } let lD = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[au, sw], sw] }), t })(), cD = 0, hD = (() => { class t { constructor() { this._stateChanges = new k, this._openCloseAllActions = new k, this.id = `cdk-accordion-${cD++}`, this._multi = !1 } get multi() { return this._multi } set multi(t) { this._multi = lb(t) } openAll() { this._openCloseAll(!0) } closeAll() { this._openCloseAll(!1) } ngOnChanges(t) { this._stateChanges.next(t) } ngOnDestroy() { this._stateChanges.complete() } _openCloseAll(t) { this.multi && this._openCloseAllActions.next(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["cdk-accordion"], ["", "cdkAccordion", ""]], inputs: { multi: "multi" }, exportAs: ["cdkAccordion"], features: [Ta] }), t })(), uD = 0, dD = (() => { class t { constructor(t, e, n) { this.accordion = t, this._changeDetectorRef = e, this._expansionDispatcher = n, this._openCloseAllSubscription = u.EMPTY, this.closed = new ql, this.opened = new ql, this.destroyed = new ql, this.expandedChange = new ql, this.id = `cdk-accordion-child-${uD++}`, this._expanded = !1, this._disabled = !1, this._removeUniqueSelectionListener = () => { }, this._removeUniqueSelectionListener = n.listen((t, e) => { this.accordion && !this.accordion.multi && this.accordion.id === e && this.id !== t && (this.expanded = !1) }), this.accordion && (this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions()) } get expanded() { return this._expanded } set expanded(t) { t = lb(t), this._expanded !== t && (this._expanded = t, this.expandedChange.emit(t), t ? (this.opened.emit(), this._expansionDispatcher.notify(this.id, this.accordion ? this.accordion.id : this.id)) : this.closed.emit(), this._changeDetectorRef.markForCheck()) } get disabled() { return this._disabled } set disabled(t) { this._disabled = lb(t) } ngOnDestroy() { this.opened.complete(), this.closed.complete(), this.destroyed.emit(), this.destroyed.complete(), this._removeUniqueSelectionListener(), this._openCloseAllSubscription.unsubscribe() } toggle() { this.disabled || (this.expanded = !this.expanded) } close() { this.disabled || (this.expanded = !1) } open() { this.disabled || (this.expanded = !0) } _subscribeToOpenCloseAllActions() { return this.accordion._openCloseAllActions.subscribe(t => { this.disabled || (this.expanded = t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(hD, 12), Ao(Ws), Ao(Yx)) }, t.\u0275dir = we({ type: t, selectors: [["cdk-accordion-item"], ["", "cdkAccordionItem", ""]], inputs: { expanded: "expanded", disabled: "disabled" }, outputs: { closed: "closed", opened: "opened", destroyed: "destroyed", expandedChange: "expandedChange" }, exportAs: ["cdkAccordionItem"], features: [ja([{ provide: hD, useValue: void 0 }])] }), t })(), pD = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) } }), t })(); const fD = ["body"]; function mD(t, e) { } const gD = [[["mat-expansion-panel-header"]], "*", [["mat-action-row"]]], yD = ["mat-expansion-panel-header", "*", "mat-action-row"], _D = function (t, e) { return { collapsedHeight: t, expandedHeight: e } }, vD = function (t, e) { return { value: t, params: e } }; function bD(t, e) { 1 & t && Lo(0, "span", 2), 2 & t && Do("@indicatorRotate", Go()._getExpandedState()) } const wD = [[["mat-panel-title"]], [["mat-panel-description"]], "*"], xD = ["mat-panel-title", "mat-panel-description", "*"], CD = new Bt("MAT_ACCORDION"), SD = { indicatorRotate: qu("indicatorRotate", [Ku("collapsed, void", Xu({ transform: "rotate(0deg)" })), Ku("expanded", Xu({ transform: "rotate(180deg)" })), Zu("expanded <=> collapsed, void => collapsed", Wu("225ms cubic-bezier(0.4,0.0,0.2,1)"))]), expansionHeaderHeight: qu("expansionHeight", [Ku("collapsed, void", Xu({ height: "{{collapsedHeight}}" }), { params: { collapsedHeight: "48px" } }), Ku("expanded", Xu({ height: "{{expandedHeight}}" }), { params: { expandedHeight: "64px" } }), Zu("expanded <=> collapsed, void => collapsed", Gu([td("@indicatorRotate", Ju(), { optional: !0 }), Wu("225ms cubic-bezier(0.4,0.0,0.2,1)")]))]), bodyExpansion: qu("bodyExpansion", [Ku("collapsed, void", Xu({ height: "0px", visibility: "hidden" })), Ku("expanded", Xu({ height: "*", visibility: "visible" })), Zu("expanded <=> collapsed, void => collapsed", Wu("225ms cubic-bezier(0.4,0.0,0.2,1)"))]) }; let kD = (() => { class t { constructor(t) { this._template = t } } return t.\u0275fac = function (e) { return new (e || t)(Ao(pl)) }, t.\u0275dir = we({ type: t, selectors: [["ng-template", "matExpansionPanelContent", ""]] }), t })(), ED = 0; const OD = new Bt("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS"); let AD = (() => { class t extends dD { constructor(t, e, n, i, r, s, o) { super(t, e, n), this._viewContainerRef = i, this._animationMode = s, this._hideToggle = !1, this.afterExpand = new ql, this.afterCollapse = new ql, this._inputChanges = new k, this._headerId = `mat-expansion-panel-header-${ED++}`, this._bodyAnimationDone = new k, this.accordion = t, this._document = r, this._bodyAnimationDone.pipe(jx((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => { "void" !== t.fromState && ("expanded" === t.toState ? this.afterExpand.emit() : "collapsed" === t.toState && this.afterCollapse.emit()) }), o && (this.hideToggle = o.hideToggle) } get hideToggle() { return this._hideToggle || this.accordion && this.accordion.hideToggle } set hideToggle(t) { this._hideToggle = lb(t) } get togglePosition() { return this._togglePosition || this.accordion && this.accordion.togglePosition } set togglePosition(t) { this._togglePosition = t } _hasSpacing() { return !!this.accordion && this.expanded && "default" === this.accordion.displayMode } _getExpandedState() { return this.expanded ? "expanded" : "collapsed" } toggle() { this.expanded = !this.expanded } close() { this.expanded = !1 } open() { this.expanded = !0 } ngAfterContentInit() { this._lazyContent && this.opened.pipe(em(null), Of(() => this.expanded && !this._portal), qf(1)).subscribe(() => { this._portal = new nC(this._lazyContent._template, this._viewContainerRef) }) } ngOnChanges(t) { this._inputChanges.next(t) } ngOnDestroy() { super.ngOnDestroy(), this._bodyAnimationDone.complete(), this._inputChanges.complete() } _containsFocus() { if (this._body) { const t = this._document.activeElement, e = this._body.nativeElement; return t === e || e.contains(t) } return !1 } } return t.\u0275fac = function (e) { return new (e || t)(Ao(CD, 12), Ao(Ws), Ao(Yx), Ao(ml), Ao(ph), Ao(pf, 8), Ao(OD, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-expansion-panel"]], contentQueries: function (t, e, n) { var i; 1 & t && oc(n, kD, !0), 2 & t && nc(i = cc()) && (e._lazyContent = i.first) }, viewQuery: function (t, e) { var n; 1 & t && rc(fD, !0), 2 & t && nc(n = cc()) && (e._body = n.first) }, hostAttrs: [1, "mat-expansion-panel"], hostVars: 6, hostBindings: function (t, e) { 2 & t && sa("mat-expanded", e.expanded)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-expansion-panel-spacing", e._hasSpacing()) }, inputs: { disabled: "disabled", expanded: "expanded", hideToggle: "hideToggle", togglePosition: "togglePosition" }, outputs: { opened: "opened", closed: "closed", expandedChange: "expandedChange", afterExpand: "afterExpand", afterCollapse: "afterCollapse" }, exportAs: ["matExpansionPanel"], features: [ja([{ provide: CD, useValue: void 0 }]), Ca, Ta], ngContentSelectors: yD, decls: 7, vars: 4, consts: [["role", "region", 1, "mat-expansion-panel-content", 3, "id"], ["body", ""], [1, "mat-expansion-panel-body"], [3, "cdkPortalOutlet"]], template: function (t, e) { 1 & t && (Xo(gD), Ko(0), Ro(1, "div", 0, 1), Ho("@bodyExpansion.done", (function (t) { return e._bodyAnimationDone.next(t) })), Ro(3, "div", 2), Ko(4, 1), Eo(5, mD, 0, 0, "ng-template", 3), Mo(), Ko(6, 2), Mo()), 2 & t && (yr(1), Do("@bodyExpansion", e._getExpandedState())("id", e.id), So("aria-labelledby", e._headerId), yr(4), Do("cdkPortalOutlet", e._portal)) }, directives: [oC], styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);position:relative}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base,.mat-action-row button.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base,[dir=rtl] .mat-action-row button.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [SD.bodyExpansion] }, changeDetection: 0 }), t })(), TD = (() => { class t { constructor(t, e, n, i, r) { this.panel = t, this._element = e, this._focusMonitor = n, this._changeDetectorRef = i, this._parentChangeSubscription = u.EMPTY, this._animationsDisabled = !0; const s = t.accordion ? t.accordion._stateChanges.pipe(Of(t => !(!t.hideToggle && !t.togglePosition))) : Cf; this._parentChangeSubscription = G(t.opened, t.closed, s, t._inputChanges.pipe(Of(t => !!(t.hideToggle || t.disabled || t.togglePosition)))).subscribe(() => this._changeDetectorRef.markForCheck()), t.closed.pipe(Of(() => t._containsFocus())).subscribe(() => n.focusVia(e, "program")), n.monitor(e).subscribe(e => { e && t.accordion && t.accordion._handleHeaderFocus(this) }), r && (this.expandedHeight = r.expandedHeight, this.collapsedHeight = r.collapsedHeight) } _animationStarted() { this._animationsDisabled = !1 } get disabled() { return this.panel.disabled } _toggle() { this.disabled || this.panel.toggle() } _isExpanded() { return this.panel.expanded } _getExpandedState() { return this.panel._getExpandedState() } _getPanelId() { return this.panel.id } _getTogglePosition() { return this.panel.togglePosition } _showToggle() { return !this.panel.hideToggle && !this.panel.disabled } _keydown(t) { switch (t.keyCode) { case 32: case 13: Zv(t) || (t.preventDefault(), this._toggle()); break; default: return void (this.panel.accordion && this.panel.accordion._handleHeaderKeydown(t)) } } focus(t = "program", e) { this._focusMonitor.focusVia(this._element, t, e) } ngOnDestroy() { this._parentChangeSubscription.unsubscribe(), this._focusMonitor.stopMonitoring(this._element) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(AD, 1), Ao(Ua), Ao(Hb), Ao(Ws), Ao(OD, 8)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-expansion-panel-header"]], hostAttrs: ["role", "button", 1, "mat-expansion-panel-header", "mat-focus-indicator"], hostVars: 19, hostBindings: function (t, e) { 1 & t && (Uo("@expansionHeight.start", (function () { return e._animationStarted() })), Ho("click", (function () { return e._toggle() }))("keydown", (function (t) { return e._keydown(t) }))), 2 & t && (So("id", e.panel._headerId)("tabindex", e.disabled ? -1 : 0)("aria-controls", e._getPanelId())("aria-expanded", e._isExpanded())("aria-disabled", e.panel.disabled), wa("@.disabled", e._animationsDisabled)("@expansionHeight", Fl(16, vD, e._getExpandedState(), Fl(13, _D, e.collapsedHeight, e.expandedHeight))), sa("mat-expanded", e._isExpanded())("mat-expansion-toggle-indicator-after", "after" === e._getTogglePosition())("mat-expansion-toggle-indicator-before", "before" === e._getTogglePosition())) }, inputs: { expandedHeight: "expandedHeight", collapsedHeight: "collapsedHeight" }, ngContentSelectors: xD, decls: 5, vars: 1, consts: [[1, "mat-content"], ["class", "mat-expansion-indicator", 4, "ngIf"], [1, "mat-expansion-indicator"]], template: function (t, e) { 1 & t && (Xo(wD), Ro(0, "span", 0), Ko(1), Ko(2, 1), Ko(3, 2), Mo(), Eo(4, bD, 1, 1, "span", 1)), 2 & t && (yr(4), Do("ngIf", e._showToggle())) }, directives: [$h], styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;position:relative}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}\n'], encapsulation: 2, data: { animation: [SD.indicatorRotate, SD.expansionHeaderHeight] }, changeDetection: 0 }), t })(), PD = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-panel-description"]], hostAttrs: [1, "mat-expansion-panel-header-description"] }), t })(), DD = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-panel-title"]], hostAttrs: [1, "mat-expansion-panel-header-title"] }), t })(), ID = (() => { class t extends hD { constructor() { super(...arguments), this._ownHeaders = new Gl, this._hideToggle = !1, this.displayMode = "default", this.togglePosition = "after" } get hideToggle() { return this._hideToggle } set hideToggle(t) { this._hideToggle = lb(t) } ngAfterContentInit() { this._headers.changes.pipe(em(this._headers)).subscribe(t => { this._ownHeaders.reset(t.filter(t => t.panel.accordion === this)), this._ownHeaders.notifyOnChanges() }), this._keyManager = new Lb(this._ownHeaders).withWrap() } _handleHeaderKeydown(t) { const { keyCode: e } = t, n = this._keyManager; 36 === e ? Zv(t) || (n.setFirstItemActive(), t.preventDefault()) : 35 === e ? Zv(t) || (n.setLastItemActive(), t.preventDefault()) : this._keyManager.onKeydown(t) } _handleHeaderFocus(t) { this._keyManager.updateActiveItem(t) } } return t.\u0275fac = function (e) { return RD(e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-accordion"]], contentQueries: function (t, e, n) { var i; 1 & t && oc(n, TD, !0), 2 & t && nc(i = cc()) && (e._headers = i) }, hostAttrs: [1, "mat-accordion"], hostVars: 2, hostBindings: function (t, e) { 2 & t && sa("mat-accordion-multi", e.multi) }, inputs: { multi: "multi", displayMode: "displayMode", togglePosition: "togglePosition", hideToggle: "hideToggle" }, exportAs: ["matAccordion"], features: [ja([{ provide: CD, useExisting: t }]), Ca] }), t })(); const RD = hi(ID); let MD = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[au, pD, aC]] }), t })(); function LD(t, e) { 1 & t && Lo(0, "mat-progress-spinner", 3), 2 & t && Do("diameter", 45) } function FD(t, e) { if (1 & t && (Ro(0, "div", 4), Ro(1, "mat-card", 5), Ro(2, "h1", 6), Lo(3, "fa-icon", 7), ga(4, " Account not found "), Mo(), Ro(5, "div"), ga(6, "We couldn't find the account "), Ro(7, "strong"), ga(8), Mo(), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(3), Do("icon", t.faSadTear), yr(5), ya(t.accountName) } } const ND = function (t) { return ["/account", t] }; function VD(t, e) { if (1 & t && (Ro(0, "div", 67), Ro(1, "strong"), ga(2, "Created by: "), Mo(), Ro(3, "a", 68), ga(4), Mo(), Mo()), 2 & t) { const t = Go(2); yr(3), Do("routerLink", Ll(2, ND, t.creationData.creator)), yr(1), ya(t.creationData.creator) } } function jD(t, e) { if (1 & t && (Ro(0, "div", 67), Ro(1, "strong"), ga(2, "Created on: "), Mo(), Ro(3, "span", 14), ga(4), Mo(), Mo()), 2 & t) { const t = Go(2); yr(4), ya(t.formatDate(t.creationData.timestamp)) } } function BD(t, e) { if (1 & t && (Ro(0, "div", 71), Ro(1, "div", 72), Ro(2, "div", 73), ga(3), Mo(), Ro(4, "div", 74), ga(5), Bl(6, "number"), Ro(7, "span", 75), ga(8), Mo(), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(2), Do("routerLink", Ll(8, ND, t.contract)), yr(1), ya(t.contract), yr(1), Do("ngClass.lt-sm", "break-word"), yr(1), _a("", Hl(6, 5, t.amount, "1.0-" + (t.precision || 4)), " "), yr(3), ya(t.symbol) } } function zD(t, e) { if (1 & t && (Ro(0, "div", 69), Eo(1, BD, 9, 10, "div", 70), Mo()), 2 & t) { const t = Go(2); yr(1), Do("ngForOf", t.accountService.tokens) } } function HD(t, e) { 1 & t && (Ro(0, "div"), ga(1, "No tokens to display"), Mo()) } const UD = function (t) { return ["/key", t] }; function $D(t, e) { if (1 & t && (Ro(0, "div"), Ro(1, "div"), Ro(2, "strong", 81), ga(3), Mo(), Lo(4, "fa-icon", 82), Ro(5, "a", 83), ga(6), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); yr(3), va(" ", t.weight, "/", n.required_auth.threshold, " "), yr(1), Do("icon", i.faKey), yr(1), Do("routerLink", Ll(5, UD, t.key)), yr(1), _a("", t.key, " ") } } function qD(t, e) { if (1 & t && (Fo(0), Eo(1, $D, 7, 7, "div", 80), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", t.required_auth.keys) } } function WD(t, e) { if (1 & t && (Ro(0, "div"), Ro(1, "strong", 81), ga(2), Mo(), Lo(3, "fa-icon", 82), Ro(4, "a", 84), ga(5), Mo(), ga(6), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); yr(2), va(" ", t.weight, "/", n.required_auth.threshold, " "), yr(1), Do("icon", i.faUser), yr(1), Do("routerLink", Ll(6, ND, t.permission.actor)), yr(1), ya(t.permission.actor), yr(1), _a("@", t.permission.permission, " ") } } function GD(t, e) { if (1 & t && (Fo(0), Eo(1, WD, 7, 8, "div", 80), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", t.required_auth.accounts) } } function YD(t, e) { if (1 & t && (Ro(0, "div"), Ro(1, "strong", 81), ga(2), Mo(), Lo(3, "fa-icon", 82), Ro(4, "span", 85), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); yr(2), va(" ", t.weight, "/", n.required_auth.threshold, " "), yr(1), Do("icon", i.faClock), yr(2), _a("", t.wait_sec, "s") } } function XD(t, e) { if (1 & t && (Fo(0), Eo(1, YD, 6, 4, "div", 80), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", t.required_auth.waits) } } function KD(t, e) { if (1 & t && (Ro(0, "mat-tree-node", 76), Lo(1, "button", 77), Ro(2, "div", 78), Ro(3, "div"), Ro(4, "h3", 79), ga(5), Mo(), Mo(), Eo(6, qD, 2, 1, "ng-container", 36), Eo(7, GD, 2, 1, "ng-container", 36), Eo(8, XD, 2, 1, "ng-container", 36), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(5), ya(t.perm_name), yr(1), Do("ngIf", t.required_auth.keys.length > 0), yr(1), Do("ngIf", t.required_auth.accounts.length > 0), yr(1), Do("ngIf", t.required_auth.waits.length > 0) } } function QD(t, e) { if (1 & t && (Ro(0, "div"), Ro(1, "div"), Ro(2, "strong", 81), ga(3), Mo(), Lo(4, "fa-icon", 82), Ro(5, "a", 83), ga(6), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); yr(3), va(" ", t.weight, "/", n.required_auth.threshold, " "), yr(1), Do("icon", i.faKey), yr(1), Do("routerLink", Ll(5, UD, t.key)), yr(1), _a("", t.key, " ") } } function ZD(t, e) { if (1 & t && (Fo(0), Eo(1, QD, 7, 7, "div", 80), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", t.required_auth.keys) } } function JD(t, e) { if (1 & t && (Ro(0, "div"), Ro(1, "strong", 81), ga(2), Mo(), Lo(3, "fa-icon", 82), Ro(4, "a", 84), ga(5), Mo(), ga(6), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); yr(2), va(" ", t.weight, "/", n.required_auth.threshold, " "), yr(1), Do("icon", i.faUser), yr(1), Do("routerLink", Ll(6, ND, t.permission.actor)), yr(1), ya(t.permission.actor), yr(1), _a("@", t.permission.permission, " ") } } function tI(t, e) { if (1 & t && (Fo(0), Eo(1, JD, 7, 8, "div", 80), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", t.required_auth.accounts) } } function eI(t, e) { if (1 & t && (Ro(0, "div"), Ro(1, "strong", 81), ga(2), Mo(), Lo(3, "fa-icon", 82), Ro(4, "span", 85), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); yr(2), va(" ", t.weight, "/", n.required_auth.threshold, " "), yr(1), Do("icon", i.faClock), yr(2), _a("", t.wait_sec, "s") } } function nI(t, e) { if (1 & t && (Fo(0), Eo(1, eI, 6, 4, "div", 80), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", t.required_auth.waits) } } function iI(t, e) { if (1 & t && (Ro(0, "mat-tree-node", 76), Ro(1, "button", 86), Lo(2, "fa-icon", 82), Mo(), Ro(3, "div", 78), Ro(4, "div"), Ro(5, "h3", 79), ga(6), Mo(), Mo(), Eo(7, ZD, 2, 1, "ng-container", 36), Eo(8, tI, 2, 1, "ng-container", 36), Eo(9, nI, 2, 1, "ng-container", 36), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2); yr(2), Do("icon", n.treeControl.isExpanded(t) ? n.faChevronDown : n.faChevronRight), yr(4), ya(t.perm_name), yr(1), Do("ngIf", t.required_auth.keys.length > 0), yr(1), Do("ngIf", t.required_auth.accounts.length > 0), yr(1), Do("ngIf", t.required_auth.waits.length > 0) } } function rI(t, e) { if (1 & t && (Ro(0, "span"), ga(1, "proxy "), Ro(2, "a", 92), ga(3), Mo(), Mo()), 2 & t) { const t = Go(4); yr(2), Do("routerLink", Ll(2, ND, t.accountService.account.voter_info.proxy)), yr(1), ya(t.accountService.account.voter_info.proxy) } } function sI(t, e) { 1 & t && (Ro(0, "span"), ga(1, "s"), Mo()) } function oI(t, e) { if (1 & t && (Ro(0, "span"), Ro(1, "strong"), ga(2), Mo(), ga(3, " producer"), Eo(4, sI, 2, 0, "span", 36), Mo()), 2 & t) { const t = Go(4); yr(2), ya(t.accountService.account.voter_info.producers.length), yr(2), Do("ngIf", t.accountService.account.voter_info.producers.length > 1) } } function aI(t, e) { if (1 & t && (Ro(0, "div"), ga(1), Eo(2, rI, 4, 4, "span", 36), Eo(3, oI, 5, 2, "span", 36), Mo()), 2 & t) { const t = Go(3); yr(1), _a(" ", t.accountService.account.account_name, " is voting in "), yr(1), Do("ngIf", t.accountService.account.voter_info.proxy), yr(1), Do("ngIf", t.accountService.account.voter_info.producers.length > 0) } } function lI(t, e) { 1 & t && (Ro(0, "span"), ga(1, ", "), Mo()) } function cI(t, e) { if (1 & t && (Ro(0, "span"), Ro(1, "a", 92), ga(2), Mo(), Eo(3, lI, 2, 0, "span", 36), Mo()), 2 & t) { const t = e.$implicit, n = e.last; yr(1), Do("routerLink", Ll(3, ND, t)), yr(1), ya(t), yr(1), Do("ngIf", !n) } } function hI(t, e) { if (1 & t && (Ro(0, "div"), Eo(1, cI, 4, 5, "span", 80), Mo()), 2 & t) { const t = Go(3); yr(1), Do("ngForOf", t.accountService.account.voter_info.producers) } } function uI(t, e) { if (1 & t && (Ro(0, "mat-accordion", 87), Ro(1, "mat-expansion-panel", 88), Ro(2, "mat-expansion-panel-header"), Ro(3, "mat-panel-title"), Ro(4, "h3", 89), Ro(5, "fa-layers", 31), Lo(6, "fa-icon", 32), Lo(7, "fa-icon", 90), Mo(), ga(8, " Votes "), Mo(), Mo(), Ro(9, "mat-panel-description", 91), Eo(10, aI, 4, 3, "div", 36), Mo(), Mo(), Eo(11, hI, 2, 1, "div", 36), Mo(), Mo()), 2 & t) { const t = Go(2); yr(1), Do("disabled", t.accountService.account.voter_info.producers.length <= 0)("hideToggle", t.accountService.account.voter_info.producers.length <= 0), yr(4), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faVote)("inverse", !0), yr(3), Do("ngIf", t.accountService.account.voter_info), yr(1), Do("ngIf", t.accountService.account.voter_info.producers.length > 0) } } const dI = function () { return { "min-width": "100px" } }; function pI(t, e) { 1 & t && (Ro(0, "th", 93), ga(1, " TX"), Mo()), 2 & t && Do("ngStyle.gt-xs", Ml(1, dI)) } function fI(t, e) { if (1 & t && (Ro(0, "span", 96), Lo(1, "fa-icon", 97), ga(2), Mo()), 2 & t) { const t = Go().$implicit, e = Go(2); yr(1), Do("icon", e.faClock), yr(1), _a(" ", (t.block_num - e.accountService.libNum) / 2, "s ") } } const mI = function (t) { return ["/transaction", t] }; function gI(t, e) { if (1 & t && (Ro(0, "td", 94), Eo(1, fI, 3, 2, "span", 95), Ro(2, "a", 92), ga(3), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2); yr(1), Do("ngIf", n.accountService.libNum < t.block_num), yr(1), Do("routerLink", Ll(3, mI, t.trx_id)), yr(1), _a(" ", t.trx_id.slice(0, 8), "... ") } } const yI = function () { return { "padding-left": "14px", "padding-right": "14px", "min-width": "100px" } }, _I = function () { return { "min-width": "240px" } }; function vI(t, e) { 1 & t && (Ro(0, "th", 98), ga(1, " Action "), Mo()), 2 & t && Do("ngStyle.gt-xs", Ml(2, yI))("ngStyle.gt-sm", Ml(3, _I)) } const bI = function () { return { "padding-left": "14px", "padding-right": "14px" } }, wI = function () { return { padding: "0" } }; function xI(t, e) { if (1 & t && (Ro(0, "td", 99), Ro(1, "span", 100), Ro(2, "span", 101), ga(3), Mo(), ga(4, " on "), Ro(5, "span", 102), ga(6), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(6, bI)), yr(1), Do("ngStyle.lt-md", Ml(7, wI))("ngClass.gt-sm", "action-border"), yr(2), ya(t.act.name), yr(2), Do("routerLink", Ll(8, ND, t.act.account)), yr(1), _a(" ", t.act.account, " ") } } function CI(t, e) { 1 & t && (Ro(0, "th", 103), ga(1, " Data"), Mo()) } function SI(t, e) { if (1 & t && (Fo(0), Ro(1, "div", 110), Ro(2, "span", 111), ga(3), Mo(), Mo(), No()), 2 & t) { const t = Go().$implicit; yr(3), _a("\u2022 ", t, "") } } const kI = function (t) { return { "data-item": t } }; function EI(t, e) { if (1 & t && (Ro(0, "div", 107), Ro(1, "span", 112), ga(2), Mo(), ga(3, ": "), Ro(4, "span", 111), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(6); Do("ngClass", Ll(3, kI, i.objectKeyCount(n) > 1)), yr(2), _a(" ", t.key, ""), yr(3), ya(t.value) } } function OI(t, e) { if (1 & t && (Fo(0), Eo(1, EI, 6, 5, "div", 105), Bl(2, "keyvalue"), No()), 2 & t) { const t = Go().$implicit; yr(1), Do("ngForOf", zl(2, 1, t)) } } function AI(t, e) { if (1 & t && (Ro(0, "div", 109), Eo(1, SI, 4, 1, "ng-container", 36), Eo(2, OI, 3, 3, "ng-container", 36), Mo()), 2 & t) { const t = e.$implicit, n = Go(6); yr(1), Do("ngIf", "string" === n.getType(t)), yr(1), Do("ngIf", "object" === n.getType(t)) } } function TI(t, e) { if (1 & t && (Fo(0), Ro(1, "span", 48), ga(2), Mo(), ga(3, ": "), Eo(4, AI, 3, 2, "div", 108), No()), 2 & t) { const t = Go().$implicit; yr(2), va("", t.key, " [", t.value.length, "]"), yr(2), Do("ngForOf", t.value) } } function PI(t, e) { if (1 & t && (Ro(0, "span", 111), ga(1), Mo()), 2 & t) { const t = Go(2).$implicit; yr(1), ya(t.value) } } function DI(t, e) { 1 & t && (Ro(0, "span", 114), ga(1, "empty"), Mo()) } function II(t, e) { if (1 & t && (Fo(0), Ro(1, "span", 48), ga(2), Mo(), ga(3, ": "), Eo(4, PI, 2, 1, "span", 113), Eo(5, DI, 2, 0, "span", 106), No()), 2 & t) { const t = Go().$implicit; yr(2), ya(t.key), yr(2), Do("ngIf", t.value), yr(1), Do("ngIf", !t.value) } } function RI(t, e) { if (1 & t && (Ro(0, "div", 107), Eo(1, TI, 5, 3, "ng-container", 36), Eo(2, II, 6, 3, "ng-container", 36), Mo()), 2 & t) { const t = e.$implicit, n = Go(2).$implicit, i = Go(2); Do("ngClass", Ll(3, kI, i.objectKeyCount(n.act.data) > 1)), yr(1), Do("ngIf", i.isArray(t.value)), yr(1), Do("ngIf", !i.isArray(t.value)) } } function MI(t, e) { if (1 & t && (Ro(0, "span", 114), ga(1), Mo()), 2 & t) { const t = Go(2).$implicit; yr(1), _a(" ", t.act.data, " ") } } function LI(t, e) { if (1 & t && (Fo(0), Eo(1, RI, 3, 5, "div", 105), Bl(2, "keyvalue"), Eo(3, MI, 2, 1, "span", 106), No()), 2 & t) { const t = Go().$implicit, e = Go(2); yr(1), Do("ngForOf", zl(2, 2, t.act.data)), yr(2), Do("ngIf", "string" === e.getType(t.act.data)) } } function FI(t, e) { 1 & t && Vo(0) } const NI = function () { return { padding: "10px 10px 7px 0" } }; function VI(t, e) { if (1 & t && (Ro(0, "td", 104), Eo(1, LI, 4, 4, "ng-container", 36), Eo(2, FI, 1, 0, "ng-container", 36), Mo()), 2 & t) { const t = Go(2); Do("ngStyle.gt-xs", Ml(3, NI)), yr(1), Do("ngIf", t.detailedView), yr(1), Do("ngIf", !t.detailedView) } } const jI = function () { return { "min-width": "70px" } }; function BI(t, e) { 1 & t && (Ro(0, "th", 115), ga(1, "Block & Date"), Mo()), 2 & t && Do("ngStyle.gt-xs", Ml(1, jI)) } const zI = function (t) { return ["/block", t] }; function HI(t, e) { if (1 & t && (Ro(0, "td", 116), Ro(1, "a", 92), ga(2), Mo(), Lo(3, "br"), Ro(4, "span"), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2); yr(1), Do("routerLink", Ll(3, zI, t.block_num)), yr(1), ya(t.block_num), yr(3), _a(" ", n.formatDate(t["@timestamp"]), "") } } function UI(t, e) { 1 & t && Lo(0, "tr", 117) } function $I(t, e) { 1 & t && Lo(0, "tr", 118) } const qI = function (t, e) { return { pulse: t, "red-dot": e } }, WI = function () { return [10, 20, 50, 100] }; function GI(t, e) { if (1 & t) { const t = jo(); Ro(0, "div", 8), Ro(1, "mat-card", 9), Ro(2, "h2", 10), Lo(3, "fa-icon", 7), ga(4), Mo(), Ro(5, "div", 11), Ro(6, "div", 12), Ro(7, "div", 13), Ro(8, "strong"), ga(9, "Total Balance: "), Mo(), Ro(10, "span", 14), ga(11), Bl(12, "number"), Mo(), Mo(), Ro(13, "div", 15), Ro(14, "strong"), ga(15, "Liquid Balance: "), Mo(), Ro(16, "span", 14), ga(17), Bl(18, "number"), Mo(), Mo(), Ro(19, "div", 15), Ro(20, "strong"), ga(21, "Staked Balance: "), Mo(), Ro(22, "span", 14), ga(23), Bl(24, "number"), Mo(), Mo(), Ro(25, "div", 5), Ro(26, "strong"), ga(27, "Refunding: "), Mo(), Ro(28, "span", 14), ga(29), Bl(30, "number"), Mo(), Mo(), Ro(31, "div", 16), Eo(32, VD, 5, 4, "div", 17), Eo(33, jD, 5, 1, "div", 17), Mo(), Mo(), Ro(34, "div", 18), Ro(35, "div", 19), Ro(36, "div"), Ro(37, "span", 20), ga(38, "CPU"), Mo(), Ro(39, "span", 21), ga(40), Bl(41, "number"), Mo(), Ro(42, "span", 22), ga(43), Mo(), Mo(), Lo(44, "mat-progress-bar", 23), Ro(45, "div", 24), Ro(46, "div", 25), Ro(47, "span"), ga(48, "Self-staked:"), Mo(), Ro(49, "span", 14), ga(50), Bl(51, "number"), Mo(), Mo(), Ro(52, "div", 25), Ro(53, "span"), ga(54, "Staked by others:"), Mo(), Ro(55, "span", 14), ga(56), Bl(57, "number"), Mo(), Mo(), Ro(58, "div"), Ro(59, "span"), ga(60, "Total in CPU:"), Mo(), Ro(61, "span", 14), ga(62), Bl(63, "number"), Mo(), Mo(), Mo(), Mo(), Ro(64, "div", 26), Ro(65, "div"), Ro(66, "span", 20), ga(67, "NET"), Mo(), Ro(68, "span", 21), ga(69), Bl(70, "number"), Mo(), Ro(71, "span", 22), ga(72), Mo(), Mo(), Lo(73, "mat-progress-bar", 23), Ro(74, "div", 24), Ro(75, "div", 25), Ro(76, "span"), ga(77, "Self-staked:"), Mo(), Ro(78, "span", 14), ga(79), Bl(80, "number"), Mo(), Mo(), Ro(81, "div", 25), Ro(82, "span"), ga(83, "Staked by others:"), Mo(), Ro(84, "span", 14), ga(85), Bl(86, "number"), Mo(), Mo(), Ro(87, "div"), Ro(88, "span"), ga(89, "Total in NET:"), Mo(), Ro(90, "span", 14), ga(91), Bl(92, "number"), Mo(), Mo(), Mo(), Mo(), Ro(93, "div", 27), Ro(94, "div"), Ro(95, "span", 28), ga(96, "RAM"), Mo(), Ro(97, "span", 21), ga(98), Bl(99, "number"), Mo(), Ro(100, "span", 22), ga(101), Mo(), Mo(), Lo(102, "mat-progress-bar", 23), Mo(), Mo(), Mo(), Mo(), Ro(103, "div", 29), Ro(104, "mat-card", 30), Ro(105, "h3"), Ro(106, "fa-layers", 31), Lo(107, "fa-icon", 32), Lo(108, "fa-icon", 33), Mo(), ga(109, " Tokens "), Lo(110, "fa-icon", 34), Mo(), Eo(111, zD, 2, 1, "div", 35), Eo(112, HD, 2, 0, "div", 36), Mo(), Ro(113, "mat-card", 37), Ro(114, "h3"), Ro(115, "fa-layers", 31), Lo(116, "fa-icon", 32), Lo(117, "fa-icon", 33), Mo(), ga(118, " Permissions & Keys "), Mo(), Ro(119, "mat-tree", 38), Eo(120, KD, 9, 4, "mat-tree-node", 39), Eo(121, iI, 10, 5, "mat-tree-node", 40), Mo(), Mo(), Mo(), Eo(122, uI, 12, 8, "mat-accordion", 41), Ro(123, "mat-card", 42), Ro(124, "div", 43), Ro(125, "h3", 44), Ro(126, "fa-layers", 31), Lo(127, "fa-icon", 32), Lo(128, "fa-icon", 33), Mo(), ga(129, " Actions "), Mo(), Ro(130, "span", 45), ga(131, "Last Irreversible Block: "), Ro(132, "strong", 46), ga(133), Mo(), Mo(), Ro(134, "div", 47), Ho("click", (function () { return Ze(t), Go().accountService.toggleStreaming() })), ga(135, " action live streaming "), Ro(136, "span", 48), ga(137), Mo(), Lo(138, "span", 49), Mo(), Mo(), Ro(139, "table", 50), Fo(140, 51), Eo(141, pI, 2, 2, "th", 52), Eo(142, gI, 4, 5, "td", 53), No(), Fo(143, 54), Eo(144, vI, 2, 4, "th", 55), Eo(145, xI, 7, 10, "td", 56), No(), Fo(146, 57), Eo(147, CI, 2, 0, "th", 58), Eo(148, VI, 3, 4, "td", 59), No(), Fo(149, 60), Eo(150, BI, 2, 2, "th", 61), Eo(151, HI, 6, 5, "td", 62), No(), Eo(152, UI, 1, 0, "tr", 63), Eo(153, $I, 1, 0, "tr", 64), Mo(), Ro(154, "mat-paginator", 65), Ho("page", (function (e) { return Ze(t), Go().changePage(e) })), Mo(), Ro(155, "button", 66), Ho("click", (function () { Ze(t); const e = Go(); return e.accountService.loadMoreActions(e.accountName) })), ga(156, " load more actions "), Mo(), Mo(), Mo() } if (2 & t) { const t = Go(); yr(3), Do("icon", t.faUserCircle), yr(1), _a(" ", t.accountService.account.account_name, " "), yr(7), va("", Hl(12, 64, t.totalBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(18, 67, t.liquidBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(24, 70, t.stakedBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(30, 73, t.refundBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(3), Do("ngIf", t.creationData && t.creationData.creator), yr(1), Do("ngIf", t.creationData && t.creationData.timestamp), yr(7), _a("", Hl(41, 76, t.accountService.account.cpu_limit.used / t.accountService.account.cpu_limit.max * 100, "1.0-2"), "% used"), yr(3), va("", t.convertMicroS(t.accountService.account.cpu_limit.used), " / ", t.convertMicroS(t.accountService.account.cpu_limit.max), " "), yr(1), Do("value", t.accountService.account.cpu_limit.used / t.accountService.account.cpu_limit.max * 100), yr(6), va("", Hl(51, 79, t.myCpuBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(57, 82, t.cpuByOthers(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(63, 85, t.cpuBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(7), _a("", Hl(70, 88, t.accountService.account.net_limit.used / t.accountService.account.net_limit.max * 100, "1.0-2"), "% used"), yr(3), va("", t.convertBytes(t.accountService.account.net_limit.used), " / ", t.convertBytes(t.accountService.account.net_limit.max), " "), yr(1), Do("value", t.accountService.account.net_limit.used / t.accountService.account.net_limit.max * 100), yr(6), va("", Hl(80, 91, t.myNetBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(86, 94, t.netByOthers(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(6), va("", Hl(92, 97, t.netBalance(), "1.0-" + t.systemPrecision), " ", t.systemSymbol, ""), yr(7), _a("", zl(99, 100, t.accountService.account.ram_usage / t.accountService.account.ram_quota * 100), "% used"), yr(3), va("", t.convertBytes(t.accountService.account.ram_usage), " / ", t.convertBytes(t.accountService.account.ram_quota), " "), yr(1), Do("value", t.accountService.account.ram_usage / t.accountService.account.ram_quota * 100), yr(4), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faStar)("inverse", !0), yr(2), Do("icon", t.faQuestionCircle), yr(1), Do("ngIf", t.accountService.tokens.length > 0), yr(1), Do("ngIf", !t.accountService.tokens || !t.accountService.tokens.length), yr(3), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faLink)("inverse", !0), yr(2), Do("dataSource", t.dataSource)("treeControl", t.treeControl), yr(2), Do("matTreeNodeDefWhen", t.hasChild), yr(1), Do("ngIf", t.accountService.account.voter_info && (t.accountService.account.voter_info.proxy || t.accountService.account.voter_info.producers.length > 0)), yr(4), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faHistory)("inverse", !0), yr(5), ya(t.accountService.libNum), yr(4), ya(t.accountService.streamClientStatus ? "enabled" : "disabled"), yr(1), Do("ngClass", Fl(102, qI, t.accountService.streamClientStatus, !t.accountService.streamClientStatus)), yr(1), Do("dataSource", t.accountService.tableDataSource), yr(13), Do("matHeaderRowDef", t.columnsToDisplay)("matHeaderRowDefSticky", !0), yr(1), Do("matRowDefColumns", t.columnsToDisplay), yr(1), Do("pageSizeOptions", Ml(105, WI))("length", t.accountService.tableDataSource.filteredData.length) } } let YI = (() => { class t { constructor(t, e, n, i) { this.activatedRoute = t, this.accountService = e, this.chainData = n, this.title = i, this.faClock = fT.faClock, this.faUserCircle = mT.faUserCircle, this.faCircle = gT.faCircle, this.faStar = yT.faStar, this.faLink = _T.faLink, this.faHistory = vT.faHistory, this.faChevronRight = qT.faChevronRight, this.faChevronDown = WT.faChevronDown, this.faSadTear = XT.faSadTear, this.faKey = GT.faKey, this.faUser = YT.faUser, this.faVote = WP.faVoteYea, this.faQuestionCircle = GP.faQuestionCircle, this.columnsToDisplay = ["trx_id", "action", "data", "block_num"], this.detailedView = !0, this.systemPrecision = 4, this.systemSymbol = "", this.creationData = { creator: void 0, timestamp: void 0 }, this.systemTokenContract = "lpc.token", this._transformer = (t, e) => Object.assign({ expandable: !!t.children && t.children.length > 0, perm_name: t.perm_name, level: e }, t), this.hasChild = (t, e) => e.expandable, this.treeControl = new bT(t => t.level, t => t.expandable), this.treeFlattener = new UT(this._transformer, t => t.level, t => t.expandable, t => t.children), this.dataSource = new $T(this.treeControl, this.treeFlattener) } ngOnDestroy() { console.log("ngOnDestroy"), this.accountService.disconnectStream() } objectKeyCount(t) { try { return Object.keys(t).length } catch (GM) { return 0 } } ngOnInit() { this.activatedRoute.params.subscribe(t => sS(this, void 0, void 0, (function* () { if (this.accountService.streamClientStatus && this.accountService.disconnectStream(), this.accountName = t.account_name, yield this.accountService.loadAccountData(t.account_name)) { this.title.setTitle(this.chainData.chainInfoData.chain_name ? `${this.accountName} \u2022 ${this.chainData.chainInfoData.chain_name} Hyperion Explorer` : `${this.accountName} \u2022 Hyperion Explorer`); const e = this.chainData.chainInfoData.custom_core_token; if (e && "" !== e) { const t = this.chainData.chainInfoData.custom_core_token.split("::"); this.systemSymbol = t[1], this.systemTokenContract = t[0]; const e = this.accountService.jsonData.tokens.find(t => t.symbol === this.systemSymbol && t.contract === this.systemTokenContract); e && (this.accountService.account.core_liquid_balance = e.amount + " " + this.systemSymbol) } else this.systemSymbol = this.getSymbol(this.accountService.account.core_liquid_balance); if (this.systemPrecision = this.getPrecision(this.accountService.account.core_liquid_balance), null === this.systemSymbol) try { this.systemSymbol = this.getSymbol(this.accountService.account.total_resources.cpu_weight), null === this.systemSymbol && (this.systemSymbol = "LPC") } catch (GM) { this.systemSymbol = "LPC" } this.processPermissions(), setTimeout(() => { this.accountService.tableDataSource.sort = this.sort, this.accountService.tableDataSource.paginator = this.paginator }, 500), this.creationData = yield this.accountService.getCreator(t.account_name) } }))) } getPrecision(t) { if (!t) return 4; try { return t.split(" ")[0].split(".")[1].length } catch (GM) { return 4 } } getSymbol(t) { if (!t) return null; try { return t.split(" ")[1] } catch (GM) { return null } } liquidBalance() { return this.accountService.account.core_liquid_balance ? parseFloat(this.accountService.account.core_liquid_balance.split(" ")[0]) : 0 } myCpuBalance() { return this.accountService.account.self_delegated_bandwidth ? parseFloat(this.accountService.account.self_delegated_bandwidth.cpu_weight.split(" ")[0]) : 0 } myNetBalance() { return this.accountService.account.self_delegated_bandwidth ? parseFloat(this.accountService.account.self_delegated_bandwidth.net_weight.split(" ")[0]) : 0 } cpuBalance() { return this.accountService.account.total_resources ? parseFloat(this.accountService.account.total_resources.cpu_weight.split(" ")[0]) : 0 } netBalance() { return this.accountService.account.total_resources ? parseFloat(this.accountService.account.total_resources.net_weight.split(" ")[0]) : 0 } totalBalance() { return this.liquidBalance() + this.myCpuBalance() + this.myNetBalance() } stakedBalance() { return this.myCpuBalance() + this.myNetBalance() } cpuByOthers() { return this.cpuBalance() - this.myCpuBalance() } netByOthers() { return this.netBalance() - this.myNetBalance() } stakedbyOthers() { return this.cpuBalance() + this.netBalance() - (this.myCpuBalance() + this.myNetBalance()) } refundBalance() { let t = 0, e = 0; return this.accountService.account.refund_request && (t = parseFloat(this.accountService.account.refund_request.cpu_amount.split(" ")[0]), e = parseFloat(this.accountService.account.refund_request.net_amount.split(" ")[0])), t + e } formatDate(t) { return new Date(t).toLocaleString() } getChildren(t, e) { return t.filter(t => t.parent === e).map(e => { const n = this.getChildren(t, e.perm_name); return n.length > 0 && (e.children = n), e }) } processPermissions() { if (this.accountService.account) { const t = this.accountService.account.permissions; if (t) try { this.dataSource.data = this.getChildren(t, ""), this.treeControl.expand(this.treeControl.dataNodes[0]), this.treeControl.expand(this.treeControl.dataNodes[1]) } catch (GM) { console.log(GM), this.dataSource.data = [] } } } isArray(t) { return "object" == typeof t && t.length > 0 } getType(t) { return typeof t } convertBytes(t) { return t > Math.pow(1024, 3) ? (t / Math.pow(1024, 3)).toFixed(2) + " GB" : t > Math.pow(1024, 2) ? (t / Math.pow(1024, 2)).toFixed(2) + " MB" : t > 1024 ? (t / 1024).toFixed(2) + " KB" : t + " bytes" } convertMicroS(t) { let e = 0, n = 0; const i = Math.pow(1e3, 2), r = 60 * i, s = 60 * r; return t > s ? (e = Math.floor(t / s), n = t % s, e + "h " + Math.round(n / r) + "min") : t > r ? (e = Math.floor(t / r), n = t % r, e + "min " + Math.round(n / i) + "s") : t > i ? (t / i).toFixed(2) + "s" : t > 1e3 ? (t / 1e3).toFixed(2) + "ms" : t + "\xb5s" } changePage(t) { this.accountService.streamClientStatus && this.accountService.toggleStreaming(); const e = Math.floor(t.length / t.pageSize); console.log(t), console.log(`${t.pageIndex} / ${e}`); try { t.pageIndex === e - 1 && this.accountService.loadMoreActions(this.accountName).catch(console.log) } catch (GM) { console.log(GM) } } } return t.\u0275fac = function (e) { return new (e || t)(Ao(vg), Ao(ck), Ao(uk), Ao(Uu)) }, t.\u0275cmp = me({ type: t, selectors: [["app-account"]], viewQuery: function (t, e) { var n; 1 & t && (rc(rT, !0), rc($P, !0)), 2 & t && (nc(n = cc()) && (e.sort = n.first), nc(n = cc()) && (e.paginator = n.first)) }, decls: 3, vars: 3, consts: [["mode", "indeterminate", 3, "diameter", 4, "ngIf"], ["class", "container", "fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", "style", "height: calc(100vh - 209px);", 4, "ngIf"], ["class", "container", "fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 4, "ngIf"], ["mode", "indeterminate", 3, "diameter"], ["fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 1, "container", 2, "height", "calc(100vh - 209px)"], [1, "width-100"], [1, "faded"], [2, "margin-right", "5px", 3, "icon"], ["fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 1, "container"], ["fxFlex", "100", "fxFlexFill", ""], [2, "letter-spacing", "1px"], ["fxLayout.gt-xs", "row", "fxLayoutAlign.gt-xs", "space-between start", "fxLayoutGap.gt-xs", "30px", "fxLayout.lt-sm", "column", "fxLayoutAlign.lt-sm", "start stretch", "fxLayoutGap.lt-sm", "20px"], ["fxLayout", "column", "fxLayoutAlign", "start start", "fxFlex.gt-xs", "316px", "fxFlexFill", "", 1, "mt-7", 2, "height", "100%"], [1, "total-balance", "width-100"], [1, "float-r"], [1, "mb-5", "width-100"], [1, "width-100", 2, "margin-top", "12px"], ["class", "mt-7 width-100", 4, "ngIf"], ["fxLayout", "row wrap", "fxLayoutAlign", "start start", "fxFlex", "grow"], ["fxFlex.gt-sm", "287px", "fxFlex.lt-md", "100", "ngStyle.gt-sm", "margin-right: 40px", 1, "full-width"], [1, "title"], [1, "faded", "used"], [1, "values", "float-r"], ["mode", "determinate", 1, "progress-bar", 3, "value"], [1, "small-info"], [1, "m-bottom"], ["fxFlex.gt-sm", "287px", "fxFlex.lt-md", "100", "ngClass.lt-md", "mt-30", 1, "full-width", "mt-responsive"], ["fxFlex", "100", 1, "mt-30"], [1, "title", "mt-6"], ["fxLayout.gt-sm", "row", "fxLayoutAlign.gt-sm", "space-between", "fxLayout.lt-md", "column", "fxLayoutAlign.lt-md", "start auto", "fxLayoutGap", "10px", "fxFlexFill", "", "fxFlex", "auto"], ["fxFlex.gt-sm", "25", "ngClass.gt-sm", "middle-card"], [2, "margin-right", "5px", 3, "fixedWidth"], ["transform", "grow-3", 3, "icon"], ["transform", "shrink-5", 3, "icon", "inverse"], ["matTooltip", "Only liquid balances are displayed", "matTooltipClass", "tooltip-bigger", 1, "faded", "float-r", "pointer", 3, "icon"], ["fxLayout.sm", "row wrap", "fxLayout.lt-sm", "column", "fxLayout.gt-sm", "column", "fxLayoutGap.sm", "43px", "fxLayoutGap.lt-sm", "10px", "fxLayoutGap.gt-sm", "10px", 4, "ngIf"], [4, "ngIf"], ["fxFlex.gt-sm", "75", "ngClass.gt-sm", "middle-card"], [3, "dataSource", "treeControl"], ["matTreeNodePadding", "", 4, "matTreeNodeDef"], ["matTreeNodePadding", "", 4, "matTreeNodeDef", "matTreeNodeDefWhen"], ["class", "width-100 vote-card", 4, "ngIf"], ["fxFlexFill", "", "fxFlex", "100"], ["fxLayout", "row", "fxLayoutAlign", "space-between start"], [2, "margin-top", "0"], [1, "lib"], [1, "monospace"], ["matTooltip", "click to turn on/off", "matTooltipClass", "tooltip-bigger", 1, "livestream", 3, "click"], [1, "w-500"], [1, "dot", 3, "ngClass"], ["mat-table", "", "matSort", "", "matSortActive", "block_num", "matSortStart", "desc", "matSortDirection", "desc", 1, "actions-table", 3, "dataSource"], ["matColumnDef", "trx_id"], ["mat-header-cell", "", 3, "ngStyle.gt-xs", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "TX", 4, "matCellDef"], ["matColumnDef", "action"], ["mat-header-cell", "", 3, "ngStyle.gt-xs", "ngStyle.gt-sm", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Action", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["matColumnDef", "data"], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Data", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["matColumnDef", "block_num"], ["mat-header-cell", "", "mat-sort-header", "", 3, "ngStyle.gt-xs", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Block & Date", 4, "matCellDef"], ["mat-header-row", "", 4, "matHeaderRowDef", "matHeaderRowDefSticky"], ["mat-row", "", 4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSizeOptions", "length", "page"], ["mat-stroked-button", "", "color", "primary", 1, "float-r", 2, "margin-right", "16px", 3, "click"], [1, "mt-7", "width-100"], [1, "float-r", "link-gray", 3, "routerLink"], ["fxLayout.sm", "row wrap", "fxLayout.lt-sm", "column", "fxLayout.gt-sm", "column", "fxLayoutGap.sm", "43px", "fxLayoutGap.lt-sm", "10px", "fxLayoutGap.gt-sm", "10px"], ["fxFlex.sm", "0 0 calc((100% - 132px) / 3)", 4, "ngFor", "ngForOf"], ["fxFlex.sm", "0 0 calc((100% - 132px) / 3)"], [1, "token-cell"], [1, "faded", "monospace", "div-link", 3, "routerLink"], [1, "token-amount", 3, "ngClass.lt-sm"], [1, "token"], ["matTreeNodePadding", ""], ["mat-icon-button", "", "disabled", ""], ["fxLayout", "column", "fxLayoutGap", "7px", 1, "permission-cell"], [1, "primary", 2, "display", "inline", "letter-spacing", "0.7px"], [4, "ngFor", "ngForOf"], ["matTooltip", "weight / threshold", "matTooltipClass", "tooltip-bigger", 1, "space-right"], [3, "icon"], [1, "monospace", "m-left", "break-word", "link-gray", 3, "routerLink"], [1, "m-left", "link-blue", 3, "routerLink"], [1, "m-left"], ["mat-icon-button", "", "matTreeNodeToggle", ""], [1, "width-100", "vote-card"], [3, "disabled", "hideToggle"], [1, "vote-card-title"], ["transform", "shrink-4", 3, "icon", "inverse"], [2, "margin-top", "22px"], [1, "link-blue", 3, "routerLink"], ["mat-header-cell", "", 3, "ngStyle.gt-xs"], ["mat-cell", "", "data-label", "TX"], ["matTooltip", "time until irreversible", "matTooltipClass", "tooltip-bigger", 4, "ngIf"], ["matTooltip", "time until irreversible", "matTooltipClass", "tooltip-bigger"], [1, "accent", 2, "margin-right", "1px", 3, "icon"], ["mat-header-cell", "", 3, "ngStyle.gt-xs", "ngStyle.gt-sm"], ["mat-cell", "", "data-label", "Action", 3, "ngStyle.gt-xs"], [1, "action-cell", 3, "ngStyle.lt-md", "ngClass.gt-sm"], [1, "accent", "w-500"], [1, "w-500", "div-link", 3, "routerLink"], ["mat-header-cell", ""], ["mat-cell", "", "data-label", "Data", 3, "ngStyle.gt-xs"], [3, "ngClass", 4, "ngFor", "ngForOf"], ["class", "break-word", "style", "font-style: italic", 4, "ngIf"], [3, "ngClass"], ["style", "margin-top: 5px", 4, "ngFor", "ngForOf"], [2, "margin-top", "5px"], [2, "margin-left", "15px"], [1, "break-word"], [1, "w-500", 2, "margin-left", "15px"], ["class", "break-word", 4, "ngIf"], [1, "break-word", 2, "font-style", "italic"], ["mat-header-cell", "", "mat-sort-header", "", 3, "ngStyle.gt-xs"], ["mat-cell", "", "data-label", "Block & Date"], ["mat-header-row", ""], ["mat-row", ""]], template: function (t, e) { 1 & t && (Eo(0, LD, 1, 1, "mat-progress-spinner", 0), Eo(1, FD, 9, 2, "div", 1), Eo(2, GI, 157, 106, "div", 2)), 2 & t && (Do("ngIf", !e.accountService.loaded), yr(1), Do("ngIf", !e.accountService.jsonData && e.accountService.loaded), yr(1), Do("ngIf", e.accountService.jsonData && e.accountService.loaded)) }, directives: [$h, JP, rE, VE, uE, QE, CA, CE, IE, WA, oD, DA, SA, PP, VT, RT, Bh, HS, rT, YS, WS, $S, ZS, tk, $P, rO, Ty, Hh, Ay, IT, LT, BT, ID, AD, TD, DD, PD, KS, QS, dT, nk, rk], pipes: [ou, ru], styles: [".container[_ngcontent-%COMP%]{margin-top:112px}.total-balance[_ngcontent-%COMP%]{border-bottom:1px solid rgba(0,0,0,.12);padding-bottom:10px;margin-bottom:10px}.mb-5[_ngcontent-%COMP%]{margin-bottom:5px}.mt-7[_ngcontent-%COMP%]{margin-top:7px}.mt-30[_ngcontent-%COMP%]{margin-top:30px}.title[_ngcontent-%COMP%]{font-size:21px;color:#00a6de;font-weight:500}.used[_ngcontent-%COMP%]{margin-left:7px}.values[_ngcontent-%COMP%]{margin-top:7px}.progress-bar[_ngcontent-%COMP%], .small-info[_ngcontent-%COMP%]{margin-top:10px}.small-info[_ngcontent-%COMP%]{font-size:15px;color:rgba(0,0,0,.45)}.display-block[_ngcontent-%COMP%]{display:block;margin-left:0}.actions-table[_ngcontent-%COMP%]{width:100%}  .bigger-tooltip{font-size:16px}.middle-card[_ngcontent-%COMP%]{max-height:523px;overflow-y:auto}.token-cell[_ngcontent-%COMP%]{margin-bottom:11px;border-bottom:1px solid rgba(0,0,0,.12);padding-bottom:14px;border-radius:3px}.token[_ngcontent-%COMP%]{font-size:20px;color:#00a6de;font-weight:500}.faded[_ngcontent-%COMP%]{color:#a4a4a4}.permission-cell[_ngcontent-%COMP%]{border-bottom:1px solid #e2e2e2;border-left:1px solid #e2e2e2;border-radius:0 0 0 5px;padding:10px 0 8px 8px;width:100%}.monospace[_ngcontent-%COMP%]{font-family:Courier Prime,monospace;font-size:16px}.m-left[_ngcontent-%COMP%]{margin-left:7px}.m-bottom[_ngcontent-%COMP%]{margin-bottom:3px}.float-r[_ngcontent-%COMP%]{float:right}.space-right[_ngcontent-%COMP%]{margin-right:4px}.vote-card[_ngcontent-%COMP%]   .mat-expansion-panel-header[_ngcontent-%COMP%]{padding-left:15px}.vote-card-title[_ngcontent-%COMP%]{font-size:19px}.action-cell[_ngcontent-%COMP%]{padding:5px 10px;font-size:13px;letter-spacing:.5px}.action-border[_ngcontent-%COMP%]{border:1px solid #f0f0f0;border-radius:3px}.data-item[_ngcontent-%COMP%]{padding-bottom:3px}.dot[_ngcontent-%COMP%]{width:12px;height:12px;display:inline-block;margin-left:10px}.dot[_ngcontent-%COMP%], .red-dot[_ngcontent-%COMP%]{border-radius:50%}.red-dot[_ngcontent-%COMP%]{background:#de0000;cursor:pointer}.off[_ngcontent-%COMP%]{background-color:grey}.livestream[_ngcontent-%COMP%]{cursor:pointer;margin-bottom:7px;font-size:15px}.pulse[_ngcontent-%COMP%]{background:#00a6de;border-radius:50%;cursor:pointer;box-shadow:0 0 0 rgba(0,166,222,.5);-webkit-animation:pulse 2s infinite;animation:pulse 2s infinite}.pulse[_ngcontent-%COMP%]:hover{-webkit-animation:none;animation:none}@-webkit-keyframes pulse{0%{-webkit-box-shadow:0 0 0 0 rgba(0,166,222,.5)}70%{-webkit-box-shadow:0 0 0 10px rgba(204,169,44,0)}to{-webkit-box-shadow:0 0 0 0 rgba(204,169,44,0)}}@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(0,166,222,.5)}70%{box-shadow:0 0 0 10px rgba(204,169,44,0)}to{box-shadow:0 0 0 0 rgba(204,169,44,0)}}  .tooltip-bigger{font-size:13px}@media (max-width:599px){.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;height:auto;position:-webkit-sticky;position:sticky;top:0;z-index:2}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%]{display:flex;flex:1;align-items:center;padding:1rem .5rem;justify-content:space-around}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container[_ngcontent-%COMP%]{padding-left:15px}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container.mat-column-actions[_ngcontent-%COMP%], .mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container.mat-sort-header-disabled[_ngcontent-%COMP%], .mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container[_ngcontent-%COMP%]:not([mat-sort-header]){display:none}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]{height:auto}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions){display:grid;grid-template-columns:50% 50%;padding:.5rem;text-align:left;word-break:break-word}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions) > *[_ngcontent-%COMP%]{grid-column:2}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions):before{content:attr(data-label);text-align:left;font-size:12px;font-weight:500;color:rgba(0,0,0,.54)}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-column-actions[_ngcontent-%COMP%]{display:flex;justify-content:center;padding:0 .5rem}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-column-actions[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]{margin:.5rem 0}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]:last-of-type   td[_ngcontent-%COMP%]:last-of-type{border:none}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]:not(:last-of-type)   td[_ngcontent-%COMP%]:last-of-type{border-bottom:.5rem solid #e5e5e5;padding-bottom:20px!important;margin-bottom:20px}.mat-card[_ngcontent-%COMP%]   .mat-expansion-panel[_ngcontent-%COMP%]   .mat-table[_ngcontent-%COMP%]{border:.5rem solid #fafafa}}.mat-expansion-panel-header[aria-disabled=true][_ngcontent-%COMP%]{color:rgba(0,0,0,.87)}@media (min-width:960px) and (max-width:1049px){.full-width[_ngcontent-%COMP%]{flex:1 1 100%!important;box-sizing:border-box!important;max-width:100%!important;min-width:unset!important;margin-right:0!important}.mt-responsive[_ngcontent-%COMP%]{margin-top:30px}}.lib[_ngcontent-%COMP%]{font-size:15px;margin-top:1px;border-bottom:1px solid rgba(0,0,0,.12);padding-bottom:13px}"] }), t })(), XI = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, imports: [[fk]] }), t })(), KI = (() => { class t { constructor(t, e) { cu(e) && !t && console.warn("Warning: Flex Layout loaded on the server without FlexLayoutServerModule") } static withConfig(e, n = []) { return { ngModule: t, providers: e.serverLoaded ? [{ provide: _k, useValue: Object.assign(Object.assign({}, yk), e) }, { provide: bk, useValue: n, multi: !0 }, { provide: vk, useValue: !0 }] : [{ provide: _k, useValue: Object.assign(Object.assign({}, yk), e) }, { provide: bk, useValue: n, multi: !0 }] } } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t)(Kt(vk), Kt(vc)) }, imports: [[YE, XA, XI], YE, XA, XI] }), t })(); var QI = n("BA80"), ZI = n("sGxO"), JI = n("N2Ba"), tR = n("17fY"); const eR = ["*"]; class nR { constructor(t) { this._elementRef = t } } const iR = cw(aw(lw(ow(nR)), "primary"), -1); let rR = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-chip-avatar"], ["", "matChipAvatar", ""]], hostAttrs: [1, "mat-chip-avatar"] }), t })(), sR = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = we({ type: t, selectors: [["mat-chip-trailing-icon"], ["", "matChipTrailingIcon", ""]], hostAttrs: [1, "mat-chip-trailing-icon"] }), t })(), oR = (() => { class t extends iR { constructor(t, e, n, i, r, s, o, a) { super(t), this._elementRef = t, this._ngZone = e, this._changeDetectorRef = s, this._hasFocus = !1, this.chipListSelectable = !0, this._chipListMultiple = !1, this._selected = !1, this._selectable = !0, this._removable = !0, this._onFocus = new k, this._onBlur = new k, this.selectionChange = new ql, this.destroyed = new ql, this.removed = new ql, this._addHostClassName(), this._chipRippleTarget = (a || document).createElement("div"), this._chipRippleTarget.classList.add("mat-chip-ripple"), this._elementRef.nativeElement.appendChild(this._chipRippleTarget), this._chipRipple = new _w(this, e, this._chipRippleTarget, n), this._chipRipple.setupTriggerEvents(t), this.rippleConfig = i || {}, this._animationsDisabled = "NoopAnimations" === r, this.tabIndex = null != o && parseInt(o) || -1 } get rippleDisabled() { return this.disabled || this.disableRipple || !!this.rippleConfig.disabled } get selected() { return this._selected } set selected(t) { const e = lb(t); e !== this._selected && (this._selected = e, this._dispatchSelectionChange()) } get value() { return void 0 !== this._value ? this._value : this._elementRef.nativeElement.textContent } set value(t) { this._value = t } get selectable() { return this._selectable && this.chipListSelectable } set selectable(t) { this._selectable = lb(t) } get removable() { return this._removable } set removable(t) { this._removable = lb(t) } get ariaSelected() { return this.selectable && (this._chipListMultiple || this.selected) ? this.selected.toString() : null } _addHostClassName() { const t = this._elementRef.nativeElement; t.hasAttribute("mat-basic-chip") || "mat-basic-chip" === t.tagName.toLowerCase() ? t.classList.add("mat-basic-chip") : t.classList.add("mat-standard-chip") } ngOnDestroy() { this.destroyed.emit({ chip: this }), this._chipRipple._removeTriggerEvents() } select() { this._selected || (this._selected = !0, this._dispatchSelectionChange(), this._markForCheck()) } deselect() { this._selected && (this._selected = !1, this._dispatchSelectionChange(), this._markForCheck()) } selectViaInteraction() { this._selected || (this._selected = !0, this._dispatchSelectionChange(!0), this._markForCheck()) } toggleSelected(t = !1) { return this._selected = !this.selected, this._dispatchSelectionChange(t), this._markForCheck(), this.selected } focus() { this._hasFocus || (this._elementRef.nativeElement.focus(), this._onFocus.next({ chip: this })), this._hasFocus = !0 } remove() { this.removable && this.removed.emit({ chip: this }) } _handleClick(t) { this.disabled ? t.preventDefault() : t.stopPropagation() } _handleKeydown(t) { if (!this.disabled) switch (t.keyCode) { case 46: case 8: this.remove(), t.preventDefault(); break; case 32: this.selectable && this.toggleSelected(!0), t.preventDefault() } } _blur() { this._ngZone.onStable.asObservable().pipe(qf(1)).subscribe(() => { this._ngZone.run(() => { this._hasFocus = !1, this._onBlur.next({ chip: this }) }) }) } _dispatchSelectionChange(t = !1) { this.selectionChange.emit({ source: this, isUserInput: t, selected: this._selected }) } _markForCheck() { this._changeDetectorRef && this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Lc), Ao(gb), Ao(vw, 8), Ao(pf, 8), Ao(Ws), To("tabindex"), Ao(ph, 8)) }, t.\u0275dir = we({ type: t, selectors: [["mat-basic-chip"], ["", "mat-basic-chip", ""], ["mat-chip"], ["", "mat-chip", ""]], contentQueries: function (t, e, n) { var i; 1 & t && (oc(n, rR, !0), oc(n, sR, !0), oc(n, aR, !0)), 2 & t && (nc(i = cc()) && (e.avatar = i.first), nc(i = cc()) && (e.trailingIcon = i.first), nc(i = cc()) && (e.removeIcon = i.first)) }, hostAttrs: ["role", "option", 1, "mat-chip", "mat-focus-indicator"], hostVars: 14, hostBindings: function (t, e) { 1 & t && Ho("click", (function (t) { return e._handleClick(t) }))("keydown", (function (t) { return e._handleKeydown(t) }))("focus", (function () { return e.focus() }))("blur", (function () { return e._blur() })), 2 & t && (So("tabindex", e.disabled ? null : e.tabIndex)("disabled", e.disabled || null)("aria-disabled", e.disabled.toString())("aria-selected", e.ariaSelected), sa("mat-chip-selected", e.selected)("mat-chip-with-avatar", e.avatar)("mat-chip-with-trailing-icon", e.trailingIcon || e.removeIcon)("mat-chip-disabled", e.disabled)("_mat-animation-noopable", e._animationsDisabled)) }, inputs: { color: "color", disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex", selected: "selected", value: "value", selectable: "selectable", removable: "removable" }, outputs: { selectionChange: "selectionChange", destroyed: "destroyed", removed: "removed" }, exportAs: ["matChip"], features: [Ca] }), t })(), aR = (() => { class t { constructor(t, e) { this._parentChip = t, e && "BUTTON" === e.nativeElement.nodeName && e.nativeElement.setAttribute("type", "button") } _handleClick(t) { const e = this._parentChip; e.removable && !e.disabled && e.remove(), t.stopPropagation() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(oR), Ao(Ua)) }, t.\u0275dir = we({ type: t, selectors: [["", "matChipRemove", ""]], hostAttrs: [1, "mat-chip-remove", "mat-chip-trailing-icon"], hostBindings: function (t, e) { 1 & t && Ho("click", (function (t) { return e._handleClick(t) })) } }), t })(); const lR = new Bt("mat-chips-default-options"); class cR { constructor(t, e, n, i) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = i } } const hR = hw(cR); let uR = 0; class dR { constructor(t, e) { this.source = t, this.value = e } } let pR = (() => { class t extends hR { constructor(t, e, n, i, r, s, o) { super(s, i, r, o), this._elementRef = t, this._changeDetectorRef = e, this._dir = n, this.ngControl = o, this.controlType = "mat-chip-list", this._lastDestroyedChipIndex = null, this._destroyed = new k, this._uid = `mat-chip-list-${uR++}`, this._tabIndex = 0, this._userTabIndex = null, this._onTouched = () => { }, this._onChange = () => { }, this._multiple = !1, this._compareWith = (t, e) => t === e, this._required = !1, this._disabled = !1, this.ariaOrientation = "horizontal", this._selectable = !0, this.change = new ql, this.valueChange = new ql, this.ngControl && (this.ngControl.valueAccessor = this) } get selected() { return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0] } get role() { return this.empty ? null : "listbox" } get multiple() { return this._multiple } set multiple(t) { this._multiple = lb(t), this._syncChipsState() } get compareWith() { return this._compareWith } set compareWith(t) { this._compareWith = t, this._selectionModel && this._initializeSelection() } get value() { return this._value } set value(t) { this.writeValue(t), this._value = t } get id() { return this._chipInput ? this._chipInput.id : this._uid } get required() { return this._required } set required(t) { this._required = lb(t), this.stateChanges.next() } get placeholder() { return this._chipInput ? this._chipInput.placeholder : this._placeholder } set placeholder(t) { this._placeholder = t, this.stateChanges.next() } get focused() { return this._chipInput && this._chipInput.focused || this._hasFocusedChip() } get empty() { return (!this._chipInput || this._chipInput.empty) && 0 === this.chips.length } get shouldLabelFloat() { return !this.empty || this.focused } get disabled() { return this.ngControl ? !!this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = lb(t), this._syncChipsState() } get selectable() { return this._selectable } set selectable(t) { this._selectable = lb(t), this.chips && this.chips.forEach(t => t.chipListSelectable = this._selectable) } set tabIndex(t) { this._userTabIndex = t, this._tabIndex = t } get chipSelectionChanges() { return G(...this.chips.map(t => t.selectionChange)) } get chipFocusChanges() { return G(...this.chips.map(t => t._onFocus)) } get chipBlurChanges() { return G(...this.chips.map(t => t._onBlur)) } get chipRemoveChanges() { return G(...this.chips.map(t => t.destroyed)) } ngAfterContentInit() { this._keyManager = new Lb(this.chips).withWrap().withVerticalOrientation().withHorizontalOrientation(this._dir ? this._dir.value : "ltr"), this._dir && this._dir.change.pipe(jw(this._destroyed)).subscribe(t => this._keyManager.withHorizontalOrientation(t)), this._keyManager.tabOut.pipe(jw(this._destroyed)).subscribe(() => { this._allowFocusEscape() }), this.chips.changes.pipe(em(null), jw(this._destroyed)).subscribe(() => { this.disabled && Promise.resolve().then(() => { this._syncChipsState() }), this._resetChips(), this._initializeSelection(), this._updateTabIndex(), this._updateFocusForDestroyedChips(), this.stateChanges.next() }) } ngOnInit() { this._selectionModel = new Gx(this.multiple, void 0, !1), this.stateChanges.next() } ngDoCheck() { this.ngControl && (this.updateErrorState(), this.ngControl.disabled !== this._disabled && (this.disabled = !!this.ngControl.disabled)) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), this.stateChanges.complete(), this._dropSubscriptions() } registerInput(t) { this._chipInput = t } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } writeValue(t) { this.chips && this._setSelectionByValue(t, !1) } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this.stateChanges.next() } onContainerClick(t) { this._originatesFromChip(t) || this.focus() } focus(t) { this.disabled || this._chipInput && this._chipInput.focused || (this.chips.length > 0 ? (this._keyManager.setFirstItemActive(), this.stateChanges.next()) : (this._focusInput(t), this.stateChanges.next())) } _focusInput(t) { this._chipInput && this._chipInput.focus(t) } _keydown(t) { const e = t.target; 8 === t.keyCode && this._isInputEmpty(e) ? (this._keyManager.setLastItemActive(), t.preventDefault()) : e && e.classList.contains("mat-chip") && (36 === t.keyCode ? (this._keyManager.setFirstItemActive(), t.preventDefault()) : 35 === t.keyCode ? (this._keyManager.setLastItemActive(), t.preventDefault()) : this._keyManager.onKeydown(t), this.stateChanges.next()) } _updateTabIndex() { this._tabIndex = this._userTabIndex || (0 === this.chips.length ? -1 : 0) } _updateFocusForDestroyedChips() { if (null != this._lastDestroyedChipIndex) if (this.chips.length) { const t = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1); this._keyManager.setActiveItem(t) } else this.focus(); this._lastDestroyedChipIndex = null } _isValidIndex(t) { return t >= 0 && t < this.chips.length } _isInputEmpty(t) { return !(!t || "input" !== t.nodeName.toLowerCase() || t.value) } _setSelectionByValue(t, e = !0) { if (this._clearSelection(), this.chips.forEach(t => t.deselect()), Array.isArray(t)) t.forEach(t => this._selectValue(t, e)), this._sortValues(); else { const n = this._selectValue(t, e); n && e && this._keyManager.setActiveItem(n) } } _selectValue(t, e = !0) { const n = this.chips.find(e => null != e.value && this._compareWith(e.value, t)); return n && (e ? n.selectViaInteraction() : n.select(), this._selectionModel.select(n)), n } _initializeSelection() { Promise.resolve().then(() => { (this.ngControl || this._value) && (this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, !1), this.stateChanges.next()) }) } _clearSelection(t) { this._selectionModel.clear(), this.chips.forEach(e => { e !== t && e.deselect() }), this.stateChanges.next() } _sortValues() { this._multiple && (this._selectionModel.clear(), this.chips.forEach(t => { t.selected && this._selectionModel.select(t) }), this.stateChanges.next()) } _propagateChanges(t) { let e = null; e = Array.isArray(this.selected) ? this.selected.map(t => t.value) : this.selected ? this.selected.value : t, this._value = e, this.change.emit(new dR(this, e)), this.valueChange.emit(e), this._onChange(e), this._changeDetectorRef.markForCheck() } _blur() { this._hasFocusedChip() || this._keyManager.setActiveItem(-1), this.disabled || (this._chipInput ? setTimeout(() => { this.focused || this._markAsTouched() }) : this._markAsTouched()) } _markAsTouched() { this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next() } _allowFocusEscape() { -1 !== this._tabIndex && (this._tabIndex = -1, setTimeout(() => { this._tabIndex = this._userTabIndex || 0, this._changeDetectorRef.markForCheck() })) } _resetChips() { this._dropSubscriptions(), this._listenToChipsFocus(), this._listenToChipsSelection(), this._listenToChipsRemoved() } _dropSubscriptions() { this._chipFocusSubscription && (this._chipFocusSubscription.unsubscribe(), this._chipFocusSubscription = null), this._chipBlurSubscription && (this._chipBlurSubscription.unsubscribe(), this._chipBlurSubscription = null), this._chipSelectionSubscription && (this._chipSelectionSubscription.unsubscribe(), this._chipSelectionSubscription = null), this._chipRemoveSubscription && (this._chipRemoveSubscription.unsubscribe(), this._chipRemoveSubscription = null) } _listenToChipsSelection() { this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(t => { t.source.selected ? this._selectionModel.select(t.source) : this._selectionModel.deselect(t.source), this.multiple || this.chips.forEach(t => { !this._selectionModel.isSelected(t) && t.selected && t.deselect() }), t.isUserInput && this._propagateChanges() }) } _listenToChipsFocus() { this._chipFocusSubscription = this.chipFocusChanges.subscribe(t => { let e = this.chips.toArray().indexOf(t.chip); this._isValidIndex(e) && this._keyManager.updateActiveItem(e), this.stateChanges.next() }), this._chipBlurSubscription = this.chipBlurChanges.subscribe(() => { this._blur(), this.stateChanges.next() }) } _listenToChipsRemoved() { this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(t => { const e = t.chip, n = this.chips.toArray().indexOf(t.chip); this._isValidIndex(n) && e._hasFocus && (this._lastDestroyedChipIndex = n) }) } _originatesFromChip(t) { let e = t.target; for (; e && e !== this._elementRef.nativeElement;) { if (e.classList.contains("mat-chip")) return !0; e = e.parentElement } return !1 } _hasFocusedChip() { return this.chips.some(t => t._hasFocus) } _syncChipsState() { this.chips && this.chips.forEach(t => { t.disabled = this._disabled, t._chipListMultiple = this.multiple }) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(Ua), Ao(Ws), Ao(Gb, 8), Ao(Lv, 8), Ao(zv, 8), Ao(dw), Ao(z_, 10)) }, t.\u0275cmp = me({ type: t, selectors: [["mat-chip-list"]], contentQueries: function (t, e, n) { var i; 1 & t && oc(n, oR, !0), 2 & t && nc(i = cc()) && (e.chips = i) }, hostAttrs: [1, "mat-chip-list"], hostVars: 15, hostBindings: function (t, e) { 1 & t && Ho("focus", (function () { return e.focus() }))("blur", (function () { return e._blur() }))("keydown", (function (t) { return e._keydown(t) })), 2 & t && (ba("id", e._uid), So("tabindex", e.disabled ? null : e._tabIndex)("aria-describedby", e._ariaDescribedby || null)("aria-required", e.role ? e.required : null)("aria-disabled", e.disabled.toString())("aria-invalid", e.errorState)("aria-multiselectable", e.multiple)("role", e.role)("aria-orientation", e.ariaOrientation), sa("mat-chip-list-disabled", e.disabled)("mat-chip-list-invalid", e.errorState)("mat-chip-list-required", e.required)) }, inputs: { ariaOrientation: ["aria-orientation", "ariaOrientation"], multiple: "multiple", compareWith: "compareWith", value: "value", required: "required", placeholder: "placeholder", disabled: "disabled", selectable: "selectable", tabIndex: "tabIndex", errorStateMatcher: "errorStateMatcher" }, outputs: { change: "change", valueChange: "valueChange" }, exportAs: ["matChipList"], features: [ja([{ provide: lx, useExisting: t }]), Ca], ngContentSelectors: eR, decls: 2, vars: 0, consts: [[1, "mat-chip-list-wrapper"]], template: function (t, e) { 1 & t && (Xo(), Ro(0, "div", 0), Ko(1), Mo()) }, styles: ['.mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0);border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:"";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\n'], encapsulation: 2, changeDetection: 0 }), t })(); const fR = { separatorKeyCodes: [13] }; let mR = (() => { class t { } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [dw, { provide: lR, useValue: fR }] }), t })(); function gR(t, e) { 1 & t && Lo(0, "mat-progress-spinner", 3), 2 & t && Do("diameter", 45) } function yR(t, e) { if (1 & t && (Ro(0, "div", 4), Ro(1, "mat-card", 5), Ro(2, "h1", 6), Lo(3, "fa-icon", 7), ga(4, " Transaction not found "), Mo(), Ro(5, "div"), ga(6, "We couldn't find the transaction "), Ro(7, "strong", 8), ga(8), Mo(), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(3), Do("icon", t.faSadTear), yr(5), ya(t.txID) } } function _R(t, e) { if (1 & t && (Ro(0, "mat-chip", 44), Lo(1, "fa-icon", 7), ga(2, " Irrevesible "), Mo()), 2 & t) { const t = Go(2); yr(1), Do("icon", t.faLock) } } function vR(t, e) { if (1 & t && (Ro(0, "mat-chip", 45), Lo(1, "fa-icon", 7), ga(2), Mo()), 2 & t) { const t = Go(2); yr(1), Do("icon", t.faHourglass), yr(1), _a(" Pending (", t.countdownTimer, "s) ") } } function bR(t, e) { 1 & t && (Ro(0, "span"), ga(1, "s"), Mo()) } function wR(t, e) { 1 & t && (Ro(0, "th", 46), ga(1, " Contract"), Mo()) } const xR = function (t) { return ["/account", t] }; function CR(t, e) { if (1 & t && (Ro(0, "td", 47), Ro(1, "span", 48), ga(2), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(1), Do("routerLink", Ll(2, xR, t.act.account)), yr(1), ya(t.act.account) } } const SR = function () { return { "padding-left": "14px", "padding-right": "14px" } }; function kR(t, e) { 1 & t && (Ro(0, "th", 49), ga(1, " Action "), Mo()), 2 & t && Do("ngStyle.gt-xs", Ml(1, SR)) } function ER(t, e) { if (1 & t && (Ro(0, "td", 50), Ro(1, "span", 51), ga(2), Mo(), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(2, SR)), yr(2), ya(t.act.name) } } function OR(t, e) { 1 & t && (Ro(0, "th", 46), ga(1, " Data"), Mo()) } const AR = function (t) { return { "data-item": t } }; function TR(t, e) { if (1 & t && (Ro(0, "div", 54), Ro(1, "span", 55), ga(2), Mo(), ga(3, ": "), Ro(4, "span", 8), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go().$implicit, i = Go(2); Do("ngClass", Ll(3, AR, i.objectKeyCount(n.act.data) > 1)), yr(2), ya(t.key), yr(3), ya(t.value) } } const PR = function () { return { padding: "10px 0 6px" } }; function DR(t, e) { if (1 & t && (Ro(0, "td", 52), Eo(1, TR, 6, 5, "div", 53), Bl(2, "keyvalue"), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(4, PR)), yr(1), Do("ngForOf", zl(2, 2, t.act.data)) } } function IR(t, e) { 1 & t && (Ro(0, "th", 46), ga(1, "Authorization"), Mo()) } function RR(t, e) { if (1 & t && (Ro(0, "div", 58), Ro(1, "span", 55), ga(2), Mo(), ga(3, ": "), Ro(4, "span"), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(2), ya(t.key), yr(3), ya(t.value) } } function MR(t, e) { if (1 & t && (Ro(0, "td", 56), Eo(1, RR, 6, 2, "div", 57), Bl(2, "keyvalue"), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(4, PR)), yr(1), Do("ngForOf", zl(2, 2, t.act.authorization[0])) } } function LR(t, e) { 1 & t && Lo(0, "tr", 59) } function FR(t, e) { 1 & t && Lo(0, "tr", 60) } const NR = function (t) { return ["/block", t] }; function VR(t, e) { if (1 & t && (Ro(0, "div", 9), Ro(1, "mat-card", 10), Ro(2, "div", 11), Ro(3, "div", 12), Ro(4, "h2", 13), Ro(5, "fa-layers", 14), Lo(6, "fa-icon", 15), Lo(7, "fa-icon", 16), Mo(), ga(8, " Transaction "), Mo(), Ro(9, "mat-chip-list", 17), Eo(10, _R, 3, 1, "mat-chip", 18), Eo(11, vR, 3, 2, "mat-chip", 19), Mo(), Mo(), Ro(12, "h4", 20), ga(13), Mo(), Mo(), Ro(14, "div", 21), Ro(15, "div"), ga(16, "Block num: "), Ro(17, "a", 22), ga(18), Mo(), Mo(), Ro(19, "div"), ga(20), Mo(), Ro(21, "div", 23), Ro(22, "div"), Ro(23, "div"), Ro(24, "span", 24), ga(25, "CPU"), Mo(), Ro(26, "span", 25), ga(27, "usage"), Mo(), Mo(), Ro(28, "div"), ga(29), Mo(), Mo(), Ro(30, "div"), Ro(31, "div"), Ro(32, "span", 24), ga(33, "NET"), Mo(), Ro(34, "span", 25), ga(35, "usage"), Mo(), Mo(), Ro(36, "div"), ga(37), Mo(), Mo(), Mo(), Mo(), Mo(), Ro(38, "mat-card", 10), Ro(39, "h3", 26), Ro(40, "fa-layers", 27), Lo(41, "fa-icon", 28), Lo(42, "fa-icon", 29), Mo(), ga(43), Eo(44, bR, 2, 0, "span", 30), Mo(), Ro(45, "table", 31), Fo(46, 32), Eo(47, wR, 2, 0, "th", 33), Eo(48, CR, 3, 4, "td", 34), No(), Fo(49, 35), Eo(50, kR, 2, 2, "th", 36), Eo(51, ER, 3, 3, "td", 37), No(), Fo(52, 38), Eo(53, OR, 2, 0, "th", 33), Eo(54, DR, 3, 5, "td", 39), No(), Fo(55, 40), Eo(56, IR, 2, 0, "th", 33), Eo(57, MR, 3, 5, "td", 41), No(), Eo(58, LR, 1, 0, "tr", 42), Eo(59, FR, 1, 0, "tr", 43), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(5), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faExchange)("inverse", !0), yr(3), Do("ngIf", t.accountService.libNum > t.tx.actions[0].block_num), yr(1), Do("ngIf", t.accountService.libNum < t.tx.actions[0].block_num), yr(2), ya(t.tx.trx_id), yr(4), Do("routerLink", Ll(22, NR, t.tx.actions[0].block_num)), yr(1), ya(t.tx.actions[0].block_num), yr(2), _a("Block time: ", t.formatDate(t.tx.actions[0]["@timestamp"]), ""), yr(9), _a("", t.tx.actions[0].cpu_usage_us, " \xb5s"), yr(8), _a("", t.tx.actions[0].net_usage_words, " bytes"), yr(3), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faHistory)("inverse", !0), yr(1), _a(" ", t.tx.actions.length, " Action"), yr(1), Do("ngIf", t.tx.actions.length > 1), yr(1), Do("dataSource", t.tx.actions), yr(13), Do("matHeaderRowDef", t.columnsToDisplay)("matHeaderRowDefSticky", !0), yr(1), Do("matRowDefColumns", t.columnsToDisplay) } } let jR = (() => { class t { constructor(t, e, n, i) { this.activatedRoute = t, this.accountService = e, this.chainData = n, this.title = i, this.columnsToDisplay = ["contract", "action", "data", "auth"], this.tx = { actions: null }, this.faCircle = gT.faCircle, this.faExchange = QI.faExchangeAlt, this.faLock = ZI.faLock, this.faHourglass = JI.faHourglassStart, this.faHistory = vT.faHistory, this.faSadTear = XT.faSadTear, this.faSpinner = tR.faSpinner, this.countdownTimer = 0 } objectKeyCount(t) { try { return Object.keys(t).length } catch (GM) { return 0 } } ngOnInit() { this.activatedRoute.params.subscribe(t => sS(this, void 0, void 0, (function* () { this.txID = t.transaction_id, this.tx = yield this.accountService.loadTxData(t.transaction_id), this.title.setTitle(this.chainData.chainInfoData.chain_name ? `TX ${t.transaction_id.slice(0, 8)} \u2022 ${this.chainData.chainInfoData.chain_name} Hyperion Explorer` : `TX ${t.transaction_id.slice(0, 8)} \u2022 Hyperion Explorer`), this.accountService.libNum = this.tx.lib, this.tx.actions[0].block_num > this.tx.lib && (yield this.reloadCountdownTimer(), this.countdownLoop = setInterval(() => sS(this, void 0, void 0, (function* () { this.countdownTimer--, this.countdownTimer <= 0 && (yield this.reloadCountdownTimer(), this.accountService.libNum > this.tx.actions[0].block_num && clearInterval(this.countdownLoop)) })), 1e3)) }))) } ngOnDestroy() { this.countdownLoop && clearInterval(this.countdownLoop) } formatDate(t) { return new Date(t).toLocaleString() } reloadCountdownTimer() { return sS(this, void 0, void 0, (function* () { yield this.accountService.updateLib(), this.countdownTimer = Math.ceil((this.tx.actions[0].block_num - this.accountService.libNum) / 2) })) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(vg), Ao(ck), Ao(uk), Ao(Uu)) }, t.\u0275cmp = me({ type: t, selectors: [["app-transaction"]], decls: 3, vars: 3, consts: [["mode", "indeterminate", 3, "diameter", 4, "ngIf"], ["class", "container", "fxLayout", "column", "style", "height: calc(100vh - 209px);", "fxLayoutAlign", "start center", 4, "ngIf"], ["class", "container", "fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 4, "ngIf"], ["mode", "indeterminate", 3, "diameter"], ["fxLayout", "column", "fxLayoutAlign", "start center", 1, "container", 2, "height", "calc(100vh - 209px)"], [2, "width", "100%"], [1, "faded"], [2, "margin-right", "5px", 3, "icon"], [1, "break-word"], ["fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 1, "container"], ["fxFlex", "100", "fxFlexFill", ""], [2, "border-bottom", "1px solid #e4e4e4", "margin-bottom", "12px"], ["fxLayout", "row", "fxLayoutAlign", "start start"], [2, "margin-bottom", "-15px", "color", "#9c9c9c", "margin-top", "0", "margin-right", "10px"], [2, "margin-right", "2px", 3, "fixedWidth"], ["transform", "grow-1", 3, "icon"], ["transform", "shrink-4", 3, "icon", "inverse"], ["orientation", "vertical"], ["selected", "", 4, "ngIf"], ["color", "accent", "selected", "", 4, "ngIf"], [1, "break-word", 2, "margin", "10px 0 12px 0"], ["fxLayout", "column", "fxLayoutAlign", "start stretch", "fxLayoutGap", "15px"], [1, "link-blue", 3, "routerLink"], ["fxLayout", "row", "fxLayoutAlign", "start center", "fxLayoutGap", "50px"], [1, "title"], [1, "faded", "used"], [2, "margin-top", "0"], [2, "margin-right", "5px", 3, "fixedWidth"], ["transform", "grow-3", 3, "icon"], ["transform", "shrink-5", 3, "icon", "inverse"], [4, "ngIf"], ["mat-table", "", 1, "actions-table", 3, "dataSource"], ["matColumnDef", "contract"], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Contract", 4, "matCellDef"], ["matColumnDef", "action"], ["mat-header-cell", "", 3, "ngStyle.gt-xs", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Action", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["matColumnDef", "data"], ["mat-cell", "", "data-label", "Data", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["matColumnDef", "auth"], ["mat-cell", "", "data-label", "Authorization", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["mat-header-row", "", 4, "matHeaderRowDef", "matHeaderRowDefSticky"], ["mat-row", "", 4, "matRowDef", "matRowDefColumns"], ["selected", ""], ["color", "accent", "selected", ""], ["mat-header-cell", ""], ["mat-cell", "", "data-label", "Contract"], [1, "div-link", 3, "routerLink"], ["mat-header-cell", "", 3, "ngStyle.gt-xs"], ["mat-cell", "", "data-label", "Action", 3, "ngStyle.gt-xs"], [1, "accent", "w-500"], ["mat-cell", "", "data-label", "Data", 3, "ngStyle.gt-xs"], [3, "ngClass", 4, "ngFor", "ngForOf"], [3, "ngClass"], [1, "w-500"], ["mat-cell", "", "data-label", "Authorization", 3, "ngStyle.gt-xs"], ["class", "data-item", 4, "ngFor", "ngForOf"], [1, "data-item"], ["mat-header-row", ""], ["mat-row", ""]], template: function (t, e) { 1 & t && (Eo(0, gR, 1, 1, "mat-progress-spinner", 0), Eo(1, yR, 9, 2, "div", 1), Eo(2, VR, 60, 24, "div", 2)), 2 & t && (Do("ngIf", !e.accountService.loaded), yr(1), Do("ngIf", e.tx.actions && 0 === e.tx.actions.length), yr(1), Do("ngIf", e.tx.actions && e.tx.actions.length > 0 && e.accountService.loaded)) }, directives: [$h, JP, rE, VE, QE, CA, uE, CE, IE, SA, pR, Ty, HS, YS, WS, $S, ZS, tk, oR, KS, QS, Ay, WA, Hh, Bh, DA, nk, rk], pipes: [ru], styles: [".container[_ngcontent-%COMP%]{margin-top:112px}.title[_ngcontent-%COMP%]{font-size:21px;color:#00a6de;font-weight:500}.used[_ngcontent-%COMP%]{margin-left:7px}.faded[_ngcontent-%COMP%]{color:#a4a4a4}.actions-table[_ngcontent-%COMP%]{width:100%}.data-item[_ngcontent-%COMP%]{padding-bottom:4px}@media (max-width:599px){.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;height:auto;position:-webkit-sticky;position:sticky;top:0;z-index:2}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%]{display:none}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container[_ngcontent-%COMP%]{padding-left:15px}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container.mat-column-actions[_ngcontent-%COMP%], .mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container.mat-sort-header-disabled[_ngcontent-%COMP%], .mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container[_ngcontent-%COMP%]:not([mat-sort-header]){display:none}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]{height:auto}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions){display:grid;grid-template-columns:50% 50%;padding:.5rem;text-align:left;word-break:break-word}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions) > *[_ngcontent-%COMP%]{grid-column:2}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions):before{content:attr(data-label);text-align:left;font-size:12px;font-weight:500;color:rgba(0,0,0,.54)}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-column-actions[_ngcontent-%COMP%]{display:flex;justify-content:center;padding:0 .5rem}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-column-actions[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]{margin:.5rem 0}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]:last-of-type   td[_ngcontent-%COMP%]:last-of-type{border:none}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]:not(:last-of-type)   td[_ngcontent-%COMP%]:last-of-type{border-bottom:.5rem solid #e5e5e5;padding-bottom:20px!important;margin-bottom:20px}.mat-card[_ngcontent-%COMP%]   .mat-expansion-panel[_ngcontent-%COMP%]   .mat-table[_ngcontent-%COMP%]{border:.5rem solid #fafafa}}"] }), t })(); var BR = n("XrrA"); function zR(t, e) { 1 & t && Lo(0, "mat-progress-spinner", 3), 2 & t && Do("diameter", 45) } function HR(t, e) { if (1 & t && (Ro(0, "div", 4), Ro(1, "mat-card"), Ro(2, "h1", 5), Lo(3, "fa-icon", 6), ga(4, " Block not found "), Mo(), Ro(5, "div"), ga(6, "We couldn't find block "), Ro(7, "strong"), ga(8), Mo(), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(3), Do("icon", t.faSadTear), yr(5), ya(t.blockNum) } } function UR(t, e) { if (1 & t && (Ro(0, "mat-chip", 41), Lo(1, "fa-icon", 6), ga(2, " Irrevesible "), Mo()), 2 & t) { const t = Go(2); yr(1), Do("icon", t.faLock) } } function $R(t, e) { if (1 & t && (Ro(0, "mat-chip", 42), Lo(1, "fa-icon", 6), ga(2), Mo()), 2 & t) { const t = Go(2); yr(1), Do("icon", t.faHourglass), yr(1), _a(" Pending (", t.countdownTimer, "s) ") } } function qR(t, e) { 1 & t && (Ro(0, "span"), ga(1, "s"), Mo()) } function WR(t, e) { 1 & t && Lo(0, "th", 43) } function GR(t, e) { if (1 & t && (Ro(0, "td", 44), Ro(1, "button", 45), Lo(2, "fa-icon", 46), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2); yr(2), Do("icon", n.expandedElement === t ? n.faChevronDown : n.faChevronRight) } } function YR(t, e) { 1 & t && (Ro(0, "th", 43), ga(1, "TX ID"), Mo()) } const XR = function (t) { return ["/transaction", t] }; function KR(t, e) { if (1 & t && (Ro(0, "td", 47), Ro(1, "a", 48), ga(2), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(1), Do("routerLink", Ll(2, XR, t.id)), yr(1), ya(t.id) } } function QR(t, e) { 1 & t && (Ro(0, "th", 49), ga(1, "Root Action"), Mo()) } const ZR = function () { return { "min-width": "170px" } }, JR = function (t) { return ["/account", t] }; function tM(t, e) { if (1 & t && (Ro(0, "td", 50), Ro(1, "span", 51), Ro(2, "span", 52), ga(3), Mo(), ga(4, " on "), Ro(5, "span", 53), ga(6), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(1), Do("ngStyle.gt-xs", Ml(5, ZR))("ngClass.gt-sm", "action-border"), yr(2), ya(t.actions[0].action), yr(2), Do("routerLink", Ll(6, JR, t.actions[0].account)), yr(1), ya(t.actions[0].account) } } function eM(t, e) { 1 & t && (Ro(0, "th", 54), ga(1, "# Actions"), Mo()) } function nM(t, e) { if (1 & t && (Ro(0, "td", 55), ga(1), Mo()), 2 & t) { const t = e.$implicit; yr(1), _a(" ", t.actions.length, " ") } } function iM(t, e) { 1 & t && (Ro(0, "th", 43), ga(1, "Action"), Mo()) } const rM = function () { return { "padding-right": "14px" } }; function sM(t, e) { if (1 & t && (Ro(0, "td", 65), Ro(1, "span"), Ro(2, "span", 52), ga(3), Mo(), ga(4, " on "), Ro(5, "span", 53), ga(6), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(4, rM)), yr(3), ya(t.action), yr(2), Do("routerLink", Ll(5, JR, t.account)), yr(1), ya(t.account) } } function oM(t, e) { 1 & t && (Ro(0, "th", 43), ga(1, " Data"), Mo()) } const aM = function (t) { return { "data-item": t } }; function lM(t, e) { if (1 & t && (Ro(0, "div", 68), Ro(1, "span", 18), ga(2), Mo(), ga(3, ": "), Ro(4, "span", 19), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go().$implicit, i = Go(3); Do("ngClass", Ll(3, aM, i.objectKeyCount(n.data) > 1)), yr(2), ya(t.key), yr(3), ya(t.value) } } const cM = function () { return { padding: "10px 14px 10px 0" } }; function hM(t, e) { if (1 & t && (Ro(0, "td", 66), Eo(1, lM, 6, 5, "div", 67), Bl(2, "keyvalue"), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(4, cM)), yr(1), Do("ngForOf", zl(2, 2, t.data)) } } function uM(t, e) { 1 & t && (Ro(0, "th", 43), ga(1, "Authorization"), Mo()) } function dM(t, e) { if (1 & t && (Ro(0, "div", 71), Ro(1, "span", 18), ga(2), Mo(), ga(3, ": "), Ro(4, "span"), ga(5), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(2), ya(t.key), yr(3), ya(t.value) } } const pM = function () { return { padding: "10px 0 6px" } }; function fM(t, e) { if (1 & t && (Ro(0, "td", 69), Eo(1, dM, 6, 2, "div", 70), Bl(2, "keyvalue"), Mo()), 2 & t) { const t = e.$implicit; Do("ngStyle.gt-xs", Ml(4, pM)), yr(1), Do("ngForOf", zl(2, 2, t.authorization[0])) } } function mM(t, e) { 1 & t && Lo(0, "tr", 72) } function gM(t, e) { 1 & t && Lo(0, "tr", 73) } function yM(t, e) { if (1 & t && (Ro(0, "td", 56), Ro(1, "div", 57), Ro(2, "table", 58), Fo(3, 33), Eo(4, iM, 2, 0, "th", 26), Eo(5, sM, 7, 7, "td", 59), No(), Fo(6, 60), Eo(7, oM, 2, 0, "th", 26), Eo(8, hM, 3, 5, "td", 61), No(), Fo(9, 62), Eo(10, uM, 2, 0, "th", 26), Eo(11, fM, 3, 5, "td", 63), No(), Eo(12, mM, 1, 0, "tr", 38), Eo(13, gM, 1, 0, "tr", 64), Mo(), Mo(), Mo()), 2 & t) { const t = e.$implicit, n = Go(2); So("colspan", n.columnsToDisplay.length), yr(1), Do("@detailExpand", t == n.expandedElement ? "expanded" : "collapsed"), yr(1), Do("dataSource", t.actions), yr(10), Do("matHeaderRowDef", n.columnsInside)("matHeaderRowDefSticky", !0), yr(1), Do("matRowDefColumns", n.columnsInside) } } function _M(t, e) { 1 & t && Lo(0, "tr", 72) } function vM(t, e) { if (1 & t) { const t = jo(); Ro(0, "tr", 74), Ho("click", (function () { Ze(t); const n = e.$implicit, i = Go(2); return i.expandedElement = i.expandedElement === n ? null : n })), Mo() } if (2 & t) { const t = e.$implicit; sa("expanded-row", Go(2).expandedElement === t) } } function bM(t, e) { 1 & t && Lo(0, "tr", 75) } const wM = function () { return ["expandedDetail"] }; function xM(t, e) { if (1 & t && (Ro(0, "div", 7), Ro(1, "mat-card", 8), Ro(2, "div", 9), Ro(3, "div", 10), Ro(4, "h2"), Ro(5, "fa-layers", 11), Lo(6, "fa-icon", 12), Lo(7, "fa-icon", 13), Mo(), Ro(8, "span", 5), ga(9, "Block"), Mo(), ga(10), Mo(), Ro(11, "mat-chip-list", 14), Eo(12, UR, 3, 1, "mat-chip", 15), Eo(13, $R, 3, 2, "mat-chip", 16), Mo(), Mo(), Mo(), Ro(14, "div", 17), Ro(15, "div"), Ro(16, "span", 18), ga(17, "Block ID: "), Mo(), Ro(18, "span", 19), ga(19), Mo(), Mo(), Ro(20, "div"), Ro(21, "span", 18), ga(22, "Producer: "), Mo(), ga(23), Mo(), Ro(24, "div"), Ro(25, "span", 18), ga(26, "Time: "), Mo(), ga(27), Mo(), Mo(), Mo(), Ro(28, "mat-card", 8), Ro(29, "h3", 20), Ro(30, "fa-layers", 11), Lo(31, "fa-icon", 21), Lo(32, "fa-icon", 22), Mo(), ga(33), Eo(34, qR, 2, 0, "span", 23), Mo(), Ro(35, "table", 24), Fo(36, 25), Eo(37, WR, 1, 0, "th", 26), Eo(38, GR, 3, 1, "td", 27), No(), Fo(39, 28), Eo(40, YR, 2, 0, "th", 26), Eo(41, KR, 3, 4, "td", 29), No(), Fo(42, 30), Eo(43, QR, 2, 0, "th", 31), Eo(44, tM, 7, 8, "td", 32), No(), Fo(45, 33), Eo(46, eM, 2, 0, "th", 34), Eo(47, nM, 2, 1, "td", 35), No(), Fo(48, 36), Eo(49, yM, 14, 6, "td", 37), No(), Eo(50, _M, 1, 0, "tr", 38), Eo(51, vM, 1, 2, "tr", 39), Eo(52, bM, 1, 0, "tr", 40), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(5), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faBlock)("inverse", !0), yr(3), _a(" ", t.block.number, " "), yr(2), Do("ngIf", t.accountService.libNum > t.block.number), yr(1), Do("ngIf", t.accountService.libNum < t.block.number), yr(6), ya(t.block.id), yr(4), ya(t.block.producer), yr(4), ya(t.formatDate(t.block.timestamp)), yr(3), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faHistory)("inverse", !0), yr(1), _a(" ", t.block.transactions.length, " Transaction"), yr(1), Do("ngIf", t.block.transactions.length > 1), yr(1), Do("dataSource", t.block.transactions), yr(15), Do("matHeaderRowDef", t.columnsToDisplay)("matHeaderRowDefSticky", !0), yr(1), Do("matRowDefColumns", t.columnsToDisplay), yr(1), Do("matRowDefColumns", Ml(21, wM)) } } let CM = (() => { class t { constructor(t, e, n, i) { this.activatedRoute = t, this.accountService = e, this.chainData = n, this.title = i, this.columnsToDisplay = ["icon", "id", "root", "action"], this.columnsInside = ["action", "data", "auth"], this.faCircle = gT.faCircle, this.faBlock = BR.faCube, this.faLock = ZI.faLock, this.faHourglass = JI.faHourglassStart, this.faHistory = vT.faHistory, this.faChevronRight = qT.faChevronRight, this.faChevronDown = WT.faChevronDown, this.faSadTear = XT.faSadTear, this.faSpinner = tR.faSpinner, this.block = { transactions: [], status: "", number: 0 }, this.countdownTimer = 0 } objectKeyCount(t) { try { return Object.keys(t).length } catch (GM) { return 0 } } ngOnInit() { this.activatedRoute.params.subscribe(t => sS(this, void 0, void 0, (function* () { this.blockNum = t.block_num, this.block = yield this.accountService.loadBlockData(t.block_num), this.title.setTitle(this.chainData.chainInfoData.chain_name ? `#${t.block_num} \u2022 ${this.chainData.chainInfoData.chain_name} Hyperion Explorer` : `#${t.block_num} \u2022 Hyperion Explorer`), this.block && "pending" === this.block.status && (yield this.reloadCountdownTimer(), this.countdownLoop = setInterval(() => sS(this, void 0, void 0, (function* () { this.countdownTimer--, this.countdownTimer <= 0 && (yield this.reloadCountdownTimer(), this.accountService.libNum > this.block.number && clearInterval(this.countdownLoop)) })), 1e3)) }))) } reloadCountdownTimer() { return sS(this, void 0, void 0, (function* () { yield this.accountService.updateLib(), this.countdownTimer = Math.ceil((this.block.number - this.accountService.libNum) / 2) })) } ngOnDestroy() { this.countdownLoop && clearInterval(this.countdownLoop) } formatDate(t) { return new Date(t).toLocaleString() } } return t.\u0275fac = function (e) { return new (e || t)(Ao(vg), Ao(ck), Ao(uk), Ao(Uu)) }, t.\u0275cmp = me({ type: t, selectors: [["app-block"]], decls: 3, vars: 3, consts: [["mode", "indeterminate", 3, "diameter", 4, "ngIf"], ["class", "container", "fxLayout", "column", "style", "height: calc(100vh - 209px);", 4, "ngIf"], ["class", "container", "fxLayout", "column", "fxLayoutGap", "15px", "fxLayoutAlign", "start center", 4, "ngIf"], ["mode", "indeterminate", 3, "diameter"], ["fxLayout", "column", 1, "container", 2, "height", "calc(100vh - 209px)"], [1, "faded"], [2, "margin-right", "5px", 3, "icon"], ["fxLayout", "column", "fxLayoutGap", "15px", "fxLayoutAlign", "start center", 1, "container"], ["fxFlex", "100", "fxFlexFill", ""], [2, "border-bottom", "1px solid #e4e4e4", "margin-bottom", "12px"], ["fxLayout", "row", "fxLayoutAlign", "start center", "fxLayoutGap", "10px"], [2, "margin-right", "5px", 3, "fixedWidth"], ["transform", "grow-1", 3, "icon"], ["transform", "shrink-4", 3, "icon", "inverse"], ["orientation", "vertical"], ["selected", "", 4, "ngIf"], ["color", "accent", "selected", "", 4, "ngIf"], ["fxLayout", "column", "fxLayoutAlign", "start stretch", "fxLayoutGap", "10px"], [1, "w-500"], [1, "break-word"], [2, "margin-top", "0"], ["transform", "grow-3", 3, "icon"], ["transform", "shrink-5", 3, "icon", "inverse"], [4, "ngIf"], ["mat-table", "", "multiTemplateDataRows", "", 1, "transactions-table", 3, "dataSource"], ["matColumnDef", "icon"], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Tap to see all actions", 4, "matCellDef"], ["matColumnDef", "id"], ["mat-cell", "", "data-label", "TX ID", 4, "matCellDef"], ["matColumnDef", "root"], ["mat-header-cell", "", "style", "padding-left: 10px;", 4, "matHeaderCellDef"], ["mat-cell", "", "data-label", "Root Action", 4, "matCellDef"], ["matColumnDef", "action"], ["mat-header-cell", "", "style", "text-align: center", 4, "matHeaderCellDef"], ["mat-cell", "", "style", "text-align: center", "data-label", "# Actions", 4, "matCellDef"], ["matColumnDef", "expandedDetail"], ["mat-cell", "", 4, "matCellDef"], ["mat-header-row", "", 4, "matHeaderRowDef", "matHeaderRowDefSticky"], ["mat-row", "", "class", "element-row", 3, "expanded-row", "click", 4, "matRowDef", "matRowDefColumns"], ["mat-row", "", "class", "detail-row", 4, "matRowDef", "matRowDefColumns"], ["selected", ""], ["color", "accent", "selected", ""], ["mat-header-cell", ""], ["mat-cell", "", "data-label", "Tap to see all actions"], ["mat-icon-button", ""], [3, "icon"], ["mat-cell", "", "data-label", "TX ID"], [1, "link-blue", "break-word", 3, "routerLink"], ["mat-header-cell", "", 2, "padding-left", "10px"], ["mat-cell", "", "data-label", "Root Action"], [1, "action-cell", 3, "ngStyle.gt-xs", "ngClass.gt-sm"], [1, "accent", "w-500"], [1, "w-500", "div-link", 3, "routerLink"], ["mat-header-cell", "", 2, "text-align", "center"], ["mat-cell", "", "data-label", "# Actions", 2, "text-align", "center"], ["mat-cell", ""], [1, "element-detail"], ["mat-table", "", 1, "actions-table", 3, "dataSource"], ["mat-cell", "", "data-label", "Action", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["matColumnDef", "data"], ["mat-cell", "", "data-label", "Data", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["matColumnDef", "auth"], ["mat-cell", "", "data-label", "Authorization", 3, "ngStyle.gt-xs", 4, "matCellDef"], ["mat-row", "", 4, "matRowDef", "matRowDefColumns"], ["mat-cell", "", "data-label", "Action", 3, "ngStyle.gt-xs"], ["mat-cell", "", "data-label", "Data", 3, "ngStyle.gt-xs"], [3, "ngClass", 4, "ngFor", "ngForOf"], [3, "ngClass"], ["mat-cell", "", "data-label", "Authorization", 3, "ngStyle.gt-xs"], ["class", "data-item", 4, "ngFor", "ngForOf"], [1, "data-item"], ["mat-header-row", ""], ["mat-row", ""], ["mat-row", "", 1, "element-row", 3, "click"], ["mat-row", "", 1, "detail-row"]], template: function (t, e) { 1 & t && (Eo(0, zR, 1, 1, "mat-progress-spinner", 0), Eo(1, HR, 9, 2, "div", 1), Eo(2, xM, 53, 22, "div", 2)), 2 & t && (Do("ngIf", !e.accountService.loaded), yr(1), Do("ngIf", !e.block && e.accountService.loaded), yr(1), Do("ngIf", e.block && e.accountService.loaded)) }, directives: [$h, JP, rE, QE, CA, uE, VE, CE, IE, SA, pR, HS, YS, WS, $S, ZS, tk, oR, KS, QS, rO, Ty, WA, DA, Ay, Hh, Bh, nk, rk], pipes: [ru], styles: [".container[_ngcontent-%COMP%]{margin-top:112px}.title[_ngcontent-%COMP%]{font-size:21px;color:#00a6de;font-weight:500}.used[_ngcontent-%COMP%]{margin-left:7px}.faded[_ngcontent-%COMP%]{color:#a4a4a4}table[_ngcontent-%COMP%]{width:100%}.actions-table[_ngcontent-%COMP%]{width:100%;border:1px solid #e0e0e0;border-radius:5px;margin:5px 0 15px;padding:2px 0 1px}.action-cell[_ngcontent-%COMP%]{padding:5px 10px;font-size:13px;letter-spacing:.5px}.action-border[_ngcontent-%COMP%]{border:1px solid #f0f0f0;border-radius:3px}.data-item[_ngcontent-%COMP%]{padding-bottom:4px}.expanded-row[_ngcontent-%COMP%], tr.detail-row[_ngcontent-%COMP%]{background:#f5f5f5}tr.detail-row[_ngcontent-%COMP%]{height:0!important}tr.element-row[_ngcontent-%COMP%]:not(.expanded-row):hover{background:#f5f5f5;cursor:pointer}tr.element-row[_ngcontent-%COMP%]:not(.expanded-row):active{background:#efefef}.element-row[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border-bottom-width:0}.element-detail[_ngcontent-%COMP%]{overflow:hidden;display:flex;max-width:1118px}.element-diagram[_ngcontent-%COMP%]{min-width:80px;border:2px solid #000;padding:8px;font-weight:lighter;margin:8px 0;height:104px}.element-symbol[_ngcontent-%COMP%]{font-weight:700;font-size:40px;line-height:normal}.element-description[_ngcontent-%COMP%]{padding:16px}.element-description-attribution[_ngcontent-%COMP%]{opacity:.5}@media (max-width:599px){td.mat-cell[_ngcontent-%COMP%]:not(:last-of-type):not(:first-of-type){border-bottom-width:1px!important;border-bottom-style:solid}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;height:auto;position:-webkit-sticky;position:sticky;top:0;z-index:2}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%]{display:none}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container[_ngcontent-%COMP%]{padding-left:15px}.mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container.mat-column-actions[_ngcontent-%COMP%], .mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container.mat-sort-header-disabled[_ngcontent-%COMP%], .mat-table[_ngcontent-%COMP%]   .mat-header-row[_ngcontent-%COMP%]   th.mat-header-cell[_ngcontent-%COMP%] > .mat-sort-header-container[_ngcontent-%COMP%]:not([mat-sort-header]){display:none}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]{height:auto}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions){display:grid;grid-template-columns:50% 50%;padding:.5rem;text-align:left;word-break:break-word}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell.mat-column-expandedDetail[_ngcontent-%COMP%]:not(.mat-column-actions){display:grid;grid-template-columns:0 100%}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions) > *[_ngcontent-%COMP%]{grid-column:2}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell[_ngcontent-%COMP%]:not(.mat-column-actions):before{content:attr(data-label);text-align:left;font-size:12px;font-weight:500;color:rgba(0,0,0,.54)}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-cell.mat-column-icon[_ngcontent-%COMP%]:not(.mat-column-actions):before{align-self:center}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-column-actions[_ngcontent-%COMP%]{display:flex;justify-content:center;padding:0 .5rem}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]   td.mat-column-actions[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]{margin:.5rem 0}.mat-table[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]:last-of-type   td[_ngcontent-%COMP%]:last-of-type{border:none}.mat-table[_ngcontent-%COMP%]   .mat-column-expandedDetail[_ngcontent-%COMP%]   .mat-row[_ngcontent-%COMP%]:not(:last-of-type)   td[_ngcontent-%COMP%]:last-of-type{border-bottom:.5rem solid #e5e5e5;padding-bottom:20px!important;margin-bottom:20px}.mat-card[_ngcontent-%COMP%]   .mat-expansion-panel[_ngcontent-%COMP%]   .mat-table[_ngcontent-%COMP%]{border:.5rem solid #fafafa}}"], data: { animation: [qu("detailExpand", [Ku("collapsed", Xu({ height: "0px", minHeight: "0" })), Ku("expanded", Xu({ height: "*" })), Zu("expanded <=> collapsed", Wu("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])] } }), t })(); function SM(t, e) { 1 & t && Lo(0, "mat-progress-spinner", 3), 2 & t && Do("diameter", 45) } function kM(t, e) { if (1 & t && (Ro(0, "div", 4), Ro(1, "mat-card", 5), Ro(2, "h1", 6), Lo(3, "fa-icon", 7), ga(4, " Key not found "), Mo(), Ro(5, "div"), ga(6, "We couldn't find the key "), Ro(7, "strong", 8), ga(8), Mo(), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(3), Do("icon", t.faSadTear), yr(5), ya(t.pubKey) } } const EM = function (t) { return ["/account", t] }; function OM(t, e) { if (1 & t && (Ro(0, "div", 21), Ro(1, "a", 22), ga(2), Mo(), Ro(3, "span", 23), ga(4), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(1), Do("routerLink", Ll(3, EM, t.owner)), yr(1), ya(t.owner), yr(2), ya(t.name) } } function AM(t, e) { if (1 & t && (Fo(0), Eo(1, OM, 5, 5, "div", 20), No()), 2 & t) { const t = Go(2); yr(1), Do("ngForOf", t.key.permissions) } } function TM(t, e) { if (1 & t && (Ro(0, "div", 21), Ro(1, "a", 22), ga(2), Mo(), Mo()), 2 & t) { const t = e.$implicit; yr(1), Do("routerLink", Ll(2, EM, t)), yr(1), ya(t) } } function PM(t, e) { if (1 & t && (Fo(0), Eo(1, TM, 3, 4, "div", 20), No()), 2 & t) { const t = Go(2); yr(1), Do("ngForOf", t.key.account_names) } } function DM(t, e) { if (1 & t && (Ro(0, "div", 9), Ro(1, "mat-card", 10), Ro(2, "div", 11), Ro(3, "div", 12), Ro(4, "h2", 13), Ro(5, "fa-layers", 14), Lo(6, "fa-icon", 15), Lo(7, "fa-icon", 16), Mo(), ga(8, " Public Key "), Mo(), Mo(), Ro(9, "h4", 17), ga(10), Mo(), Mo(), Ro(11, "div"), Ro(12, "h4", 18), ga(13, "Associated accounts:"), Mo(), Eo(14, AM, 2, 1, "ng-container", 19), Eo(15, PM, 2, 1, "ng-container", 19), Mo(), Mo(), Mo()), 2 & t) { const t = Go(); yr(5), Do("fixedWidth", !0), yr(1), Do("icon", t.faCircle), yr(1), Do("icon", t.faKey)("inverse", !0), yr(3), ya(t.pubKey), yr(4), Do("ngIf", t.key.permissions.length > 0), yr(1), Do("ngIf", 0 === t.key.permissions.length) } } let IM = (() => { class t { constructor(t, e, n, i) { this.activatedRoute = t, this.accountService = e, this.chainData = n, this.title = i, this.key = { account_names: null, permissions: null }, this.faCircle = gT.faCircle, this.faKey = GT.faKey, this.faSadTear = XT.faSadTear, this.faSpinner = tR.faSpinner } ngOnInit() { this.activatedRoute.params.subscribe(t => sS(this, void 0, void 0, (function* () { this.pubKey = t.key, this.key = yield this.accountService.loadPubKey(t.key), this.title.setTitle(this.chainData.chainInfoData.chain_name ? `\u{1f511} ${t.key.slice(0, 12)} \u2022 ${this.chainData.chainInfoData.chain_name} Hyperion Explorer` : `\u{1f511} ${t.key.slice(0, 12)} \u2022 Hyperion Explorer`) }))) } } return t.\u0275fac = function (e) { return new (e || t)(Ao(vg), Ao(ck), Ao(uk), Ao(Uu)) }, t.\u0275cmp = me({ type: t, selectors: [["app-key"]], decls: 3, vars: 3, consts: [["mode", "indeterminate", 3, "diameter", 4, "ngIf"], ["class", "container", "fxLayout", "column", "style", "height: calc(100vh - 209px);", "fxLayoutAlign", "start center", 4, "ngIf"], ["class", "container", "fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 4, "ngIf"], ["mode", "indeterminate", 3, "diameter"], ["fxLayout", "column", "fxLayoutAlign", "start center", 1, "container", 2, "height", "calc(100vh - 209px)"], [2, "width", "100%"], [1, "faded"], [2, "margin-right", "5px", 3, "icon"], [1, "break-word"], ["fxLayout", "column", "fxLayoutAlign", "start center", "fxLayoutGap", "15px", 1, "container"], ["fxFlex", "100", "fxFlexFill", ""], [2, "border-bottom", "1px solid #e4e4e4", "margin-bottom", "12px"], ["fxLayout", "row", "fxLayoutAlign", "start start"], [2, "margin-bottom", "-15px", "color", "#9c9c9c", "margin-top", "0", "margin-right", "10px"], [2, "margin-right", "2px", 3, "fixedWidth"], ["transform", "grow-1", 3, "icon"], ["transform", "shrink-4", 3, "icon", "inverse"], [1, "break-word", 2, "margin", "27px 0 12px 0"], [2, "font-weight", "500"], [4, "ngIf"], ["class", "account-cell", 4, "ngFor", "ngForOf"], [1, "account-cell"], [3, "routerLink"], [1, "permission"]], template: function (t, e) { 1 & t && (Eo(0, SM, 1, 1, "mat-progress-spinner", 0), Eo(1, kM, 9, 2, "div", 1), Eo(2, DM, 16, 7, "div", 2)), 2 & t && (Do("ngIf", !e.accountService.loaded), yr(1), Do("ngIf", e.key.account_names && 0 === e.key.account_names.length && e.accountService.loaded), yr(1), Do("ngIf", e.key.account_names && e.key.account_names.length > 0 && e.accountService.loaded)) }, directives: [$h, JP, rE, VE, QE, CA, uE, CE, IE, SA, Hh, Ty], styles: [".container[_ngcontent-%COMP%]{margin-top:112px}.account-cell[_ngcontent-%COMP%]{padding:20px 10px 10px;letter-spacing:.5px;font-size:14px;width:160px;border-bottom:1px solid rgba(0,0,0,.12);border-radius:3px}.permission[_ngcontent-%COMP%]{color:rgba(0,0,0,.54);font-size:12px;font-weight:500;text-align:right;float:right}"] }), t })(); const RM = new b(om), MM = "Service workers are disabled or not supported by this browser"; class LM { constructor(t) { if (this.serviceWorker = t, t) { const e = Vw(t, "controllerchange").pipe(N(() => t.controller)), n = tm(kf(() => gf(t.controller)), e); this.worker = n.pipe(Of(t => !!t)), this.registration = this.worker.pipe(Qf(() => t.getRegistration())); const i = Vw(t, "message").pipe(N(t => t.data)).pipe(Of(t => t && t.type)).pipe(tt(new k)); i.connect(), this.events = i } else this.worker = this.events = this.registration = kf(() => Hx(new Error("Service workers are disabled or not supported by this browser"))) } postMessage(t, e) { return this.worker.pipe(qf(1), am(n => { n.postMessage(Object.assign({ action: t }, e)) })).toPromise().then(() => { }) } postMessageWithStatus(t, e, n) { const i = this.waitForStatus(n), r = this.postMessage(t, e); return Promise.all([i, r]).then(() => { }) } generateNonce() { return Math.round(1e7 * Math.random()) } eventsOfType(t) { return this.events.pipe(Of(e => e.type === t)) } nextEventOfType(t) { return this.eventsOfType(t).pipe(qf(1)) } waitForStatus(t) { return this.eventsOfType("STATUS").pipe(Of(e => e.nonce === t), qf(1), N(t => { if (!t.status) throw new Error(t.error) })).toPromise() } get isEnabled() { return !!this.serviceWorker } } let FM = (() => { class t { constructor(t) { if (this.sw = t, this.subscriptionChanges = new k, !t.isEnabled) return this.messages = RM, this.notificationClicks = RM, void (this.subscription = RM); this.messages = this.sw.eventsOfType("PUSH").pipe(N(t => t.data)), this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(N(t => t.data)), this.pushManager = this.sw.registration.pipe(N(t => t.pushManager)); const e = this.pushManager.pipe(Qf(t => t.getSubscription())); this.subscription = G(e, this.subscriptionChanges) } get isEnabled() { return this.sw.isEnabled } requestSubscription(t) { if (!this.sw.isEnabled) return Promise.reject(new Error(MM)); const e = { userVisibleOnly: !0 }; let n = this.decodeBase64(t.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+")), i = new Uint8Array(new ArrayBuffer(n.length)); for (let r = 0; r < n.length; r++)i[r] = n.charCodeAt(r); return e.applicationServerKey = i, this.pushManager.pipe(Qf(t => t.subscribe(e)), qf(1)).toPromise().then(t => (this.subscriptionChanges.next(t), t)) } unsubscribe() { return this.sw.isEnabled ? this.subscription.pipe(qf(1), Qf(t => { if (null === t) throw new Error("Not subscribed to push notifications."); return t.unsubscribe().then(t => { if (!t) throw new Error("Unsubscribe failed!"); this.subscriptionChanges.next(null) }) })).toPromise() : Promise.reject(new Error(MM)) } decodeBase64(t) { return atob(t) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(LM)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), NM = (() => { class t { constructor(t) { if (this.sw = t, !t.isEnabled) return this.available = RM, void (this.activated = RM); this.available = this.sw.eventsOfType("UPDATE_AVAILABLE"), this.activated = this.sw.eventsOfType("UPDATE_ACTIVATED") } get isEnabled() { return this.sw.isEnabled } checkForUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(MM)); const t = this.sw.generateNonce(); return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES", { statusNonce: t }, t) } activateUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(MM)); const t = this.sw.generateNonce(); return this.sw.postMessageWithStatus("ACTIVATE_UPDATE", { statusNonce: t }, t) } } return t.\u0275fac = function (e) { return new (e || t)(Kt(LM)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class VM { } const jM = new Bt("NGSW_REGISTER_SCRIPT"); function BM(t, e, n, i) { return () => { if (!lu(i) || !("serviceWorker" in navigator) || !1 === n.enabled) return; let r; if (navigator.serviceWorker.addEventListener("controllerchange", () => { null !== navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({ action: "INITIALIZE" }) }), "function" == typeof n.registrationStrategy) r = n.registrationStrategy(); else { const [e, ...i] = (n.registrationStrategy || "registerWhenStable").split(":"); switch (e) { case "registerImmediately": r = gf(null); break; case "registerWithDelay": r = gf(null).pipe(BC(+i[0] || 0)); break; case "registerWhenStable": r = t.get(eh).isStable.pipe(Of(t => t)); break; default: throw new Error(`Unknown ServiceWorker registration strategy: ${n.registrationStrategy}`) } } r.pipe(qf(1)).subscribe(() => navigator.serviceWorker.register(e, { scope: n.scope }).catch(t => console.error("Service worker registration failed with:", t))) } } function zM(t, e) { return new LM(lu(e) && !1 !== t.enabled ? navigator.serviceWorker : void 0) } let HM = (() => { class t { static register(e, n = {}) { return { ngModule: t, providers: [{ provide: jM, useValue: e }, { provide: VM, useValue: n }, { provide: LM, useFactory: zM, deps: [VM, vc] }, { provide: pc, useFactory: BM, deps: [lo, jM, VM, vc], multi: !0 }] } } } return t.\u0275mod = ve({ type: t }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [FM, NM] }), t })(); const UM = [{ path: "", component: AA }, { path: "", component: ZA, children: [{ path: "account/:account_name", component: YI }, { path: "transaction/:transaction_id", component: jR }, { path: "block/:block_num", component: CM }, { path: "key/:key", component: IM }] }, { path: "**", component: AA }]; let $M = (() => { class t extends jP { constructor(t) { super(), this.accountService = t, this.getRangeLabel = (t, e, n) => { if (0 === n || 0 === e) return `0 of ${n}`; const i = t * e; return `${i + 1} \u2013 ${i < (n = Math.max(n, 0)) ? Math.min(i + e, n) : i + e} of ${this.accountService.jsonData.total_actions} (${n} loaded)` } } } return t.\u0275fac = function (e) { return new (e || t)(Kt(ck)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), qM = (() => { class t { } return t.\u0275mod = ve({ type: t, bootstrap: [rS] }), t.\u0275inj = pt({ factory: function (e) { return new (e || t) }, providers: [{ provide: jP, useClass: $M }], imports: [[zu, mf, HM.register("./ngsw-worker.js", { enabled: !0, scope: "/", registrationStrategy: "registerImmediately" }), Uy.forRoot(UM, { scrollPositionRestoration: "enabled" }), Qv, T_, Nw, xx, Nx, iS, ZE, kA, sO, KI, lD, HT, jS, ok, qP, pT, IP, mR, MD, Uy, tD]] }), t })(); (function () { if (ki) throw new Error("Cannot enable prod mode after platform setup."); Si = !1 })(), document.addEventListener("DOMContentLoaded", () => { ju().bootstrapModule(qM).catch(t => console.error(t)) }) }, zn8P: function (t, e) { function n(t) { return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })) } n.keys = function () { return [] }, n.resolve = n, t.exports = n, n.id = "zn8P" } }, [[0, 0]]]);